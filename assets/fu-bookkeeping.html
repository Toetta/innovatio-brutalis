<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FU-BOOKKEEPING – Offline bookkeeping in your browser</title>

  <link rel="canonical" href="https://www.innovatio-brutalis.se/assets/fu-bookkeeping.html" />

  <meta property="og:type" content="website" />
  <meta property="og:title" content="FU-BOOKKEEPING – Offline bookkeeping in your browser" />
  <meta property="og:description" content="Offline bookkeeping with audit log, archive package and OCR. Runs locally in the browser." />
  <meta property="og:url" content="https://www.innovatio-brutalis.se/assets/fu-bookkeeping.html" />
  <meta property="og:image" content="https://www.innovatio-brutalis.se/assets/fu-bookkeeping-preview.jpg" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:image:alt" content="FU-BOOKKEEPING screenshot" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://www.innovatio-brutalis.se/assets/fu-bookkeeping-preview.jpg" />

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-LGJK9XKDZB"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-LGJK9XKDZB');
  </script>
  <style>
    html{ font-size: clamp(14px, 1.05vw, 16px); }
    :root{ --bg:#0b0f14; --card:#111826; --muted:#94a3b8; --text:#e5e7eb; --line:#223044; --ok:#22c55e; --bad:#ef4444; --accent:#60a5fa; }
    *{ box-sizing:border-box; }
    *[hidden]{ display:none !important; }
    body{ margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,#0b0f14,#070a0f); color:var(--text); }
    /* Header/nav: force-disable any lingering backdrop-filter (it can break clicks in some setups) */
    header{
      position:relative;
      z-index:5;
      background:rgba(11,15,20,.98);
      border-bottom:1px solid var(--line);
      backdrop-filter:none !important;
      -webkit-backdrop-filter:none !important;
      transform:none !important;
    }
    header::before{ content:none !important; }
    header .wrap, header nav{ position:relative; z-index:10; }
    header nav{ pointer-events:auto !important; }
    .tab{ pointer-events:auto !important; }

    /* Extra safety: ensure nothing overlays the nav row */
    header nav *{ pointer-events:auto !important; }

    .wrap{ max-width:1400px; margin:0 auto; padding:clamp(10px, 1.2vw, 16px); }

    /* Layout with vertical navigation (grouped fly-out) */
    .layout{ display:grid; grid-template-columns: 210px 1fr; gap:12px; align-items:start; min-width:0; }
    .sidebar{
      padding:12px;
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(17,24,38,.90);
      box-shadow: 0 10px 30px rgba(0,0,0,.18);
      position:relative;
      z-index:20;
    }
    .sidebar .navGroup{ position:relative; margin-bottom:8px; }
    .sidebar .navGroup:last-child{ margin-bottom:0; }

    .navGroupBtn{
      width:100%;
      text-align:left;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background:transparent;
      color:var(--muted);
      border:1px solid var(--line);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
    }
    .navGroupBtn:focus{
      outline:none;
      border-color:rgba(96,165,250,.7);
      box-shadow:0 0 0 3px rgba(96,165,250,.12);
    }
    .navGroup.open .navGroupBtn{
      border-color:rgba(96,165,250,.7);
      box-shadow:0 0 0 3px rgba(96,165,250,.12);
    }
.navGroup.hasActive .navGroupBtn{
      color:var(--text);
    }
    .navGroupBtn .chev{ transition: transform .15s ease; opacity:.8; }
    .navGroup.open .navGroupBtn .chev{ transform: rotate(90deg); }

    .navFlyout{
      display:none;
      position:absolute;
      left: calc(100% + 10px);
      top:0;
      min-width:240px;
      max-width:330px;
      padding:10px;
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(17,24,38,.96);
      box-shadow: 0 18px 45px rgba(0,0,0,.35);
      z-index:60;
    }
    .navGroup.open .navFlyout{ display:grid; gap:8px; }
    .navFlyout .tab{ width:100%; text-align:left; }

    .content{ min-width:0; overflow:hidden; position:relative; z-index:1; }

    @media (max-width: 900px){
      .layout{ grid-template-columns: 1fr; }
      .navFlyout{
        position:static;
        left:auto;
        top:auto;
        min-width:0;
        max-width:none;
        margin-top:8px;
        padding:8px;
        box-shadow:none;
        border-radius:14px;
      }
    }
    .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .header-row{ align-items:flex-end; }
    .header-row .pill{ align-self:flex-end; }
    .header-row .field{ align-self:flex-end; }
    h1{ margin:0; font-size:18px; font-weight:700; }
    .pill{ font-size:12px; color:var(--muted); border:1px solid var(--line); padding:6px 10px; border-radius:999px; }
    .pill.ok{ border:3px solid rgba(34,197,94,.7); background:rgba(34,197,94,.08); color:var(--text); }
    .pill.bad{ border:3px solid rgba(239,68,68,.7); background:rgba(239,68,68,.08); color:var(--text); }
    /* Header year dropdown should look like a pill */
    select.pill{
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
      background:rgba(17,24,38,.85);
      color:var(--text);
      cursor:pointer;
      border:1px solid rgba(96,165,250,.45);
      padding:8px 34px 8px 12px;
      border-radius:999px;
      font-weight:700;
      min-width: 340px;
      max-width: 100%;
      background-image:
        linear-gradient(45deg, transparent 50%, var(--text) 50%),
        linear-gradient(135deg, var(--text) 50%, transparent 50%);
      background-position: calc(100% - 14px) 55%, calc(100% - 9px) 55%;
      background-size:5px 5px, 5px 5px;
      background-repeat:no-repeat;
    }
    select.pill:focus{
      outline:none;
      border-color:rgba(96,165,250,.7);
      box-shadow:0 0 0 3px rgba(96,165,250,.12);
    }

    nav{ display:flex; gap:8px; margin-top:12px; flex-wrap:wrap; }
    button, input, select, textarea{ font:inherit; }
    .tab{ background:transparent; color:var(--muted); border:1px solid var(--line); padding:8px 12px; border-radius:10px; cursor:pointer; }
    .tab.active{ color:var(--text); border-color:rgba(96,165,250,.7); box-shadow:0 0 0 3px rgba(96,165,250,.12); }
    main .wrap{ padding-top:18px; }
    .grid{ display:grid; grid-template-columns: 1fr; gap:12px; min-width:0; }
    @media (min-width: 980px){ .grid.two{ grid-template-columns: minmax(0, 1.25fr) minmax(0, 1fr); } }
    .card{ isolation:isolate; overflow:hidden; background:rgba(17,24,38,.94); border:1px solid var(--line); border-radius:16px; padding:14px; box-shadow: 0 10px 30px rgba(0,0,0,.25);  min-width:0; overflow:hidden; }
    .card h2{ margin:0 0 10px 0; font-size:14px; color:var(--muted); font-weight:700; letter-spacing:.02em; }
    .muted{ color:var(--muted); }
    .btn{ background:rgba(96,165,250,.15); border:1px solid rgba(96,165,250,.4); color:var(--text); padding:8px 12px; border-radius:12px; cursor:pointer; }
    .btn.secondary{ background:transparent; border-color:var(--line); color:var(--text); }
    .btn.danger{ background:rgba(239,68,68,.12); border-color:rgba(239,68,68,.35); }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .field{ display:grid; gap:6px; }
    .field label{ font-size:12px; color:var(--muted); }
    input, select, textarea{ background:#0b1220; color:var(--text); border:1px solid var(--line); border-radius:12px; padding:10px 10px; outline:none; }
    input:focus, select:focus, textarea:focus{ border-color:rgba(96,165,250,.7); box-shadow:0 0 0 3px rgba(96,165,250,.12); }
    textarea{ min-height: 84px; resize: vertical; }
    table{ width:100%; border-collapse: collapse; }
    th, td{ border-bottom:1px solid rgba(34,48,68,.8); padding:8px 8px; text-align:left; vertical-align:top; }
    th{ font-size:12px; color:var(--muted); font-weight:700; }
    td{ font-size:13px; }
    .right{ text-align:right; }

    /* Bankimport: keep Text/Referens readable and visible */
    .biPreviewTable{ table-layout:fixed; width:100%; }
    .biPreviewTable th,
    .biPreviewTable td{ overflow-wrap:anywhere; word-break:break-word; }
    .biInboxTable{ table-layout:fixed; width:100%; }
    .biInboxTable th,
    .biInboxTable td{ overflow-wrap:anywhere; word-break:break-word; }

    /* Voucher lines table: avoid horizontal scrollbar by letting content shrink */
    .linesTable{ table-layout:fixed; }
    .linesTable td > input,
    .linesTable td > select{
      width:100%;
      min-width:0;
      box-sizing:border-box;
    }
    .linesTable td:last-child{ text-align:center; }
    .linesTable td:last-child .btn{ padding:8px 10px; }
    .status{ font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid var(--line); }
    .status.ok{ color:var(--ok); border-color:rgba(34,197,94,.35); background:rgba(34,197,94,.08); }
    .status.bad{ color:var(--bad); border-color:rgba(239,68,68,.35); background:rgba(239,68,68,.08); }
    .list{ display:grid; gap:12px; }
    .item{ position:relative; overflow:hidden; padding:10px; border:1px solid var(--line); border-radius:14px; background:rgba(11,18,32,.92); }
    .item.voided{ opacity:.72; border-style:dashed; }
    .item .top{ display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .item .title{ font-weight:700; }
    .item .meta{ font-size:12px; color:var(--muted); }
    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; font-size:12px; color:var(--muted); }
    .small{ font-size:12px; }

    /* SRU (locked option) */
    .lockbox{ border:1px dashed rgba(148,163,184,.5); border-radius:16px; padding:12px; background:rgba(11,18,32,.55); }
    .lockbox .row{ justify-content:space-between; align-items:center; }
    .badge.lock{ display:inline-flex; align-items:center; gap:6px; font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid rgba(148,163,184,.35); color:var(--muted); background:rgba(148,163,184,.08);
    }
    .badge.lock b{ color:var(--text); }

    /* In-app toast (replaces browser alert for success messages) */
    .toast{
      position:fixed;
      top:12px;
      left:50%;
      transform:translateX(-50%);
      z-index:9999;
      max-width:min(520px, calc(100vw - 24px));
      background:rgba(17,24,38,.98);
      color:var(--text);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      text-align:center;
      font-size:13px;
    }

    /* In-app confirm modal (replaces browser confirm dialogs) */
    .modal-backdrop{
      position:fixed;
      inset:0;
      z-index:9998;
      background:rgba(0,0,0,.55);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:12px;
    }
    .modal{
      width:min(520px, calc(100vw - 24px));
      background:rgba(17,24,38,.98);
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .modal.wide{
      width:min(920px, calc(100vw - 24px));
      max-height:calc(100vh - 24px);
      overflow:auto;
    }
    .modal .actions{ display:flex; justify-content:flex-end; gap:10px; margin-top:12px; flex-wrap:wrap; }

  </style>

  <!-- OCR (offline i webbläsaren: körs lokalt, inga filer laddas upp) -->
  <script defer src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/legacy/build/pdf.min.js"></script>

</head>
<body>
<header>
  <div class="wrap">
    <div class="row header-row">
      <h1 id="companyName">FU-BOOKKEEPING</h1>
      <div class="field" style="gap:4px; min-width: 180px;">
        <select class="pill" id="companySelect" aria-label="Företag"></select>
<select class="pill" id="yearPillSelect" aria-label="Räkenskapsår"></select>
      </div>
      <span class="pill" id="bootPill">JS: laddar…</span>
      <span class="pill" id="storagePill">Lagring: localStorage (offline)</span>
      <span class="pill" id="backupPill">Backup: –</span>
      <span class="pill" id="revPill">v0.2.19</span>
    </div>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="layout">
      <aside class="sidebar" aria-label="Navigation">
        <div class="navGroup open" data-group="bookkeeping">
          <button type="button" class="navGroupBtn" aria-expanded="true" aria-controls="nav-bookkeeping">
            <span>Bokföring</span><span class="chev">▸</span>
          </button>
          <div class="navFlyout" id="nav-bookkeeping" role="menu">
            <button type="button" class="tab active" data-tab="vouchers">Verifikationer</button>
            <button type="button" class="tab" data-tab="accounts">Kontoplan</button>
          </div>
        </div>

        <div class="navGroup" data-group="sales">
          <button type="button" class="navGroupBtn" aria-expanded="false" aria-controls="nav-sales">
            <span>Försäljning</span><span class="chev">▸</span>
          </button>
          <div class="navFlyout" id="nav-sales" role="menu">
            <button type="button" class="tab" data-tab="invoices">Kundfakturor</button>
            <button type="button" class="tab" data-tab="customers">Kunder</button>
          </div>
        </div>

        <div class="navGroup" data-group="purchases">
          <button type="button" class="navGroupBtn" aria-expanded="false" aria-controls="nav-purchases">
            <span>Inköp</span><span class="chev">▸</span>
          </button>
          <div class="navFlyout" id="nav-purchases" role="menu">
            <button type="button" class="tab" data-tab="supplier_invoices">Leverantörsfakturor</button>
            <button type="button" class="tab" data-tab="suppliers">Leverantörer</button>
          </div>
        </div>

        <div class="navGroup" data-group="reporting">
          <button type="button" class="navGroupBtn" aria-expanded="false" aria-controls="nav-reporting">
            <span>Rapportering</span><span class="chev">▸</span>
          </button>
          <div class="navFlyout" id="nav-reporting" role="menu">
            <button type="button" class="tab" data-tab="reports">Rapporter</button>
            <button type="button" class="tab" data-tab="sru">Deklaration (SRU)</button>
          </div>
        </div>

        <div class="navGroup" data-group="data">
          <button type="button" class="navGroupBtn" aria-expanded="false" aria-controls="nav-data">
            <span>Data &amp; Arkiv</span><span class="chev">▸</span>
          </button>
          <div class="navFlyout" id="nav-data" role="menu">
            <button type="button" class="tab" id="btnBankImportOpen">Import: Bank &amp; Skattekonto</button>
            <button type="button" class="tab" data-tab="bank_inbox">Inkorg: Bankrader</button>
            <button type="button" class="tab" data-tab="export">Import/Export</button>
          </div>
        </div>

        <div class="navGroup" data-group="admin">
          <button type="button" class="navGroupBtn" aria-expanded="false" aria-controls="nav-admin">
            <span>Administration</span><span class="chev">▸</span>
          </button>
          <div class="navFlyout" id="nav-admin" role="menu">
            <button type="button" class="tab" data-tab="settings">Inställningar</button>
          </div>
        </div>
      </aside>
      <div class="content">

    <!-- VERIFIKATIONER -->
    <section id="tab-vouchers">
      <div class="grid two">
        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Ny verifikation</h2>
            <div class="row">
              <button class="btn secondary" id="btnFillExample">Fyll A76–A79 (exempel)</button>
              <button class="btn" id="btnNewVoucher">Ny</button>
            </div>
          </div>

          <div class="grid" style="gap:10px;">
            <div class="row" style="gap:10px;">
              <div class="field" style="min-width:140px;">
                <label>Datum</label>
                <input id="vDate" type="date" />
              </div>
              <div class="field" style="min-width:90px;">
                <label>Serie</label>
                <input id="vSeries" type="text" value="A" maxlength="10" />
              </div>
              <div class="field" style="min-width:110px;">
                <label>Vernr</label>
                <input id="vNo" type="text" placeholder="Auto" />
              </div>
              <div class="field" style="min-width:160px; flex:1;">
                <label>Text</label>
                <input id="vText" type="text" placeholder="t.ex. Lagerjustering" />
              </div>
              <div class="field" style="min-width:140px;">
                <label>Sign</label>
                <input id="vSign" type="text" placeholder="t.ex. MA" />
              </div>
            </div>

            <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
              <div class="row" style="justify-content:space-between; margin-bottom:8px;">
                <div class="muted small">Rader</div>
                <div class="row">
                  <span id="balanceBadge" class="status bad">Inte i balans</span>
                  <button class="btn secondary" id="btnAddLine">+ Rad</button>
                </div>
              </div>

              <div style="overflow:auto;">
                <table class="linesTable">
                  <thead>
                    <tr>
                      <th style="width:170px;">Konto</th>
                      <th>Radtext</th>
                      <th class="right" style="width:120px;">Debet</th>
                      <th class="right" style="width:120px;">Kredit</th>
                      <th style="width:56px;"></th>
                    </tr>
                  </thead>
                  <tbody id="linesTbody"></tbody>
                </table>
              </div>

              <div class="row" style="justify-content:space-between; margin-top:10px;">
                <div class="muted small">Tips: skriv 1460/1930 osv så filtreras listan.</div>
                <div class="row">
                  <button class="btn danger" id="btnClearVoucher">Rensa</button>
                  <button class="btn" id="btnSaveVoucher" disabled>Spara verifikation</button>
                </div>
              </div>
            </div>


            <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
              <div class="row" style="justify-content:space-between; margin-bottom:8px;">
                <div class="muted small">Underlag (kvitto/faktura/PDF/bild)</div>
                <div class="muted small">Lagring: lokalt i webbläsaren (IndexedDB)</div>
              </div>

              <div class="grid" style="gap:10px;">
                <div class="row" style="gap:10px; flex-wrap:wrap; align-items:flex-end;">
                  <div class="field" style="min-width:180px;">
                    <label>Underlagstyp</label>
                    <select id="uType">
                      <option value="kvitto">Kvitto</option>
                      <option value="leverantorsfaktura">Leverantörsfaktura</option>
                      <option value="kundfaktura">Kundfaktura</option>
                      <option value="bank">Bankunderlag</option>
                      <option value="annat">Annat</option>
                    </select>
                  </div>
                  <div class="field" style="min-width:220px; flex:1;">
                    <label>Underlags-ID/nummer</label>
                    <input id="uRef" type="text" placeholder="t.ex. LF 10233 / Kvitto 2026-001" />
                  </div>
                  <div class="field" style="min-width:240px; flex:1;">
                    <label>Notering (valfritt)</label>
                    <input id="uNote" type="text" placeholder="t.ex. leverantör, projekt, kommentar" />
                  </div>
                  <label class="btn secondary" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer; height:40px;">
                    + Lägg till filer
                    <input id="uFiles" type="file" multiple accept="application/pdf,image/*" hidden />
                  </label>
                </div>

                <div id="uList" class="list"></div>

                <div class="muted small">
                  Tips: För revisionsbarhet över tid – exportera “Arkivmapp (med underlag)” så hamnar JSON + underlag i samma mappstruktur.
                </div>
              </div>
            </div>

            <div class="muted small">
              Balansregler: Summan debet ska vara lika med summan kredit. Programmet använder <span class="kbd">+ = debet</span> och <span class="kbd">− = kredit</span> internt.
            </div>
          </div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Verifikationer i året</h2>
            <div class="row">
              <select id="yearSelect"></select>
              <button class="btn secondary" id="btnRefresh">Uppdatera</button>
            </div>
          </div>

          <div id="voucherList" class="list"></div>
        </div>
      </div>
    </section>

    <!-- KONTOPLAN -->
    <section id="tab-accounts" hidden>
      <div class="grid two">
        <div class="card">
          <h2>Lägg till konto</h2>
          <div class="row" style="gap:10px;">
            <div class="field" style="min-width:140px;">
              <label>Konto</label>
              <input id="aNo" placeholder="t.ex. 1930" />
            </div>
            <div class="field" style="flex:1; min-width:220px;">
              <label>Namn</label>
              <input id="aName" placeholder="t.ex. Företagskonto" spellcheck="true" lang="sv" />
            </div>
            <div class="field" style="min-width:180px;">
              <label>Typ (för rapporter)</label>
              <select id="aType">
                <option value="asset">Tillgång (klass 1)</option>
                <option value="liability">Eget kapital/skuld (klass 2)</option>
                <option value="income">Intäkt (klass 3)</option>
                <option value="expense">Kostnad (klass 4–8)</option>
                <option value="other">Övrigt</option>
              </select>
            </div>
            <button class="btn" id="btnAddAccount">Lägg till</button>
          </div>
          <p class="muted small" style="margin:10px 0 0 0;">Du kan lägga exakt de konton du vill (BAS). Appen kommer inte stoppa dig från att använda ett konto även om det är ”rubrik” – men rapporter blir bättre om du använder rätt underkonto (t.ex. 1460 i stället för 1400).</p>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Kontoplan</h2>
            <div class="row">
              <input id="accountSearch" placeholder="Sök (konto eller namn)" />
              <button class="btn danger" id="btnResetDemo">Återställ demo-kontoplan</button>
              <button class="btn secondary" id="btnExportAccountNameTemplate" title="Exporterar en CSV-mall (konto;namn;typ) som du kan rätta i Excel och sedan importera via Standardlista.">Exportera mall</button>
              <label class="btn secondary" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;" title="Välj en standardlista (CSV/JSON) för att auto-fixa konton som innehåller \"�\".">
                Standardlista
                <input id="stdAccountsFile" type="file" accept=".json,.csv,.txt" hidden />
              </label>
            </div>
          </div>
          <div style="overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th style="width:110px;">Konto</th>
                  <th>Namn</th>
                  <th style="width:170px;">Typ</th>
                  <th style="width:70px;"></th>
                </tr>
              </thead>
              <tbody id="accountsTbody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>

    <!-- RAPPORTER -->
    <section id="tab-reports" hidden>
      <div class="grid">
        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Rapportgenerator</h2>
            <div class="row">
              <button class="btn secondary" id="btnRptGenerate">Generera</button>
              <button class="btn" id="btnRptPrint" disabled>Skriv ut</button>
              <button class="btn secondary" id="btnRptCsv" disabled>CSV</button>
              <button class="btn secondary" id="btnRptXls" disabled>Excel</button>
            </div>
          </div>

          <div class="row" style="gap:10px; flex-wrap:wrap; align-items:flex-end; margin-bottom:10px;">
            <div class="field" style="min-width:260px;">
              <label>Räkenskapsår</label>
              <select id="rptYearSelect"></select>
            </div>

            <div class="field" style="min-width:160px;">
              <label>Från</label>
              <input id="rptFrom" type="date" />
            </div>
            <div class="field" style="min-width:160px;">
              <label>Till</label>
              <input id="rptTo" type="date" />
            </div>

            <div class="field" style="min-width:260px; flex:1;">
              <label>Rapport</label>
              <select id="rptType">
                <option value="is">Resultaträkning (period)</option>
                <option value="bs">Balansräkning (per datum)</option>
                                <option value="br">Balansrapport (från/förändring/till)</option>
<option value="trial">Saldolista (period + ack)</option>
                <option value="gl">Huvudbok (period)</option>
                <option value="vj">Verifikationsjournal (period)</option>
                <option value="inventory">Lagerrapport & inventeringslista</option>
              </select>
            </div>

            <button class="btn secondary" id="btnRptFullYear" type="button">Hela året</button>
            <button class="btn secondary" id="btnRptThisMonth" type="button">Denna månad</button>
            <button class="btn secondary" id="btnRptThisQuarter" type="button">Detta kvartal</button>
          </div>

          <div id="reportOutput" class="card" style="padding:12px; border-radius:14px; background:rgba(11,18,32,.90);">
            <div class="muted small">Välj rapport + datumintervall och klicka <b>Generera</b>.</div>
          </div>
        </div>
      </div>
    </section>

    <!-- BANKIMPORT INKORG -->
    <section id="tab-bank_inbox" hidden>
      <div class="grid">
        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px; gap:10px; flex-wrap:wrap;">
            <h2>Inkorg: Bankrader</h2>
            <div class="row" style="gap:10px; flex-wrap:wrap;">
              <button class="btn secondary" id="btnBankImportOpen2" type="button">Importera…</button>
              <button class="btn secondary" id="btnBankInboxRefresh" type="button">Uppdatera</button>
            </div>
          </div>

          <div class="row" style="gap:10px; flex-wrap:wrap; align-items:flex-end; margin-bottom:10px;">
            <div class="field" style="min-width:280px; flex:1;">
              <label>Batch</label>
              <select id="biBatchFilter"></select>
            </div>
            <div class="field" style="min-width:220px;">
              <label>Status</label>
              <select id="biStatusFilter">
                <option value="">Alla</option>
                <option value="unmatched">unmatched</option>
                <option value="matched">matched</option>
                <option value="posted">posted</option>
                <option value="duplicate">duplicate</option>
                <option value="ignored">ignored</option>
                <option value="error">error</option>
              </select>
            </div>
            <div class="field" style="min-width:220px;">
              <label>Bulk</label>
              <div class="row" style="gap:10px; flex-wrap:wrap;">
                <button class="btn" id="btnBiBulkPost" type="button">Skapa verifikationer för markerade</button>
                <button class="btn danger" id="btnBiBulkDelete" type="button">Radera markerade rader</button>
              </div>
            </div>
          </div>

          <div class="row" style="gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:10px;">
            <button class="btn secondary" id="btnBiDeleteBatch" type="button">Radera hela import-batchen</button>
            <button class="btn secondary" id="btnBiUndoBatch" type="button">Ångra bokföring för batch</button>
            <span id="biStats" class="muted small" style="margin-left:auto;"></span>
          </div>

          <div style="overflow:auto;">
            <table class="biInboxTable">
              <thead>
                <tr>
                  <th style="width:34px;"><input type="checkbox" id="biSelectAll" aria-label="Markera alla" /></th>
                  <th style="width:110px;">Datum</th>
                  <th style="width:130px; text-align:right;">Belopp</th>
                  <th style="width:120px; text-align:right;">Moms</th>
                  <th style="width:360px;">Text</th>
                  <th style="width:280px;">Referens</th>
                  <th style="width:120px;">Status</th>
                  <th style="width:200px;">Batch</th>
                  <th style="width:220px;">Föreslaget konto</th>
                  <th style="width:160px;">Föreslagen faktura</th>
                  <th style="width:110px; text-align:right;">Confidence</th>
                  <th style="width:220px;"></th>
                </tr>
              </thead>
              <tbody id="biTbody"></tbody>
            </table>
          </div>

          <div class="muted small" style="margin-top:10px;">
            Import skapar bara bankrader i inkorgen. Inga verifikationer skapas utan aktivt klick (radvis eller bulk med bekräftelse).
          </div>
        </div>
      </div>
    </section>

    <!-- KUNDER -->
    <section id="tab-customers" hidden>
      <div class="grid two">
        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Kundregister</h2>
            <div class="row">
              <button class="btn secondary" id="btnCustNew">Ny</button>
              <button class="btn" id="btnCustSave">Spara</button>
            </div>
          </div>

          <div class="grid" style="gap:10px;">
            <input type="hidden" id="custEditId" />
            <div class="field">
              <label>Namn</label>
              <input id="custRegName" placeholder="t.ex. Mariano Vozzi" />
            </div>
            <div class="field">
              <label>Adress</label>
              <input id="custRegAddr" placeholder="Gata, postnr, ort" />
            </div>
            <div class="row" style="gap:10px;">
              <div class="field" style="flex:1; min-width:220px;">
                <label>E-post (valfritt)</label>
                <input id="custRegEmail" placeholder="kund@exempel.se" />
              </div>
              <div class="field" style="min-width:180px;">
                <label>Org.nr (valfritt)</label>
                <input id="custRegOrgnr" placeholder="559999-9999" />
              </div>
            </div>
            <div class="muted small">Tips: kunder används i Kundfakturor-fliken och sparas i din datafil/backup.</div>
          </div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Kunder</h2>
            <div class="row">
              <input id="custSearch" placeholder="Sök kund…" />
              <button class="btn secondary" id="btnCustRefresh">Uppdatera</button>
            </div>
          </div>
          <div id="customersList" class="list"></div>
        </div>
      </div>
    </section>

    <!-- LEVERANTÖRER -->
    <section id="tab-suppliers" hidden>
      <div class="grid two">
        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Leverantörsregister</h2>
            <div class="row">
              <button class="btn secondary" id="btnSupNew">Ny</button>
              <button class="btn" id="btnSupSave">Spara</button>
            </div>
          </div>

          <div class="grid" style="gap:10px;">
            <input type="hidden" id="supEditId" />
            <div class="field">
              <label>Namn</label>
              <input id="supRegName" placeholder="t.ex. Webhallen AB" />
            </div>
            <div class="field">
              <label>Adress</label>
              <input id="supRegAddr" placeholder="Gata, postnr, ort" />
            </div>
            <div class="row" style="gap:10px;">
              <div class="field" style="flex:1; min-width:220px;">
                <label>E-post (valfritt)</label>
                <input id="supRegEmail" placeholder="leverantor@exempel.se" />
              </div>
              <div class="field" style="min-width:180px;">
                <label>Org.nr (valfritt)</label>
                <input id="supRegOrgnr" placeholder="559999-9999" />
              </div>
            </div>
            <div class="row" style="gap:10px;">
              <div class="field" style="flex:1; min-width:220px;">
                <label>Bankgiro/Plusgiro (valfritt)</label>
                <input id="supRegPayout" placeholder="BG/PG" />
              </div>
            </div>
            <div class="muted small">Leverantörer är förberett för kommande inköp/leverantörsfakturor.</div>
          </div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Leverantörer</h2>
            <div class="row">
              <input id="supSearch" placeholder="Sök leverantör…" />
              <button class="btn secondary" id="btnSupRefresh">Uppdatera</button>
            </div>
          </div>
          <div id="suppliersList" class="list"></div>
        </div>
      </div>
    </section>

    <!-- LEVERANTÖRSFAKTUROR -->
    <section id="tab-supplier_invoices" hidden>
      <div class="grid two">
        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Läs in leverantörsfaktura</h2>
            <div class="row">
              <button class="btn secondary" id="btnSiNew">Ny</button>
              <button class="btn" id="btnSiSave" disabled>Spara</button>
            </div>
          </div>

          <div class="grid" style="gap:10px;">
            <input type="hidden" id="siEditId" />

            <div class="row" style="gap:10px;">
              <div class="field" style="min-width:140px;">
                <label>Fakturadatum</label>
                <input id="siDate" type="date" />
              </div>
              <div class="field" style="min-width:140px;">
                <label>Förfallodatum</label>
                <input id="siDue" type="date" />
              </div>
              <div class="field" style="min-width:160px;">
                <label>Fakturanr</label>
                <input id="siInvoiceNo" placeholder="t.ex. 10233" />
              </div>
              <div class="field" style="flex:1; min-width:220px;">
                <label>OCR/Referens (valfritt)</label>
                <input id="siOcr" placeholder="t.ex. 1234567890" />
              </div>
              <div class="field" style="min-width:110px;">
                <label>Serie (bokföring)</label>
                <input id="siSeries" type="text" value="L" maxlength="10" />
              </div>
            </div>

            <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
              <div class="row" style="justify-content:space-between; margin-bottom:8px;">
                <div class="muted small">Leverantör</div>
                <div class="field" style="min-width:320px;">
                  <label>Välj från register (valfritt)</label>
                  <select id="siSupplierSelect"></select>
                </div>
              </div>
              <div class="grid" style="gap:10px;">
                <div class="row" style="gap:10px;">
                  <div class="field" style="flex:1; min-width:220px;">
                    <label>Namn</label>
                    <input id="siSupplierName" placeholder="t.ex. Webhallen AB" />
                  </div>
                  <div class="field" style="min-width:180px;">
                    <label>Org.nr (valfritt)</label>
                    <input id="siSupplierOrgnr" placeholder="559999-9999" />
                  </div>
                </div>
                <div class="row" style="gap:10px;">
                  <div class="field" style="flex:1; min-width:220px;">
                    <label>BG/PG (valfritt)</label>
                    <input id="siSupplierPayout" placeholder="BG/PG" />
                  </div>
                  <div class="field" style="min-width:220px;">
                    <label>E-post (valfritt)</label>
                    <input id="siSupplierEmail" placeholder="leverantor@exempel.se" />
                  </div>
                </div>
              </div>
              <div class="muted small" style="margin-top:8px;">Tips: leverantörer skapas/uppdateras i fliken Leverantörer.</div>
            </div>

            <div class="card" id="siOcrPanel" hidden style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
              <div class="row" style="justify-content:space-between; margin-bottom:8px;">
                <div class="muted small"><b>OCR (offline)</b> – läs av faktura/kvitto och granska innan du fyller i fälten</div>
                <div class="row">
                  <button class="btn secondary" type="button" id="btnSiOcrDiscard">Avvisa</button>
                  <button class="btn" type="button" id="btnSiOcrApply">Använd valda fält</button>
                </div>
              </div>

              <div class="row" style="gap:10px; align-items:center;">
                <span class="status" id="siOcrStatus">–</span>
                <div class="muted small" id="siOcrFileInfo"></div>
              </div>

              <div class="row" style="gap:10px; align-items:flex-end; margin-top:10px;">
                <div class="field" style="min-width:220px;">
                  <label>Språk (för OCR)</label>
                  <select id="siOcrLang">
                    <option value="swe+eng" selected>Svenska + engelska</option>
                    <option value="swe">Svenska</option>
                    <option value="eng">Engelska</option>
                  </select>
                </div>
                <div class="field" style="min-width:220px;">
                  <label>PDF-sidor</label>
                  <select id="siOcrPdfPages">
                    <option value="1" selected>Endast sida 1</option>
                    <option value="2">Sida 1–2</option>
                    <option value="5">Sida 1–5</option>
                    <option value="all">Alla sidor (kan bli långsamt)</option>
                  </select>
                </div>
                <button class="btn secondary" type="button" id="btnSiOcrRun">Kör OCR igen</button>
              </div>

              <div style="overflow:auto; margin-top:10px;">
                <table>
                  <thead>
                    <tr>
                      <th style="width:70px;">Använd</th>
                      <th style="width:220px;">Fält</th>
                      <th>Värde (redigerbart)</th>
                      <th style="width:90px;" class="right">Träff</th>
                    </tr>
                  </thead>
                  <tbody id="siOcrFieldsTbody"></tbody>
                </table>
              </div>

              <details style="margin-top:10px;">
                <summary class="muted small">Visa OCR-text</summary>
                <textarea id="siOcrText" class="kbd" style="width:100%; min-height:140px;"></textarea>
              </details>

              <div class="muted small" style="margin-top:8px;">
                Tips: kör OCR genom att klicka <b>OCR</b> på ett underlag nedan. OCR sker lokalt i webbläsaren (ingen fil laddas upp), men första gången kan motorn/språkfiler behöva laddas.
              </div>
            </div>

            <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
              <div class="muted small" style="margin-bottom:8px;">Belopp och kontering (förslag)</div>
              <div class="row" style="gap:10px; align-items:flex-end;">
                <div class="field" style="min-width:180px;">
                  <label>Belopp inkl moms</label>
                  <input id="siGross" inputmode="decimal" placeholder="0" />
                </div>
                <div class="field" style="min-width:180px;">
                  <label>Momsbelopp</label>
                  <input id="siVat" inputmode="decimal" placeholder="0" />
                </div>
                <div class="field" style="min-width:180px;">
                  <label>Belopp exkl moms</label>
                  <input id="siNet" inputmode="decimal" placeholder="0" disabled />
                </div>
              </div>

              <div class="row" style="gap:10px; margin-top:10px;">
                <div class="field" style="min-width:220px; flex:1;">
                  <label>Kostnadskonto (debet)</label>
                  <select id="siExpenseAcc"></select>
                </div>
                <div class="field" style="min-width:220px; flex:1;">
                  <label>Ingående moms (debet)</label>
                  <select id="siVatAcc"></select>
                </div>
                <div class="field" style="min-width:220px; flex:1;">
                  <label>Leverantörsskuld (kredit)</label>
                  <select id="siLiabAcc"></select>
                </div>
              </div>

              <div class="row" style="justify-content:space-between; margin-top:10px;">
                <div class="muted small">Skapar verifikation: Debet kostnad + moms, Kredit skuldkonto (t.ex. 2440).</div>
                <button class="btn secondary" id="btnSiToVoucher">Skapa verifikation (serie L)</button>
              </div>
            </div>

            <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
              <div class="row" style="justify-content:space-between; margin-bottom:8px;">
                <div class="muted small">Underlag (PDF/bild)</div>
                <label class="btn secondary" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer; height:40px;">
                  + Lägg till filer
                  <input id="siFiles" type="file" multiple accept="application/pdf,image/*" hidden />
                </label>
              </div>
              <div id="siUnderlagList" class="list" data-ocr="supplierinvoice"></div>
            </div>

            <div class="muted small">Detta flöde ger spårbarhet: leverantörsfaktura → underlag → verifikation.</div>
          </div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Leverantörsfakturor</h2>
            <div class="row">
              <select id="siYearSelect"></select>
              <button class="btn secondary" id="btnSiRefresh">Uppdatera</button>
            </div>
          </div>
          <div id="supplierInvoiceList" class="list"></div>
        </div>
      </div>
    </section>



    <!-- KUNDFAKTUROR -->
    <section id="tab-invoices" hidden>
      <div class="grid two" id="invGrid">
        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Skapa kundfaktura</h2>
            <div class="row">
              <button class="btn secondary" id="btnInvToggleList" type="button">Dölj lista</button>
              <button class="btn secondary" id="btnInvNew">Ny</button>
              <button class="btn" id="btnInvSave" disabled>Spara</button>
            </div>
          </div>

          <div class="grid" style="gap:10px;">
            <div class="row" style="gap:10px;">
              <div class="field" style="min-width:140px;">
                <label>Fakturadatum</label>
                <input id="invDate" type="date" />
              </div>
              <div class="field" style="min-width:140px;">
                <label>Förfallodatum</label>
                <input id="invDue" type="date" />
              </div>
              <div class="field" style="min-width:110px;">
                <label>Nr</label>
                <input id="invNo" placeholder="Auto" />
              </div>
              <div class="field" style="flex:1; min-width:220px;">
                <label>Referens</label>
                <input id="invRef" placeholder="t.ex. Order 123" />
              </div>
            </div>

            <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
              <div class="row" style="justify-content:space-between; margin-bottom:8px;">
                <div class="muted small">Kund</div>
                <button class="btn secondary" id="btnInvPickCustomer">Välj/Lägg till</button>
              </div>
              <div id="invCustomerBox" class="muted small">Ingen kund vald.</div>
            </div>

            <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
              <div class="row" style="justify-content:space-between; margin-bottom:8px;">
                <div class="muted small">Rader</div>
                <div class="row">
                  <button class="btn secondary" id="btnInvAddItem">+ Artikel</button>
                  <button class="btn secondary" id="btnInvAddComment">+ Kommentar</button>
                </div>
              </div>
              <div style="overflow:auto;">
                <table>
                  <thead>
                    <tr>
                      <th>Beskrivning</th>
                      <th class="right" style="width:90px;">Antal</th>
                      <th class="right" style="width:140px;">Á-pris exkl.</th>
                      <th class="right" style="width:90px;">Moms %</th>
                      <th class="right" style="width:140px;">Radbelopp</th>
                      <th style="width:70px;"></th>
                    </tr>
                  </thead>
                  <tbody id="invLinesTbody"></tbody>
                </table>
              </div>
              <div class="row" style="justify-content:space-between; margin-top:10px;">
                <div class="muted small">Artikelrader räknas in i total. Kommentar-rader påverkar inte belopp.</div>
                <button class="btn danger" id="btnInvClear">Rensa</button>
              </div>
            </div>

            <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
              <div class="row" style="justify-content:space-between;">
                <div>
                  <div class="muted small">Totalt inkl. moms</div>
                  <div id="invTotal" style="font-size:24px; font-weight:900;">–</div>
                  <div class="muted small">Öresavrundning <span id="invRounding">0,00</span></div>
                </div>
                <div class="row">
                  <button class="btn secondary" id="btnInvPrint" disabled>Förhandsgranska/skriv ut</button>
                  <button class="btn secondary" id="btnInvToVoucher" disabled>Skapa verifikation</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="card" id="invListCard">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Kundfakturor</h2>
            <div class="row">
              <select id="invYearSelect" aria-label="Räkenskapsår för fakturor"></select>
              <button class="btn secondary" id="btnInvRefresh">Uppdatera</button>
            </div>
          </div>
          <div id="invoiceList" class="list"></div>
        </div>
      </div>

      <!-- Enkel kund-dialog (utan externa bibliotek) -->
      <dialog id="customerDialog" style="border:1px solid rgba(34,48,68,.8); border-radius:16px; padding:0; max-width:720px; width:calc(100% - 24px); background:rgba(11,15,20,.98); color:var(--text);">
        <div style="padding:14px;">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2 style="margin:0; font-size:14px; color:var(--muted);">Kund</h2>
            <button class="btn secondary" id="btnCustomerClose">Stäng</button>
          </div>

          <div class="grid" style="gap:10px;">
            <div class="row" style="gap:10px;">
              <div class="field" style="flex:1; min-width:220px;">
                <label>Namn</label>
                <input id="custName" placeholder="t.ex. Mariano Vozzi" />
              </div>
              <div class="field" style="flex:1; min-width:220px;">
                <label>Adress</label>
                <input id="custAddr" placeholder="Gata, postnr, ort" />
              </div>
            </div>
            <div class="row" style="gap:10px;">
              <div class="field" style="flex:1; min-width:220px;">
                <label>E-post (valfritt)</label>
                <input id="custEmail" placeholder="kund@exempel.se" />
              </div>
              <div class="field" style="min-width:180px;">
                <label>Org.nr (valfritt)</label>
                <input id="custOrgnr" placeholder="559999-9999" />
              </div>
            </div>
            <div class="row" style="justify-content:flex-end;">
              <button class="btn" id="btnCustomerSave">Spara & välj</button>
            </div>
            <div style="height:1px; background:rgba(34,48,68,.8); margin:6px 0;"></div>
            <div class="muted small">Befintliga kunder</div>
            <div id="customerList" class="list"></div>
          </div>
        </div>
      </dialog>
    </section>


    
    
    <!-- SRU / DEKLARATION -->
    <section id="tab-sru" hidden>
      <div class="grid two">
        <div class="card">
          <h2>SRU-export (NE) <span class="badge lock" id="sruLockBadge">🔒 <b>Låst</b> · beta</span></h2>

          <div class="lockbox" id="sruLockedBox" style="margin-top:10px;">
            <div class="row">
              <div class="muted small">
                SRU är förberett för <b>blankettstyrd</b> export (börjar med <b>NE</b>).
                Funktionen syns alltid – men är låst tills du aktiverar den.
              </div>
              <button class="btn" type="button" id="btnEnableSRU">Aktivera SRU (beta)</button>
            </div>
            <div class="muted small" style="margin-top:10px;">
              När SRU är aktiv kan du mappa BAS-konton till SRU-fältkoder och exportera <span class="kbd">INFO.SRU</span> + <span class="kbd">BLANKETTER.SRU</span>.
            </div>
          </div>

          <div id="sruUnlockedBox" hidden style="margin-top:10px;">
            <div class="row" style="gap:10px; align-items:end;">
              <div class="field" style="min-width:220px;">
                <label>Räkenskapsår</label>
                <select id="sruYearSelect"></select>
              </div>
              <div class="field" style="min-width:220px;">
                <label>Blankettperiod (suffix)</label>
                <input id="sruPeriodSuffix" placeholder="t.ex. P4" />
              </div>
              <button class="btn" type="button" id="btnExportSRUNE">Exportera INFO.SRU + BLANKETTER.SRU</button>
            </div>
            <div class="muted small" style="margin-top:10px;">
              Exporten bygger på din <b>NE-mappning</b> nedan. Belopp hämtas från verifikationsrader i valt år.
            </div>
          </div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>NE-mappning</h2>
            <div class="row">
              <button class="btn secondary" type="button" id="btnSruAddMap">+ Rad</button>
              <button class="btn" type="button" id="btnSruSaveMap">Spara mappning</button>
            </div>
          </div>
          <div class="muted small" style="margin-bottom:10px;">
            Ange SRU-fältkod (t.ex. <span class="kbd">R1</span>), och vilka konton som ska summeras.
            Kontofilter kan vara: <span class="kbd">1930</span>, <span class="kbd">30*</span>, eller intervall <span class="kbd">3000-3099</span>. Separera flera med komma.
          </div>

          <div style="overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th style="width:120px;">Fältkod</th>
                  <th style="width:220px;">Kontofilter</th>
                  <th style="width:140px;">Tecken</th>
                  <th>Kommentar</th>
                  <th style="width:70px;"></th>
                </tr>
              </thead>
              <tbody id="sruMapTbody"></tbody>
            </table>
          </div>

          <div class="muted small" style="margin-top:10px;">
            Tips: Om du vill att ett konto ska minska värdet i fältet, välj <b>Invertera</b> på den raden.
          </div>
        </div>
      </div>
    </section>

<section id="tab-export" hidden>
      <div class="grid two">
        <div class="card">
          <h2>SIE-export (Typ 4)</h2>
          <div class="row" style="gap:10px;">
            <select id="sieYearSelect"></select>
            <button class="btn" id="btnExportSie4">Ladda ner SIE4</button>
          </div>
          <p class="muted small" style="margin-top:10px;">
            Exporten följer SIE 4B-principerna (#VER/#TRANS, samt #IB/#UB för balanskonto). Om mottagande program är super-strikt med teckenkodning (PC8/CP437) kan du behöva spara om filen via en editor som kan konvertera encoding.
          </p>

        </div>

        <div class="card">
          <h2>SIE-import</h2>
          <div class="row" style="gap:10px; flex-wrap:wrap;">
            <select id="sieImportEncoding" title="Teckenkodning">
              <option value="utf-8">UTF-8</option>
              <option value="windows-1252">Windows-1252</option>
              <option value="ibm437">IBM437 (PC8/CP437)</option>
            </select>
            <label class="btn secondary" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
              Välj SIE-fil
              <input id="sieImportFile" type="file" hidden multiple accept=".se,.sie,.txt" />
            </label>
            <span id="sieImportFileName" class="muted small" style="margin-left:10px; max-width:360px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:inline-block; vertical-align:middle;">Ingen fil vald</span>
            <button class="btn" id="btnImportSie">Importera</button>
            <label class="muted small" style="display:flex; align-items:center; gap:8px;">
              <input id="sieImportWipe" type="checkbox" /> Rensa innan import
            </label>
            <label class="muted small" style="display:flex; align-items:center; gap:8px;">
              <input id="sieImportParallel" type="checkbox" /> Läs filer parallellt (snabbare)
            </label>
          </div>
          <p class="muted small" style="margin-top:10px;">
            Importen läser #KONTO, #RAR, #VER/#TRANS (objekt ignoreras). Tips: om importen blir konstig, testa att byta teckenkodning (många SIE är PC8/CP437).
          </p>
        </div>
      </div>
    </section>

    <!-- SETTINGS -->
    <section id="tab-settings" hidden>
      <div class="grid two">
        <div class="card">
          <h2>Företagsuppgifter</h2>
          <div class="grid" style="gap:10px;">
            <div class="field">
              <label>Företagsnamn</label>
              <input id="sCompany" placeholder="t.ex. Innovatio Brutalis AB" />
            </div>
            <div class="row" style="gap:10px;">
              <div class="field" style="flex:1; min-width:220px;">
                <label>Org.nr (för SIE)</label>
                <input id="sOrgnr" placeholder="t.ex. 559999-9999" />
              </div>
              <div class="field" style="min-width:170px;">
                <label>Valuta</label>
                <select id="sCurrency">
                  <option>SEK</option>
                  <option>NOK</option>
                  <option>DKK</option>
                  <option>EUR</option>
                  <option>USD</option>
                </select>
              </div>
              <div class="field" style="min-width:140px;">
                <label>Sign (default)</label>
                <input id="sSign" placeholder="t.ex. MA" />
              </div>
            </div>
            <div style="height:1px; background:rgba(34,48,68,.8); margin:12px 0;"></div>
            <h2>Fakturauppgifter</h2>
            <div class="grid" style="gap:10px;">
              <div class="row" style="gap:10px;">
                <div class="field" style="flex:1; min-width:260px;">
                  <label>Adress</label>
                  <input id="sAddr" placeholder="Gata, nr" />
                </div>
                <div class="field" style="min-width:140px;">
                  <label>Postnr</label>
                  <input id="sZip" placeholder="123 45" />
                </div>
                <div class="field" style="flex:1; min-width:200px;">
                  <label>Ort</label>
                  <input id="sCity" placeholder="Stockholm" />
                </div>
                <div class="field" style="min-width:180px;">
                  <label>Land (valfritt)</label>
                  <input id="sCountry" placeholder="Sverige" />
                </div>
              </div>

              <div class="row" style="gap:10px;">
                <div class="field" style="min-width:220px; flex:1;">
                  <label>E-post</label>
                  <input id="sEmail" placeholder="faktura@dittbolag.se" />
                </div>
                <div class="field" style="min-width:200px;">
                  <label>Telefon</label>
                  <input id="sPhone" placeholder="+46 ..." />
                </div>
                <div class="field" style="min-width:220px;">
                  <label>Webb (valfritt)</label>
                  <input id="sWeb" placeholder="https://..." />
                </div>
              </div>

              <div class="row" style="gap:10px;">
                <div class="field" style="min-width:220px;">
                  <label>Momsreg.nr / VAT (valfritt)</label>
                  <input id="sVat" placeholder="SE559999999901" />
                </div>
                <div class="field" style="min-width:160px;">
                  <label>Betalvillkor (dagar)</label>
                  <input id="sPayDays" inputmode="numeric" placeholder="30" />
                </div>
              </div>

              <div class="row" style="gap:10px; flex-wrap:wrap;">
                <div class="field" style="min-width:220px;">
                  <label>Bankgiro (valfritt)</label>
                  <input id="sBg" placeholder="123-4567" />
                </div>
                <div class="field" style="min-width:220px;">
                  <label>Plusgiro (valfritt)</label>
                  <input id="sPg" placeholder="123456-7" />
                </div>
                <div class="field" style="min-width:220px;">
                  <label>Swish (telefon, valfritt)</label>
                  <input id="sSwish" inputmode="tel" placeholder="t.ex. 0701234567" />
                </div>
                <div class="field" style="min-width:260px; flex:1;">
                  <label>Bankkonto (kontonr, valfritt)</label>
                  <input id="sBankAccount" placeholder="t.ex. 1234-5, 1234567890" />
                </div>
                <div class="field" style="min-width:260px; flex:1;">
                  <label>IBAN (valfritt)</label>
                  <input id="sIban" placeholder="SE..." />
                </div>
                <div class="field" style="min-width:180px;">
                  <label>SWIFT/BIC (valfritt)</label>
                  <input id="sSwift" placeholder="XXXXSESS" />
                </div>
              </div>

              <div class="row" style="gap:10px;">
                <div class="field" style="flex:1; min-width:260px;">
                  <label>Notis på faktura (valfritt)</label>
                  <input id="sInvNote" placeholder="t.ex. Tack för din beställning!" />
                </div>
              </div>

              <div class="field">
                <label>Fakturafot / extra info (valfritt)</label>
                <textarea id="sInvFooter" placeholder="t.ex. Förseningsränta 8% + referens..."></textarea>
              </div>

              <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap;">
                <div class="field" style="min-width:260px;">
                  <label>Logotyp (valfritt)</label>
                  <input id="sLogo" type="file" accept="image/*" />
                </div>
                <button class="btn secondary" type="button" id="btnRemoveLogo">Ta bort logotyp</button>
                <div id="logoPreview" class="muted small"></div>
              </div>
            </div>

            
              <div style="height:1px; background:rgba(34,48,68,.8); margin:12px 0;"></div>
              <h2>Deklaration (SRU)</h2>
              <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap;">
                <label class="muted small" style="display:flex; align-items:center; gap:8px;">
                  <input id="sSruEnabled" type="checkbox" />
                  Aktivera SRU (NE) – avancerat (kräver mappning)
                </label>
                <span class="muted small">Visas alltid i menyn, men är låst om du inte aktiverar här.</span>
              </div>

            <div class="row" style="justify-content:flex-end;">
              <button class="btn" id="btnSaveSettings">Spara</button>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>Räkenskapsår</h2>
          <div style="height:1px; background:rgba(34,48,68,.8); margin:12px 0;"></div>
          <h2>Periodlås</h2>
          <div class="muted small" style="margin-bottom:10px;">
            Lås äldre perioder så att verifikationer inte kan ändras/raderas. Rättelser görs via ny verifikation som hänvisar till originalet.
          </div>
          <div class="row" style="gap:10px; margin-bottom:10px; align-items:end; flex-wrap:wrap;">
            <div class="field" style="min-width:240px;">
              <label>År</label>
              <select id="lockYear"></select>
            </div>
            <div class="field" style="min-width:200px;">
              <label>Lås t.o.m (inkl.)</label>
              <input id="lockUntil" type="date" />
            </div>
            <button class="btn" id="btnSetLock">Spara lås</button>
            <button class="btn secondary" id="btnClearLock">Ta bort lås</button>
          </div>

          <div class="row" style="gap:10px; margin-bottom:10px;">
            <div class="field" style="min-width:160px;">
              <label>Start</label>
              <input id="fyStart" type="date" />
            </div>
            <div class="field" style="min-width:160px;">
              <label>Slut</label>
              <input id="fyEnd" type="date" />
            </div>
            <button class="btn" id="btnAddYear">Lägg till år</button>
          </div>
          <div class="row" style="gap:10px; margin-bottom:10px; align-items:end;">
            <div class="field" style="min-width:240px;">
              <label>IB från (år)</label>
              <select id="carryFrom"></select>
            </div>
            <div class="field" style="min-width:240px;">
              <label>IB till (år)</label>
              <select id="carryTo"></select>
            </div>
            <button class="btn secondary" id="btnCarry">För över IB (balanskonto)</button>
          </div>
          <div class="muted small">För över IB skapar en verifikation på första dagen i ”Till”-året med text “Ingående balans”.</div>
          <div style="overflow:auto; margin-top:10px;">
            <table>
              <thead>
                <tr>
                  <th>År-id</th>
                  <th>Start</th>
                  <th>Slut</th>
                  <th style="width:70px;"></th>
                </tr>
              </thead>
              <tbody id="yearsTbody"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <h2>Företag (JSON-datafil)</h2>
          <div class="row" style="gap:10px; flex-wrap:wrap;">
            <button class="btn" id="btnConnectFile">Koppla befintligt företag (JSON)</button>
            <button class="btn secondary" id="btnCreateFile">+ Skapa företag</button>
            <button class="btn secondary" id="btnLoadFromFile" disabled>Läs in</button>
            <button class="btn secondary" id="btnSaveToFile" disabled>Spara nu</button>
            <button class="btn danger" id="btnDisconnectFile" disabled>Koppla från</button>
          </div>
          <div class="row" style="gap:10px; margin-top:10px; align-items:center; flex-wrap:wrap;">
            <label class="muted small" style="display:flex; align-items:center; gap:8px;">
              <input id="fsAutosave" type="checkbox" /> Autospara till fil
            </label>
            <label class="muted small" style="display:flex; align-items:center; gap:8px;">
              <input id="fsRequireFile" type="checkbox" /> Kräv datafil (ingen bokföring utan fil)
            </label>
            <span id="fsStatus" class="status bad">Inte ansluten</span>
          </div>
          <p class="muted small" style="margin-top:10px;">
            Kräver File System Access API (Chrome/Edge) och <b>secure context</b> (HTTPS eller localhost). Varje företag använder en egen JSON-datafil.
          </p>
        </div>

        <div class="card">
          <h2>Backup (JSON)</h2>
          <div class="row" style="gap:10px; flex-wrap:wrap;">
            <button class="btn secondary" id="btnChooseBackupDir" title="Välj mapp för autobackup">Byt backup-mapp…</button>
            <label class="pill" style="display:inline-flex; align-items:center; gap:8px; padding:10px 12px; border:1px solid #2a2e37; border-radius:999px; user-select:none;">
              <input type="checkbox" id="chkAutoBackup" checked style="margin:0;" />
              Autobackup (max 1/dag)
            </label>
            <span id="backupDirStatus" class="muted small" style="margin-left:auto; min-width:240px; text-align:right;"></span>
            <button class="btn" id="btnExportJson">Ladda ner backup.json</button>
            <label class="btn secondary" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
              Importera JSON
              <input id="jsonImport" type="file" accept="application/json" hidden />
            </label>
            <button class="btn danger" id="btnWipe">Rensa ALL data</button>
          </div>
          <p class="muted small" style="margin-top:10px;">Tips: ta en backup innan du gör bokslutsverifikationer.</p>
        </div>

        <div class="card">
          <h2>Arkivering (årspaket)</h2>
          <div class="row" style="gap:10px; flex-wrap:wrap;">
            <select id="archiveYearSelect" aria-label="Räkenskapsår för arkiv"></select>
            <button class="btn" id="btnMakeArchive">Skapa arkivpaket</button>
            <button class="btn secondary" id="btnMakeArchiveFolder">Skapa arkivmapp (med underlag)</button>
          </div>
          <p class="muted small" style="margin-top:10px;">
            Skapar en fryst export för valt år (kontoplan, verifikationer, fakturor + relevanta register) samt en SHA-256 checksumma.
            Spara båda filerna på ett säkert ställe (t.ex. skrivskyddad plats / offline-kopia). Programmet kan inte garantera arkivering om du bara har localStorage.
          </p>

          <div class="row" style="gap:10px; flex-wrap:wrap;">
            <label class="btn secondary" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
              Välj arkiv-JSON
              <input id="archiveImportJson" type="file" accept="application/json" hidden />
            </label>
            <label class="btn secondary" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
              Välj .sha256 (valfritt)
              <input id="archiveImportSha" type="file" accept="text/plain" hidden />
            </label>
            <button class="btn secondary" id="btnVerifyArchive">Verifiera arkiv</button>
          </div>
          <div id="archiveVerifyResult" class="muted small" style="margin-top:10px;"></div>
        </div>
      </div>
    </section>
      </div>
    </div>
  </div>
</main>

<div id="appToast" class="toast" hidden role="status" aria-live="polite"></div>

<div id="appConfirm" class="modal-backdrop" hidden>
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="appConfirmTitle" aria-describedby="appConfirmMessage">
    <div id="appConfirmTitle" style="font-weight:800; margin-bottom:6px;">Bekräfta</div>
    <div id="appConfirmMessage" class="muted small"></div>
    <div class="actions">
      <button type="button" class="btn secondary" id="appConfirmCancel">Avbryt</button>
      <button type="button" class="btn danger" id="appConfirmOk">OK</button>
    </div>
  </div>
</div>

<div id="appPrompt" class="modal-backdrop" hidden>
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="appPromptTitle" aria-describedby="appPromptMessage">
    <div id="appPromptTitle" style="font-weight:800; margin-bottom:6px;">Ange orsak</div>
    <div id="appPromptMessage" class="muted small"></div>
    <textarea id="appPromptInput" style="margin-top:10px; width:100%;" placeholder="(valfritt)"></textarea>
    <div class="actions">
      <button type="button" class="btn secondary" id="appPromptCancel">Avbryt</button>
      <button type="button" class="btn" id="appPromptOk">OK</button>
    </div>
  </div>
</div>

<!-- Bank import modal -->
<div id="bankImportModal" class="modal-backdrop" hidden>
  <div class="modal wide" role="dialog" aria-modal="true" aria-labelledby="bankImportTitle">
    <div class="row" style="justify-content:space-between; align-items:center; gap:10px;">
      <div id="bankImportTitle" style="font-weight:800;">Importera bank/skatteutdrag</div>
      <button type="button" class="btn secondary" id="btnBankImportClose">Stäng</button>
    </div>

    <div class="grid" style="gap:10px; margin-top:10px;">
      <div class="row" style="gap:10px; flex-wrap:wrap; align-items:center;">
        <label class="btn secondary" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
          Välj fil (.csv/.xlsx/.xls)
          <input id="biFile" type="file" accept=".csv,.xlsx,.xls" hidden />
        </label>
        <span id="biFileName" class="muted small" style="max-width:320px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:inline-block;">Ingen fil vald</span>
      </div>

      <div class="row" style="gap:10px; flex-wrap:wrap;">
        <div class="field" style="min-width:180px;">
          <label>Källa</label>
          <select id="biSource">
            <option value="bank">Bank</option>
            <option value="skattekonto">Skattekonto</option>
          </select>
        </div>
        <div class="field" style="min-width:220px; flex:1;">
          <label>Balans-konto</label>
          <select id="biBankAccount"></select>
        </div>
      </div>

      <div class="row" style="gap:10px; flex-wrap:wrap; align-items:flex-end;">
        <div class="field" style="min-width:180px;">
          <label>Datum från (valfritt)</label>
          <input id="biDateFrom" type="date" />
        </div>
        <div class="field" style="min-width:180px;">
          <label>Datum till (valfritt)</label>
          <input id="biDateTo" type="date" />
        </div>
        <div class="field" style="min-width:220px;" id="biSheetBox" hidden>
          <label>Sheet (Excel)</label>
          <select id="biSheet"></select>
        </div>
      </div>

      <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
        <div style="font-weight:800; margin-bottom:8px;">Kolumnmappning</div>
        <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:10px;">
          <div class="field">
            <label>Datum (krav)</label>
            <select id="biMapDate"></select>
          </div>
          <div class="field">
            <label>Belopp (krav)</label>
            <select id="biMapAmount"></select>
          </div>
          <div class="field">
            <label>Moms (valfri)</label>
            <select id="biMapVat"></select>
          </div>
          <div class="field">
            <label>Text/Beskrivning (krav)</label>
            <select id="biMapText"></select>
          </div>
          <div class="field">
            <label>Referens (valfri)</label>
            <select id="biMapRef"></select>
          </div>
          <div class="field">
            <label>Debet (valfri)</label>
            <select id="biMapDebit"></select>
          </div>
          <div class="field">
            <label>Kredit (valfri)</label>
            <select id="biMapCredit"></select>
          </div>
        </div>
        <div class="muted small" style="margin-top:8px;">Om Debet/Kredit används ignoreras Belopp-kolumnen (amount = kredit − debet).</div>
        <label class="muted small" style="display:flex; gap:8px; align-items:center; margin-top:8px;">
          <input id="biFlipSign" type="checkbox" />
          Vänd tecken på belopp
        </label>
      </div>

      <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
        <div style="font-weight:800; margin-bottom:8px;">Preview (20 rader)</div>
        <div style="overflow:auto; max-height:260px;">
          <table class="biPreviewTable">
            <colgroup>
              <col style="width:110px;" />
              <col style="width:120px;" />
              <col style="width:110px;" />
              <col style="width:calc((100% - 340px) * 0.30);" />
              <col style="width:calc((100% - 340px) * 0.70);" />
            </colgroup>
            <thead>
              <tr>
                <th style="width:110px;">Datum</th>
                <th style="width:120px; text-align:right;">Belopp</th>
                <th style="width:110px; text-align:right;">Moms</th>
                <th>Text</th>
                <th>Referens</th>
              </tr>
            </thead>
            <tbody id="biPreviewTbody"></tbody>
          </table>
        </div>
      </div>

      <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.90);">
        <div style="font-weight:800; margin-bottom:8px;">Validering</div>
        <div id="biWarnings" class="muted small"></div>
        <label id="biRiskBox" class="muted small" style="display:flex; gap:8px; align-items:center; margin-top:8px;" hidden>
          <input id="biRiskOk" type="checkbox" />
          Jag förstår riskerna och vill importera ändå
        </label>
      </div>
    </div>

    <div class="actions">
      <button type="button" class="btn secondary" id="btnBankImportReset">Återställ</button>
      <button type="button" class="btn" id="btnBankImportRun" disabled>Importera 0 rader till inkorg</button>
    </div>
  </div>
</div>

<!-- Per-row posting modal -->
<div id="bankPostModal" class="modal-backdrop" hidden>
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="bankPostTitle">
    <div class="row" style="justify-content:space-between; align-items:center; gap:10px;">
      <div id="bankPostTitle" style="font-weight:800;">Kontera bankrad</div>
      <button type="button" class="btn secondary" id="btnBankPostClose">Stäng</button>
    </div>
    <div id="bankPostMeta" class="muted small" style="margin-top:8px;"></div>
    <div class="field" style="margin-top:10px;">
      <label>Motkonto</label>
      <select id="bankPostAccount"></select>
    </div>
    <label class="muted small" style="display:flex; gap:8px; align-items:center; margin-top:10px;">
      <input id="bankPostReviewed" type="checkbox" />
      Jag har granskat och vill skapa verifikation
    </label>
    <div class="actions">
      <button type="button" class="btn secondary" id="btnBankPostIgnore">Markera som ej bokföringshändelse</button>
      <button type="button" class="btn" id="btnBankPostCreate" disabled>Skapa verifikation</button>
    </div>
  </div>
</div>

<!-- Bulk posting confirmation modal -->
<div id="bankBulkModal" class="modal-backdrop" hidden>
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="bankBulkTitle">
    <div class="row" style="justify-content:space-between; align-items:center; gap:10px;">
      <div id="bankBulkTitle" style="font-weight:800;">Skapa verifikationer (bulk)</div>
      <button type="button" class="btn secondary" id="btnBankBulkClose">Stäng</button>
    </div>
    <div id="bankBulkSummary" class="muted small" style="margin-top:10px;"></div>
    <label class="muted small" style="display:flex; gap:8px; align-items:center; margin-top:10px;">
      <input id="bankBulkReviewed" type="checkbox" />
      Jag har granskat
    </label>
    <div class="actions">
      <button type="button" class="btn secondary" id="btnBankBulkCancel">Avbryt</button>
      <button type="button" class="btn" id="btnBankBulkConfirm" disabled>Skapa verifikationer</button>
    </div>
  </div>
</div>

<script>
(function(){
 

  const APP_VERSION = "1.3.0"; // bump when adding new data fields
  const APP_SEMVER = "0.2.19";  // user-facing revision
  const APP_GIT_REV = "86fcf6d";      // injected by tools/stamp-fu-version.mjs (optional)
  const STORAGE_KEY = "FU_BOOKKEEPING_STATE";

  let localStorageOk = true;

  function setPillState(el, kind){
    if (!el) return;
    try {
      el.classList.remove("ok", "bad");
      if (kind === "ok") el.classList.add("ok");
      else if (kind === "bad") el.classList.add("bad");
    } catch {}
  }

  const bootPill = document.getElementById("bootPill");
  const revPill = document.getElementById("revPill");
  const setBoot = (text, kind) => {
    if (!bootPill) return;
    bootPill.textContent = text;
    if (kind) setPillState(bootPill, kind);
  };

  function updateRevisionPill(){
    if (!revPill) return;
    const v = String(APP_SEMVER || "0.0.0");
    const r = String(APP_GIT_REV || "").trim();
    revPill.textContent = r ? (`v${v} · ${r}`) : (`v${v}`);
  }
  setBoot("JS: OK", "ok");
  updateRevisionPill();
  window.addEventListener("error", (ev) => {
    try {
      const msg = ev && ev.message ? String(ev.message) : "(okänt fel)";
      setBoot(`JS: fel · ${msg}`.slice(0, 60), "bad");
    } catch { setBoot("JS: fel (konsol)", "bad"); }
    try { console.error("Global error", ev && ev.error ? ev.error : ev); } catch {}
  });
  window.addEventListener("unhandledrejection", (ev) => {
    try {
      const reason = ev && ev.reason ? ev.reason : "(okänd promise-rejection)";
      const msg = (reason && (reason.message || reason.name)) ? String(reason.message || reason.name) : String(reason);
      setBoot(`JS: fel · ${msg}`.slice(0, 60), "bad");
    } catch { setBoot("JS: fel (konsol)", "bad"); }
    try { console.error("Unhandled rejection", ev && ev.reason ? ev.reason : ev); } catch {}
  });

  // In-app toast (used to avoid browser alert header text)
  const appToast = document.getElementById("appToast");
  let toastTimer = null;
  function showToast(message, ms = 2200){
    if (!appToast) return;
    if (toastTimer) { clearTimeout(toastTimer); toastTimer = null; }
    appToast.textContent = String(message ?? "");
    appToast.hidden = false;
    toastTimer = setTimeout(() => {
      appToast.hidden = true;
    }, ms);
  }

  // In-app confirm (replaces browser confirm dialogs)
  const appConfirm = document.getElementById("appConfirm");
  const appConfirmMessage = document.getElementById("appConfirmMessage");
  const appConfirmOk = document.getElementById("appConfirmOk");
  const appConfirmCancel = document.getElementById("appConfirmCancel");
  let confirmResolve = null;
  let confirmKeyHandler = null;

  function hideConfirm(result){
    if (!appConfirm) return;
    try { appConfirm.hidden = true; } catch {}
    try { if (confirmKeyHandler) document.removeEventListener("keydown", confirmKeyHandler, true); } catch {}
    if (!confirmResolve){
      confirmKeyHandler = null;
      return;
    }
    const r = confirmResolve;
    confirmResolve = null;
    confirmKeyHandler = null;
    try { r(!!result); } catch {}
  }

  function confirmAsync(message, options = {}){
    return new Promise((resolve)=>{
      const msg = String(message ?? "");
      if (!appConfirm || !appConfirmMessage || !appConfirmOk || !appConfirmCancel){
        resolve(!!window.confirm(msg));
        return;
      }

      // Close any previous pending confirm
      if (confirmResolve){
        try { confirmResolve(false); } catch {}
        confirmResolve = null;
      }

      appConfirmMessage.textContent = msg;
      appConfirmOk.textContent = String(options.okText ?? "OK");
      appConfirmCancel.textContent = String(options.cancelText ?? "Avbryt");

      const okKind = String(options.okKind ?? "danger");
      appConfirmOk.className = "btn" + (okKind === "danger" ? " danger" : (okKind === "secondary" ? " secondary" : ""));
      appConfirmCancel.className = "btn secondary";

      appConfirm.hidden = false;
      confirmResolve = resolve;

      confirmKeyHandler = (e)=>{
        if (e.key === "Escape"){
          e.preventDefault();
          hideConfirm(false);
          return;
        }
        if (e.key === "Enter"){
          e.preventDefault();
          hideConfirm(true);
        }
      };
      document.addEventListener("keydown", confirmKeyHandler, true);

      setTimeout(()=>{
        try { appConfirmOk.focus(); } catch {}
      }, 0);
    });
  }

  if (appConfirmOk) appConfirmOk.addEventListener("click", ()=> hideConfirm(true));
  if (appConfirmCancel) appConfirmCancel.addEventListener("click", ()=> hideConfirm(false));
  if (appConfirm) appConfirm.addEventListener("click", (e)=>{ if (e.target === appConfirm) hideConfirm(false); });


  // In-app prompt (replaces browser prompt dialogs)
  const appPrompt = document.getElementById("appPrompt");
  const appPromptMessage = document.getElementById("appPromptMessage");
  const appPromptInput = document.getElementById("appPromptInput");
  const appPromptOk = document.getElementById("appPromptOk");
  const appPromptCancel = document.getElementById("appPromptCancel");
  let promptResolve = null;
  let promptKeyHandler = null;

  function hidePrompt(value, cancelled){
    if (!appPrompt) return;
    try { appPrompt.hidden = true; } catch {}
    try { if (promptKeyHandler) document.removeEventListener("keydown", promptKeyHandler, true); } catch {}
    if (!promptResolve){
      promptKeyHandler = null;
      return;
    }
    const r = promptResolve;
    promptResolve = null;
    promptKeyHandler = null;
    try { r(cancelled ? null : String(value ?? "")); } catch {}
  }

  function promptAsync(message, options = {}){
    return new Promise((resolve)=>{
      const msg = String(message ?? "");
      if (!appPrompt || !appPromptMessage || !appPromptInput || !appPromptOk || !appPromptCancel){
        const v = window.prompt(msg, String(options.defaultValue ?? ""));
        resolve(v == null ? null : String(v));
        return;
      }

      // Close any previous pending prompt
      if (promptResolve){
        try { promptResolve(null); } catch {}
        promptResolve = null;
      }

      appPromptMessage.textContent = msg;
      appPromptInput.value = String(options.defaultValue ?? "");
      appPromptInput.placeholder = String(options.placeholder ?? "(valfritt)");
      appPromptOk.textContent = String(options.okText ?? "OK");
      appPromptCancel.textContent = String(options.cancelText ?? "Avbryt");

      appPrompt.hidden = false;
      promptResolve = resolve;

      promptKeyHandler = (e)=>{
        if (e.key === "Escape"){
          e.preventDefault();
          hidePrompt("", true);
          return;
        }
        // In textarea we keep Enter for newline. Use Ctrl+Enter to accept.
        if (e.key === "Enter" && (e.ctrlKey || e.metaKey)){
          e.preventDefault();
          hidePrompt(appPromptInput.value, false);
        }
      };
      document.addEventListener("keydown", promptKeyHandler, true);

      setTimeout(()=>{
        try { appPromptInput.focus(); appPromptInput.select(); } catch {}
      }, 0);
    });
  }

  if (appPromptOk) appPromptOk.addEventListener("click", ()=> hidePrompt(appPromptInput ? appPromptInput.value : "", false));
  if (appPromptCancel) appPromptCancel.addEventListener("click", ()=> hidePrompt("", true));
  if (appPrompt) appPrompt.addEventListener("click", (e)=>{ if (e.target === appPrompt) hidePrompt("", true); });

  // --- Utilities ---
  const fmtSEK = (n) => {
    if (!Number.isFinite(n)) return "–";
    return n.toLocaleString("sv-SE", {minimumFractionDigits: 2, maximumFractionDigits: 2});
  };
  const parseMoney = (s) => {
    if (s == null) return 0;
    const t = String(s).trim().replace(/\s+/g, "").replace(",", ".");
    if (t === "") return 0;
    const v = Number(t);
    return Number.isFinite(v) ? v : 0;
  };
  const ymd = (d) => d.replaceAll("-", "");
  const todayISO = () => new Date().toISOString().slice(0,10);
  const clampText = (s, max=120) => String(s ?? "").slice(0,max);

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#39;");
  }
  function escapeAttr(s){
    // For quoted attributes; reuse HTML escaping.
    return escapeHtml(s);
  }

  // Download helper (creates a local file download)
  function downloadText(filename, text, mime="text/plain"){
    const blob = new Blob([text], { type: mime });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=> URL.revokeObjectURL(a.href), 1500);
  }

  function ymd8ToIso(s){
    const t = String(s || "").trim();
    if (!/^\d{8}$/.test(t)) return "";
    return `${t.slice(0,4)}-${t.slice(4,6)}-${t.slice(6,8)}`;
  }
  function isoToYmd8(iso){
    const t = String(iso || "").trim();
    if (/^\d{8}$/.test(t)) return t;
    if (/^\d{4}-\d{2}-\d{2}$/.test(t)) return t.replaceAll("-", "");
    return "";
  }
  function sieQuote(s){
    return `"${String(s ?? "").replaceAll('"', "''")}"`;
  }
  function sieTokens(line){
    const out = [];
    const re = /"([^"]*)"|(\S+)/g;
    let m;
    while ((m = re.exec(String(line || ""))) !== null){
      out.push(m[1] != null ? m[1] : m[2]);
    }
    return out;
  }

  function bankImportNormFpText(s){
    return String(s || "")
      .toLowerCase()
      .replace(/\s+/g, " ")
      .trim();
  }
  function bankImportFingerprintKey(dateISO, amount, text, ref){
    const d = String(dateISO || "").trim();
    const a = Number(amount);
    const t = bankImportNormFpText(text);
    const r = bankImportNormFpText(ref);
    if (!d || !Number.isFinite(a) || !t) return "";
    const base = `${d}|${a.toFixed(2)}|${t}`;
    return r ? `${base}|${r}` : base;
  }

  function normalizeImportedState(d){
    const base = defaultData();
    const o = (d && typeof d === "object") ? d : base;

    if (!o.company) o.company = base.company;
    const cdef = base.company;
    o.company = o.company || {};
    for (const k of Object.keys(cdef)) if (o.company[k] == null) o.company[k] = cdef[k];

    if (!o.features) o.features = { sruEnabled: false };
    if (typeof o.features.sruEnabled !== "boolean") o.features.sruEnabled = false;

    if (!o.fileSync) o.fileSync = { autosave: true, requireFile: false };
    if (typeof o.fileSync.autosave !== "boolean") o.fileSync.autosave = true;
    if (typeof o.fileSync.requireFile !== "boolean") o.fileSync.requireFile = false;

    if (!Array.isArray(o.fiscalYears)) o.fiscalYears = base.fiscalYears;
    if (!o.activeYearId) o.activeYearId = o.fiscalYears[0]?.id ?? String(new Date().getFullYear());
    if (!o.accounts) o.accounts = demoAccounts();

    // Repair account types (common when importing SIE into older versions)
    try{
      Object.entries(o.accounts || {}).forEach(([acc, meta])=>{
        if (!acc || !meta) return;
        const inferred = guessTypeFromAccountNo(acc);
        if (inferred === "asset" || inferred === "liability"){
          if (meta.type !== inferred) meta.type = inferred;
        } else {
          if (!meta.type || meta.type === "other") meta.type = inferred;
        }
      });
    }catch(e){}

    if (!Array.isArray(o.vouchers)) o.vouchers = [];
    // Voucher fields: add new compliance fields without destroying old content
    o.vouchers = o.vouchers
      .filter(v => v && typeof v === "object")
      .map(v=>{
        // required identity fields
        if (!v.id) v.id = crypto.randomUUID();
        if (!v.yearId) v.yearId = (v.date ? String(v.date).slice(0,4) : o.activeYearId);
        if (!v.series) v.series = "A";
        if (v.no == null) v.no = "";
        if (!v.date) v.date = todayISO();
        if (!v.regDate) v.regDate = v.date || todayISO();
        if (v.sign == null) v.sign = o.company?.defaultSign || "";
        if (!Array.isArray(v.lines)) v.lines = [];
        // normalize lines just enough for safe rendering & reports
        v.lines = v.lines
          .filter(l => l && typeof l === "object")
          .map(l=>({
            account: String(l.account||"").trim(),
            text: clampText(l.text||""),
            amount: Math.round((Number(l.amount)||0)*100)/100
          }))
          .filter(l => l.account && Math.abs(l.amount) > 0.00001);

        if (!("correctionOf" in v)) v.correctionOf = null;

        // Soft-delete / makulering
        const isVoided = (String(v.status||"") === "voided") || !!v.voidedAt || (v.voided === true);
        v.status = isVoided ? "voided" : "active";
        if (v.status === "voided"){
          if (!v.voidedAt) v.voidedAt = new Date().toISOString();
          if (v.voidedBy == null) v.voidedBy = "";
          if (v.voidReason == null) v.voidReason = "";
        }
        return v;
      });

    if (!Array.isArray(o.underlag)) o.underlag = [];
    // underlag entries are stored as metadata in state; file blobs are in IndexedDB keys "underlagBlob:<id>"
    o.underlag = o.underlag.filter(u=>u && typeof u === "object").map(u=>{
      if (!u.id) u.id = crypto.randomUUID();
      if (!u.voucherId) u.voucherId = "";
      if (!u.yearId) u.yearId = (u.date ? String(u.date).slice(0,4) : o.activeYearId);
      if (!u.series) u.series = "";
      if (u.no == null) u.no = "";
      if (!u.date) u.date = "";
      if (!u.type) u.type = "annat";
      if (u.ref == null) u.ref = "";
      if (u.note == null) u.note = "";
      if (!u.fileName) u.fileName = "underlag";
      if (u.mime == null) u.mime = "";
      if (u.size == null) u.size = 0;
      if (!u.status) u.status = "active";
      if (!u.createdAt) u.createdAt = new Date().toISOString();
      if (u.createdBy == null) u.createdBy = "";
      return u;
    });

    if (!o.customers) o.customers = {};
    if (!o.suppliers) o.suppliers = {};
    if (!Array.isArray(o.supplierInvoices)) o.supplierInvoices = [];
    o.supplierInvoices = o.supplierInvoices.filter(x=>x && typeof x==="object").map(si=>{
      if (!si.id) si.id = crypto.randomUUID();
      if (!si.docId) si.docId = "SI:" + si.id;
      if (!si.date) si.date = todayISO();
      if (!si.yearId) si.yearId = String(si.date).slice(0,4) || o.activeYearId;
      if (!si.due) si.due = si.date;
      if (si.invoiceNo == null) si.invoiceNo = "";
      if (si.ocr == null) si.ocr = "";
      if (!si.series) si.series = "L";
      if (!si.currency) si.currency = (o.company && o.company.currency) ? o.company.currency : "SEK";
      si.gross = Math.round((Number(si.gross)||0)*100)/100;
      si.vat = Math.round((Number(si.vat)||0)*100)/100;
      si.net = Math.round((Number(si.net)|| (si.gross - si.vat))*100)/100;
      if (!si.expenseAccount) si.expenseAccount = "4010";
      if (!si.vatAccount) si.vatAccount = "2641";
      if (!si.liabAccount) si.liabAccount = "2440";
      if (!si.status) si.status = si.bookedVoucherId ? "booked" : "received";
      if (si.bookedVoucherId == null) si.bookedVoucherId = null;
      if (!si.createdAt) si.createdAt = new Date().toISOString();
      if (si.createdBy == null) si.createdBy = "";
      if (si.updatedAt == null) si.updatedAt = null;
      if (si.updatedBy == null) si.updatedBy = "";
      if (si.supplierId == null) si.supplierId = null;
      if (si.supplierName == null) si.supplierName = "";
      if (si.supplierOrgnr == null) si.supplierOrgnr = "";
      if (si.supplierEmail == null) si.supplierEmail = "";
      if (si.supplierPayout == null) si.supplierPayout = "";
      return si;
    });
    if (!Array.isArray(o.invoices)) o.invoices = [];
    if (!o.locks || typeof o.locks !== "object") o.locks = {};
    if (!o.compliance) o.compliance = { immutableVouchers: true };

    // Audit trail (append-only)
    if (typeof o.auditSeq !== "number" || !Number.isFinite(o.auditSeq) || o.auditSeq < 0) o.auditSeq = 0;
    if (!Array.isArray(o.auditLog)) o.auditLog = [];
    try {
      const maxSeq = o.auditLog.reduce((m, e)=> Math.max(m, Number(e && e.seq) || 0), 0);
      if (maxSeq > o.auditSeq) o.auditSeq = maxSeq;
      if (!o.auditSeq && o.auditLog.length) o.auditSeq = o.auditLog.length;
    } catch {}

    if (!o.sru) o.sru = { enabled:false, periodSuffix:"P4", neMappings: [] };
    if (typeof o.sru.enabled !== "boolean") o.sru.enabled = false;
    if (!o.sru.periodSuffix) o.sru.periodSuffix = "P4";
    if (!Array.isArray(o.sru.neMappings)) o.sru.neMappings = [];

    // Bank import / inbox (staging only)
    if (!o.bankImport || typeof o.bankImport !== "object") o.bankImport = base.bankImport;
    if (!o.bankImport.batches || typeof o.bankImport.batches !== "object") o.bankImport.batches = {};
    if (!o.bankImport.items || typeof o.bankImport.items !== "object") o.bankImport.items = {};
    if (!o.bankImport.fingerprints || typeof o.bankImport.fingerprints !== "object") o.bankImport.fingerprints = {};
    if (!Array.isArray(o.bankImport.rules)) o.bankImport.rules = [];
    if (!o.bankImport.settings || typeof o.bankImport.settings !== "object") o.bankImport.settings = { lastSource: "bank", defaultBankAccount: "", defaultTaxAccount: "" };
    if (!o.bankImport.settings.lastSource) o.bankImport.settings.lastSource = "bank";
    if (o.bankImport.settings.defaultBankAccount == null) o.bankImport.settings.defaultBankAccount = "";
    if (o.bankImport.settings.defaultTaxAccount == null) o.bankImport.settings.defaultTaxAccount = "";

    // Field-name migration to spec (keep reading old names, but normalize in-memory)
    try {
      Object.values(o.bankImport.batches || {}).forEach((b)=>{
        if (!b || typeof b !== "object") return;
        if (!b.createdAtISO) b.createdAtISO = b.createdAt || "";
        if (!b.filename) b.filename = b.fileName || b.file || "";
        if (!b.accountBank) b.accountBank = b.bankAccount || "";
        if (typeof b.rowCount !== "number" || !Number.isFinite(b.rowCount)){
          const rc = Number(b.rowCount);
          b.rowCount = Number.isFinite(rc) ? rc : (Number(b.importedCount) || 0);
        }
        if (!Array.isArray(b.warnings)) b.warnings = [];
        if (b.fileHash == null) b.fileHash = "";
        if (b.mapping == null || typeof b.mapping !== "object") b.mapping = {};
        if (b.source == null) b.source = "";
      });

      Object.values(o.bankImport.items || {}).forEach((it)=>{
        if (!it || typeof it !== "object") return;
        if (!it.createdAtISO) it.createdAtISO = it.createdAt || "";
        if (it.ref == null) it.ref = "";
        if (it.raw == null) it.raw = null;
      });
    } catch {}

    // Rebuild fingerprint index (prevents duplicates even if older versions used different keys)
    try {
      const fp = {};
      Object.values(o.bankImport.items || {}).forEach((it)=>{
        if (!it || typeof it !== "object") return;
        const key = bankImportFingerprintKey(it.dateISO, it.amount, it.text, it.ref);
        if (!key) return;
        it.fingerprint = key;
        if (!fp[key]) fp[key] = it.id;
      });
      o.bankImport.fingerprints = fp;
    } catch {}

    return o;
  }
  function exportBackupJson(){
    const json = JSON.stringify(state, null, 2) + "\n";
    downloadText("backup.json", json, "application/json");
  }

// --- Auto-backup (JSON) to user-chosen folder (max 1 file/day) ---
const OLD_AUTO_BACKUP_LAST_DAY_KEY = "FU_AUTOBACKUP_LAST_DAY_V1"; // legacy single-company key (migration/fallback)
const AUTO_BACKUP_ENABLED_KEY  = "FU_AUTOBACKUP_ENABLED_V1";
let backupDirHandle = null;

function autoBackupEnabled(){
  try {
    const v = localStorage.getItem(AUTO_BACKUP_ENABLED_KEY);
    if (v == null) return true; // default ON
    return v === "1" || v === "true";
  } catch {
    return true;
  }
}
function setAutoBackupEnabled(on){
  try { localStorage.setItem(AUTO_BACKUP_ENABLED_KEY, on ? "1" : "0"); } catch {}
}
function getLastBackupDay(){
  try {
    const activeId = CompanyManager.getActiveCompanyId();
    const c = activeId ? CompanyManager.getCompanyMeta(activeId) : null;
    if (c && c.lastBackupDate) return String(c.lastBackupDate || "").trim();
  } catch {}
  // Fallback: old global key (pre-migration)
  try { return String(localStorage.getItem(OLD_AUTO_BACKUP_LAST_DAY_KEY) || "").trim(); } catch { return ""; }
}
function setLastBackupDay(day){
  const d = String(day || "").trim();
  try {
    if (CompanyManager.hasActiveCompany()){
      CompanyManager.updateActiveCompanyMeta({ lastBackupDate: d || null });
      return;
    }
  } catch {}
  // Fallback: old global key
  try { localStorage.setItem(OLD_AUTO_BACKUP_LAST_DAY_KEY, d); } catch {}
}
function backupFileNameForDay(day){
  const d = String(day || todayISO() || "").trim() || new Date().toISOString().slice(0,10);
  let name = "fu-bookkeeping";
  try {
    const activeId = CompanyManager.getActiveCompanyId();
    const c = activeId ? CompanyManager.getCompanyMeta(activeId) : null;
    name = safeFilename((c && c.name) ? c.name : (state && state.company && state.company.name) ? state.company.name : name);
  } catch {}
  return `${d}_${name}_backup.json`;
}
function backupApiSupported(){
  return !!(window.showDirectoryPicker && window.FileSystemFileHandle && window.FileSystemDirectoryHandle);
}
async function backupEnsurePermission(request){
  if (!backupDirHandle) return false;
  try {
    const mode = "readwrite";
    const q = await backupDirHandle.queryPermission({ mode });
    if (q === "granted") return true;
    if (!request) return false;
    const r = await backupDirHandle.requestPermission({ mode });
    return r === "granted";
  } catch {
    return false;
  }
}
async function backupWriteJsonToDir(day){
  if (!backupDirHandle) throw new Error("Ingen backup-mapp vald");
  const filename = backupFileNameForDay(day);
  const fileHandle = await backupDirHandle.getFileHandle(filename, { create: true });
  const writable = await fileHandle.createWritable();
  const json = JSON.stringify(state, null, 2) + "\n";
  await writable.write(json);
  await writable.close();
  return filename;
}
async function maybeDailyAutoBackup(trigger){
  try {
    if (!backupApiSupported()) return;
    if (!autoBackupEnabled()) return;
    if (!CompanyManager.hasActiveCompany()) return;
    if (!backupDirHandle) return;

    const today = todayISO();
    if (!today) return;

    const last = getLastBackupDay();
    if (last === today) return;

    const ok = await backupEnsurePermission(false); // never prompt automatically
    if (!ok) return;

    const filename = await backupWriteJsonToDir(today);
    setLastBackupDay(today);
    updateBackupUI();
    // keep it quiet – but log for debugging
    console.info("[AutoBackup] wrote", filename, "trigger=", trigger || "");
  } catch (e){
    console.warn("[AutoBackup] failed", e);
  }
}
async function chooseBackupFolder(){
  if (!backupApiSupported()){
    showToast("Autobackup kräver Chrome/Edge + HTTPS (File System Access API).", 6500);
    return;
  }
  if (!CompanyManager.hasActiveCompany()){
    showToast("Välj/koppla ett företag först.", 4500);
    return;
  }
  try{
    const h = await window.showDirectoryPicker({ mode: "readwrite" });
    if (!h) return;
    await CompanyManager.setActiveBackupDirHandle(h);

    const ok = await backupEnsurePermission(true); // user click → allow prompt
    if (!ok){
      showToast("Behörighet nekad till backup-mappen.", 6000);
      updateBackupUI();
      return;
    }

    updateBackupUI();
    // Create today's backup immediately (still max 1/day)
    await maybeDailyAutoBackup("choose-folder");
    showToast("Backup-mapp vald.", 2500);
  } catch (e){
    if (e && e.name === "AbortError") return;
    console.error(e);
    showToast("Kunde inte välja backup-mapp.", 6000);
  }
}
function updateBackupUI(){
  try{
    const el = document.getElementById("backupDirStatus");
    const chk = document.getElementById("chkAutoBackup");
    const btn = document.getElementById("btnChooseBackupDir");
    const pill = document.getElementById("backupPill");
    if (chk) chk.checked = autoBackupEnabled();
    const last = getLastBackupDay();
    const has = !!backupDirHandle;
    const supported = backupApiSupported();
    const hasCompany = CompanyManager.hasActiveCompany();

    if (btn){
      btn.textContent = has ? "Byt backup-mapp…" : "Byt backup-mapp…";
      btn.disabled = !hasCompany;
    }

    // Header indicator: green only when folder selected AND at least one backup written
    if (pill){
      if (!supported){
        pill.textContent = "Backup: stöds ej";
        setPillState(pill, "bad");
      } else if (!hasCompany){
        pill.textContent = "Backup: inget företag";
        setPillState(pill, "bad");
      } else if (!has){
        pill.textContent = "Backup: ej vald";
        setPillState(pill, "");
      } else if (last){
        pill.textContent = `Backup: ${last}`;
        setPillState(pill, "ok");
      } else {
        pill.textContent = "Backup: vald";
        setPillState(pill, "");
      }
    }

    if (el){
      if (!backupApiSupported()){
        el.textContent = "Autobackup stöds ej i denna webbläsare.";
      } else if (!hasCompany){
        el.textContent = "Inget aktivt företag.";
      } else if (!has){
        el.textContent = "Ingen backup-mapp vald.";
      } else {
        el.textContent = last ? (`Senast backup: ${last}`) : "Backup-mapp vald.";
      }
    }
  } catch {}
}


  async function importBackupJsonFile(file){
    if (!file) return;
    const txt = await file.text();
    const d = JSON.parse(txt);
    state = normalizeImportedState(d);
    try { fillYearSelectors(); } catch (e){ console.error(e); }
    save();
    try { newVoucher(); } catch (e){ console.error(e); }
    try { newInvoice(); } catch (e){ console.error(e); }
    try { renderAll(); } catch (e){ console.error(e); }
    showToast("Import klar.", 3000);
  }

  async function wipeAllData(){
    if (!(await confirmAsync("Rensa ALL data? Detta kan inte ångras. Ta en backup först."))) return;
    try { localStorage.removeItem(STORAGE_KEY); } catch (e){ console.error(e); }
    try { await fsDisconnect(); } catch (e){ /* ignore */ }
    state = defaultData();
    try { fillYearSelectors(); } catch (e){ console.error(e); }
    save();
    try { newVoucher(); } catch (e){ console.error(e); }
    try { newInvoice(); } catch (e){ console.error(e); }
    try { renderAll(); } catch (e){ console.error(e); }
    showToast("All data rensad.", 3500);
  }

  function exportSie4(yearId){
    const yid = String(yearId || state.activeYearId || "").trim();
    if (!yid) return showToast("Välj år.", 3500);

    const fy = (state.fiscalYears||[]).find(y=>String(y.id)===yid) || null;
    const vs = (state.vouchers||[])
      .filter(v => String(v.yearId) === yid && !isVoidedVoucher(v))
      .slice()
      .sort((a,b)=> (a.date+a.series+a.no).localeCompare(b.date+b.series+b.no, "sv"));

    const lines = [];
    lines.push("#FLAGGA 0");
    lines.push(`#PROGRAM ${sieQuote("FU-BOOKKEEPING")} ${APP_VERSION}`);
    lines.push(`#GEN ${isoToYmd8(todayISO())}`);
    lines.push("#SIETYP 4");
    if (state.company?.name) lines.push(`#FNAMN ${sieQuote(state.company.name)}`);
    if (state.company?.orgnr) lines.push(`#ORGNR ${state.company.orgnr}`);
    if (fy && fy.start && fy.end) lines.push(`#RAR 0 ${isoToYmd8(fy.start)} ${isoToYmd8(fy.end)}`);

    Object.keys(state.accounts||{}).sort((a,b)=>a.localeCompare(b,"sv")).forEach(acc=>{
      const nm = state.accounts[acc]?.name || "";
      lines.push(`#KONTO ${acc} ${sieQuote(nm)}`);
    });

    vs.forEach(v=>{
      const series = (v.series || "A").trim() || "A";
      const no = (v.no || "").trim() || "0";
      const dt = isoToYmd8(v.date || "") || isoToYmd8(todayISO());
      const txt = v.text || "";
      const sign = v.sign || "";
      lines.push(`#VER ${series} ${no} ${dt} ${sieQuote(txt)} ${sieQuote(sign)}`);
      (v.lines||[]).forEach(l=>{
        const acc = String(l.account || "").trim();
        if (!acc) return;
        const amt = Math.round((Number(l.amount)||0)*100)/100;
        const amtTxt = (Number.isFinite(amt) ? amt.toFixed(2) : "0.00");
        const lt = l.text || v.text || "";
        lines.push(`#TRANS ${acc} {} ${amtTxt} ${dt} ${sieQuote(lt)}`);
      });
      lines.push("{");
      lines.push("}");
    });
    lines.push("#END");

    const filename = `SIE4_${yid}.se`;
    downloadText(filename, lines.join("\n") + "\n", "text/plain");
  }

  
  async function importSieText(txt, wipe, fileName){
    if (wipe && !(await confirmAsync("Rensa innan import? (Rekommenderas endast om du vill ersätta allt.)"))) return;

if (wipe){
      // Keep company defaults but wipe data.
      const keepCompany = state?.company || defaultData().company;
      state = defaultData();
      state.company = { ...state.company, ...keepCompany };
    }

    state = normalizeImportedState(state);

    const importedAccounts = {};
    const importedYears = [];
        const importedVouchers = [];

    // SIE uses relative year identifiers in #RAR (often 0, -1, -2 ...).
    // We normalize them to an absolute year key (YYYY) based on the #RAR start date,
    // so fiscal years don’t show up as duplicates like -1/0 alongside 2024/2025.
    let currentSieYearId = "";
    const yearIdMap = Object.create(null);
    const normalizeYearKey = (sieId, startIso, endIso)=>{
      const s = (startIso || "").slice(0,4);
      const e = (endIso || "").slice(0,4);
      const y = (s || e || "").trim();
      if (y && /^\d{4}$/.test(y)) return y;
      const sid = String(sieId || "").trim();
      if (/^\d{4}$/.test(sid)) return sid;
      return (new Date().getFullYear()).toString();
    };
    const resolveYearIdForDate = (isoDate)=>{
      const d8 = isoToYmd8(isoDate);
      if (d8){
        // Prefer fiscal years declared in the currently imported SIE file (#RAR)
        for (const y of (importedYears||[])){
          const s8 = isoToYmd8(y.start);
          const e8 = isoToYmd8(y.end);
          if (s8 && e8 && s8 <= d8 && d8 <= e8) return String(y.id);
        }
        // Fallback to already existing years in state
        for (const y of (state.fiscalYears||[])){
          const s8 = isoToYmd8(y.start);
          const e8 = isoToYmd8(y.end);
          if (s8 && e8 && s8 <= d8 && d8 <= e8) return String(y.id);
        }
        return String(isoDate||"").slice(0,4) || (new Date().getFullYear()).toString();
      }
      return String(isoDate||"").slice(0,4) || (new Date().getFullYear()).toString();
    };


    let cur = null;

const flush = ()=>{
      if (!cur) return;
      if (!Array.isArray(cur.lines)) cur.lines = [];
      // skip empty
      if (!cur.series && !cur.no && !cur.lines.length){ cur = null; return; }
      if (!cur.id) cur.id = crypto.randomUUID();
      if (!cur.regDate) cur.regDate = todayISO();
      if (!cur.sign) cur.sign = state.company?.defaultSign || "";
      if (!cur.yearId) cur.yearId = currentYearId || (cur.date ? String(cur.date).slice(0,4) : state.activeYearId);
      importedVouchers.push(cur);
      cur = null;
    };

    const lines = String(txt).split(/\r?\n/);
    for (const rawLine of lines){
      const line = rawLine.trim();
      if (!line) continue;
      if (!line.startsWith("#")) continue;

      const t = sieTokens(line);
      const tag = t[0];

      if (tag === "#RAR"){
        // Fiscal year definition: #RAR <yearId> <startYYYYMMDD> <endYYYYMMDD>
        const sieYid = String(t[1] || "").trim();
        const start = ymd8ToIso(t[2]) || "";
        const end = ymd8ToIso(t[3]) || "";
        if (sieYid){
          currentSieYearId = sieYid;
          const normY = normalizeYearKey(sieYid, start, end);
          yearIdMap[sieYid] = normY;
          currentYearId = normY;
          importedYears.push({ id: normY, sieId: sieYid, start, end });}
        continue;
      }

      if (tag === "#FNAMN" && t[1] != null){
        state.company = state.company || defaultData().company;
        state.company.name = String(t.slice(1).join(" ") || "").trim();
        continue;
      }
      if (tag === "#ORGNR" && t[1] != null){
        state.company = state.company || defaultData().company;
        state.company.orgnr = String(t[1] || "").trim();
        continue;
      }

      if (tag === "#RAR" && t.length >= 4){
        const start = ymd8ToIso(t[2]);
        const end = ymd8ToIso(t[3]);
        const yid = (start ? start.slice(0,4) : "");
        if (yid){
          currentYearId = yid;
          importedYears.push({ id: yid, start: start || `${yid}-01-01`, end: end || `${yid}-12-31` });
        }
        continue;
      }

      if (tag === "#KONTO" && t.length >= 3){
        const acc = String(t[1] || "").trim();
        const name = String(t[2] || "").trim();
        if (acc){
          const prevType = (state.accounts && state.accounts[acc] && state.accounts[acc].type) ? state.accounts[acc].type : "";
          const inferred = guessTypeFromAccountNo(acc);
          importedAccounts[acc] = { name, type: (prevType && prevType !== "other") ? prevType : inferred };
        }
        continue;
      }

      if (tag === "#VER"){
        flush();
        const series = String(t[1] || "A").trim() || "A";
        const no = String(t[2] || "0").trim() || "0";
        const date = ymd8ToIso(t[3]) || todayISO();
        const text = (t[4] != null ? String(t[4]) : "").trim();
        const sign = (t[5] != null ? String(t[5]) : "").trim();
        const yid = resolveYearIdForDate(date);
        currentYearId = yid;
        // don’t overwrite currentSieYearId here; it tracks the last #RAR seen
cur = {
          id: crypto.randomUUID(),
          yearId: yid,
          series,
          no,
          date,
          text,
          regDate: todayISO(),
          sign,
          lines: [],
          correctionOf: null
        };
        continue;
      }

      if (tag === "#TRANS" && cur){
        const acc = String(t[1] || "").trim();
        // Find first numeric token after account/optional object token
        let amt = 0;
        for (let i = 2; i < t.length; i++){
          const v = String(t[i] || "");
          if (v === "{}" || v === "{" || v === "}") continue;
          const n = Number(v.replace(",", "."));
          if (Number.isFinite(n)) { amt = n; break; }
        }
        const text = (t[t.length-1] != null ? String(t[t.length-1]) : "").trim();
        if (acc){
          cur.lines.push({ account: acc, text, amount: Math.round(amt*100)/100 });
        }
        continue;
      }
    }
    flush();
    // Ensure fiscal years exist for imported vouchers (some SIE files omit #RAR)
    try{
      const yearIds = new Set();
      if (currentYearId) yearIds.add(String(currentYearId));
      importedVouchers.forEach(v=>{ if (v && v.yearId) yearIds.add(String(v.yearId)); });
      yearIds.forEach(yid=>{
        if (!yid) return;
        const exists = importedYears.find(y=>String(y.id)===String(yid));
        if (!exists) importedYears.push({ id: yid, start:"", end:"" });
      });
    } catch {}

    // Merge fiscal years
    state.fiscalYears = state.fiscalYears || [];
    importedYears.forEach(y=>{
      if (!y || !y.id) return;
      const exists = state.fiscalYears.find(x=>String(x.id)===String(y.id));
      if (!exists) state.fiscalYears.push(y);
    });
    state.fiscalYears.sort((a,b)=>String(a.id).localeCompare(String(b.id),"sv"));

    // De-dup fiscal years (SIE can use relative ids like 0 / -1; we keep one per period)
    try{
      const byPeriod = new Map(); // key=start|end -> {keep, dropIds[]}
      (state.fiscalYears||[]).forEach(y=>{
        const s = (y.start||"").trim();
        const e = (y.end||"").trim();
        const key = s + "|" + e;
        if (!byPeriod.has(key)){
          byPeriod.set(key, { keep: y, drop: [] });
        } else {
          const cur = byPeriod.get(key);
          const prefer = (obj)=> (/^\d{4}$/.test(String(obj.id||"")) ? 2 : 1);
          // prefer absolute year id (YYYY)
          if (prefer(y) > prefer(cur.keep)){
            cur.drop.push(cur.keep);
            cur.keep = y;
          } else {
            cur.drop.push(y);
          }
          byPeriod.set(key, cur);
        }
      });

      const dropIds = new Map(); // oldId -> newId
      byPeriod.forEach(v=>{
        v.drop.forEach(d=>{
          if (d && d.id != null) dropIds.set(String(d.id), String(v.keep.id));
        });
      });

      if (dropIds.size){
        state.fiscalYears = (state.fiscalYears||[]).filter(y=> !dropIds.has(String(y.id)));
        // rewrite vouchers to kept ids
        (state.vouchers||[]).forEach(v=>{
          const nid = dropIds.get(String(v.yearId));
          if (nid) v.yearId = nid;
        });
        const aid = dropIds.get(String(state.activeYearId||""));
        if (aid) state.activeYearId = aid;
      }
    }catch(e){}

    // Merge accounts
    state.accounts = state.accounts || {};
    Object.entries(importedAccounts).forEach(([acc, meta])=>{
      if (!acc) return;
      state.accounts[acc] = state.accounts[acc] || { name: meta.name || "", type: meta.type || "other" };
      if (meta.name) state.accounts[acc].name = meta.name;
    });

    // Repair account types inferred from account number (prevents wrong "type" from breaking reports)
    Object.entries(state.accounts).forEach(([acc, meta])=>{
      if (!acc || !meta) return;
      const inferred = guessTypeFromAccountNo(acc);
      if (inferred === "asset" || inferred === "liability"){
        if (meta.type !== inferred) meta.type = inferred;
      } else {
        if (!meta.type || meta.type === "other") meta.type = inferred;
      }
    });

    // Merge vouchers
    state.vouchers = state.vouchers || [];
    importedVouchers.forEach(v=>{
      if (!v || typeof v !== "object") return;
      if (!("correctionOf" in v)) v.correctionOf = null;
      if (!v.status) v.status = "active";
      state.vouchers.push(v);
    });

    // Pick active year
    const active = currentYearId || state.activeYearId || state.fiscalYears[0]?.id;
    if (active) state.activeYearId = active;

    try { fillYearSelectors(); } catch (e){ console.error(e); }
    save();
    try { newVoucher(); } catch (e){ console.error(e); }
    try { renderAll(); } catch (e){ console.error(e); }
    appendAudit({
      action: "sie.import",
      entityType: "system",
      entityId: "sie",
      yearId: state.activeYearId || currentYearId || "",
      details: { file: fileName || "", importedAccounts: Object.keys(importedAccounts).length, importedVouchers: importedVouchers.length }
    });
    showToast(`SIE-import${fileName ? " ("+fileName+")" : ""} klar. Importerade ${Object.keys(importedAccounts).length} konton och ${importedVouchers.length} verifikationer.`, 5500);  }

  async function importSieFile(file, encoding, wipe){
    if (!file) return showToast("Välj en SIE-fil först.", 3500);

    const buf = await file.arrayBuffer();
    const preferred = String(encoding || "utf-8");
    const dec = decodeWithBestEncoding(buf, preferred);
    const txt = dec.text;
    if (dec.enc && String(dec.enc) !== String(preferred)){
      showToast(`Teckenkodning: använde ${dec.enc} (i stället för ${preferred}) för att undvika "�".`, 6500);
    }
    return importSieText(txt, wipe, file && file.name ? file.name : "");
  }

  async function sha256Hex(text){
    const data = new TextEncoder().encode(String(text));
    const hash = await crypto.subtle.digest("SHA-256", data);
    const bytes = Array.from(new Uint8Array(hash));
    return bytes.map(b => b.toString(16).padStart(2,"0")).join("");
  }

  async function sha256HexBuf(buf){
    const hash = await crypto.subtle.digest("SHA-256", buf);
    const bytes = Array.from(new Uint8Array(hash));
    return bytes.map(b => b.toString(16).padStart(2,"0")).join("");
  }

  async function sha256HexBlob(blob){
    const ab = await blob.arrayBuffer();
    return sha256HexBuf(ab);
  }

  function archiveBuildObject(yearId){
    const fy = (state.fiscalYears||[]).find(y=>y.id===yearId) || null;
    const vouchers = (state.vouchers||[]).filter(v=>v.yearId===yearId);
    const invoices = (state.invoices||[]).filter(i=>i.yearId===yearId);
    const supplierInvoices = (state.supplierInvoices||[]).filter(si=>si && si.yearId===yearId);
    const auditLog = (state.auditLog||[]).filter(e=>String(e.yearId||"")===String(yearId));
    const lockUntil = lockUntilForYear(yearId);

    // collect referenced customers/suppliers (keep minimal but sufficient)
    const customers = {};
    for (const inv of invoices){
      const cid = inv.customerId;
      if (cid && state.customers && state.customers[cid]) customers[cid] = state.customers[cid];
    }
    const suppliers = {};
    // suppliers referenced by supplierInvoices (keep minimal but sufficient)
    for (const si of supplierInvoices){
      if (!si) continue;
      const sid = si.supplierId;
      if (sid && state.suppliers && state.suppliers[sid]){
        suppliers[sid] = state.suppliers[sid];
      } else {
        // fallback: store what was on the invoice itself (if user didn't create a supplier)
        const k = ("_adHoc_" + (si.supplierName||"")).trim();
        if (si.supplierName && !suppliers[k]){
          suppliers[k] = { name: si.supplierName || "", orgnr: si.supplierOrgnr || "", email: si.supplierEmail || "", payout: si.supplierPayout || "", addr: "" };
        }
      }
    }
    return {
      schema: "FU_BOOKKEEPING_ARCHIVE_V1",
      app: "FU-BOOKKEEPING",
      appVersion: APP_VERSION,
      createdAt: new Date().toISOString(),
      yearId,
      fiscalYear: fy,
      company: {
        name: state.company?.name || "",
        orgnr: state.company?.orgnr || "",
        currency: state.company?.currency || "SEK",
        addr: state.company?.addr || "",
        zip: state.company?.zip || "",
        city: state.company?.city || "",
        country: state.company?.country || "",
        email: state.company?.email || "",
        phone: state.company?.phone || "",
        web: state.company?.web || "",
        vat: state.company?.vat || "",
        payDays: state.company?.payDays ?? 30,
        bankgiro: state.company?.bankgiro || "",
        plusgiro: state.company?.plusgiro || "",
        iban: state.company?.iban || "",
        swift: state.company?.swift || "",
        invoiceNote: state.company?.invoiceNote || "",
        invoiceFooter: state.company?.invoiceFooter || "",
        logoDataUrl: state.company?.logoDataUrl || ""
      },
      accounts: state.accounts || {},
      locks: lockUntil ? { [yearId]: lockUntil } : {},
      vouchers,
      invoices,
      supplierInvoices,
      customers,
      suppliers,
      underlag: (state.underlag||[]).filter(u=>u && (u.yearId||"")===yearId),
      auditLog,
      notes: "Arkivexport: spara JSON + SHA256 på en plats du kontrollerar. Paketet innehåller även auditLog (behandlingshistorik) och ev. makulerade verifikationer. För långtidsarkiv: gör även offline-kopia (t.ex. extern disk/print/PDF)."
    };
  }

  async function makeArchive(yearId){
    if (!yearId) return showToast("Välj räkenskapsår.", 3500);
    const obj = archiveBuildObject(yearId);
    const json = JSON.stringify(obj, null, 2) + "\n";
    const sha = await sha256Hex(json);
    const ts = new Date().toISOString().replace(/[:.]/g,"-").slice(0,19);
    const base = `FU_ARCHIVE_${yearId}_${ts}`;
    appendAudit({ action:"archive.export", entityType:"archive", entityId: base, yearId, details:{ sha, bytes: json.length } });
    save();
    downloadText(base + ".json", json, "application/json");
    downloadText(base + ".sha256.txt", sha + "  " + base + ".json\n", "text/plain");
    if (archiveVerifyResult) archiveVerifyResult.textContent = `Skapade arkiv för ${yearId}. SHA-256: ${sha.slice(0,12)}…`;
  }


  async function makeArchiveFolder(yearId){
    if (!yearId) return showToast("Välj räkenskapsår.", 3500);
    if (typeof window.showDirectoryPicker !== "function"){
      showToast("Arkivmapp kräver Chrome/Edge i HTTPS/localhost (File System Access API).", 6500);
      return;
    }

    const obj = archiveBuildObject(yearId);
    const json = JSON.stringify(obj, null, 2) + "\n";
    const shaJson = await sha256Hex(json);
    const ts = new Date().toISOString().replace(/[:.]/g,"-").slice(0,19);
    const base = `FU_ARCHIVE_${yearId}_${ts}`;

    let root;
    try {
      root = await window.showDirectoryPicker({ mode: "readwrite" });
    } catch (e){
      if (e && e.name === "AbortError") return;
      throw e;
    }

    async function ensureDir(rootDir, parts){
      let d = rootDir;
      for (const p of parts){
        if (!p) continue;
        d = await d.getDirectoryHandle(String(p), { create: true });
      }
      return d;
    }

    async function writeText(dir, name, text, mime){
      const fh = await dir.getFileHandle(name, { create: true });
      const w = await fh.createWritable();
      await w.write(new Blob([text], { type: mime || "text/plain" }));
      await w.close();
    }

    async function writeBlob(dir, name, blob){
      const fh = await dir.getFileHandle(name, { create: true });
      const w = await fh.createWritable();
      await w.write(blob);
      await w.close();
    }

    function uniqueName(used, name){
      const base = String(name || "underlag");
      if (!used.has(base)){ used.add(base); return base; }
      const m = base.match(/^(.*?)(\.[A-Za-z0-9]{1,8})?$/);
      const stem = (m && m[1]) ? m[1] : base;
      const ext = (m && m[2]) ? m[2] : "";
      for (let i=2; i<10_000; i++){
        const nn = `${stem}_${i}${ext}`;
        if (!used.has(nn)){ used.add(nn); return nn; }
      }
      return `${stem}_${crypto.randomUUID().slice(0,8)}${ext}`;
    }

    // Create folder structure
    const outDir = await root.getDirectoryHandle(base, { create: true });

    // Write archive JSON + SHA
    await writeText(outDir, "archive.json", json, "application/json");
    await writeText(outDir, "archive.sha256.txt", shaJson + "  archive.json\n", "text/plain");

    const manifestLines = [];
    manifestLines.push(`${shaJson}  archive.json`);

    // Underlag files
    const underlag = (state.underlag||[]).filter(u=>u && (u.yearId||"")===yearId);
    const underlagIndex = [];
    const usedByFolder = new Map(); // folderPath -> Set(names)

    for (const u of underlag){
      const blob = await idbGet("underlagBlob:" + u.id);
      if (!blob){
        underlagIndex.push({ ...u, relPath: null, sha256: null, note2: "SAKNAS LOKALT (IndexedDB)" });
        continue;
      }

      const series = (String(u.series||"").trim() || "_");
      const no = padVerno(u.no) || ("_unlinked_" + String(u.voucherId||"").slice(0,8));
      const baseParts = (String(u.status||"") === "detached") ? ["underlag", "_bortkopplat", series, no] : ["underlag", series, no];
      const folderPath = baseParts.join("/");

      const dir = await ensureDir(outDir, baseParts);

      const used = usedByFolder.get(folderPath) || new Set();
      usedByFolder.set(folderPath, used);

      const fname = uniqueName(used, safeFileName(u.fileName || "underlag"));
      await writeBlob(dir, fname, blob);

      const relPath = folderPath + "/" + fname;
      const shaFile = await sha256HexBlob(blob);
      manifestLines.push(`${shaFile}  ${relPath}`);

      // Optional: include OCR-text (if available) as a .ocr.txt file next to underlaget
      let ocrRelPath = null;
      let ocrSha256 = null;
      try {
        const ocr = await idbGet("underlagOcr:" + u.id);
        if (ocr && ocr.text){
          const baseName = String(fname).replace(/\.[A-Za-z0-9]{1,8}$/,"");
          const ocrName = uniqueName(used, safeFileName(baseName + ".ocr.txt"));
          const ocrText = String(ocr.text || "");
          await writeText(dir, ocrName, ocrText, "text/plain;charset=utf-8");
          ocrRelPath = folderPath + "/" + ocrName;
          ocrSha256 = await sha256Hex(ocrText);
          manifestLines.push(`${ocrSha256}  ${ocrRelPath}`);
        }
      } catch (e){ /* ignore OCR export failures */ }

      underlagIndex.push({ ...u, relPath, sha256: shaFile, ocrRelPath, ocrSha256 });
    }

    // Write underlag index + manifest
    await writeText(await ensureDir(outDir, ["underlag"]), "index.json", JSON.stringify({ yearId, base, generatedAt: new Date().toISOString(), items: underlagIndex }, null, 2) + "\n", "application/json");
    await writeText(outDir, "manifest.sha256.txt", manifestLines.sort((a,b)=>a.localeCompare(b,"sv")).join("\n") + "\n", "text/plain");

    appendAudit({ action:"archive.exportFolder", entityType:"archive", entityId: base, yearId, details:{ shaArchive: shaJson, files: underlagIndex.length } });
    save();

    if (archiveVerifyResult) archiveVerifyResult.textContent = `Skapade arkivmapp ${base} (${yearId}).`;
    showToast(`Arkivmapp skapad: ${base}`, 4500);
  }

  async function verifyArchive(){
    const fJson = archiveImportJson && archiveImportJson.files ? archiveImportJson.files[0] : null;
    if (!fJson) return showToast("Välj en arkiv-JSON först.", 3500);
    const txt = await fJson.text();
    let shaProvided = "";
    const fSha = archiveImportSha && archiveImportSha.files ? archiveImportSha.files[0] : null;
    if (fSha){
      const s = (await fSha.text()).trim();
      // accept formats like: "<hash>  filename"
      shaProvided = s.split(/\s+/)[0].trim().toLowerCase();
    }
    const shaCalc = await sha256Hex(txt);
    const ok = shaProvided ? (shaCalc === shaProvided) : true;

    let meta = "";
    try{
      const obj = JSON.parse(txt);
      if (obj && obj.schema) meta = ` · ${obj.schema} · år ${obj.yearId || "?"}`;
    } catch {}

    if (archiveVerifyResult){
      archiveVerifyResult.innerHTML = ok
        ? `<span class="status ok">OK</span> SHA-256: <span class="kbd">${shaCalc}</span>${meta}`
        : `<span class="status bad">FEL</span> Beräknad SHA-256: <span class="kbd">${shaCalc}</span> · Filens SHA: <span class="kbd">${shaProvided}</span>${meta}`;
    } else {
      showToast(ok ? "Arkiv OK" : "Arkiv FEL (checksum matchar inte)", 5500);
    }
  }




  // --- Year selector sync (single source of truth) ---
  function fillYearSelectors(){
    const ys = (state.fiscalYears||[]).slice().sort((a,b)=>String(a.id).localeCompare(String(b.id),"sv"));
    const active = state.activeYearId || ys[0]?.id || "";

    function fillSelect(sel, prefer){
      if (!sel) return;
      const prev = prefer ?? sel.value;
      sel.innerHTML = "";
      ys.forEach(y=>{
        const opt = document.createElement("option");
        opt.value = y.id;
        opt.textContent = `${y.id} (${y.start} – ${y.end})`;
        sel.appendChild(opt);
      });
      sel.value = ys.find(y=>y.id===prev)?.id || ys.find(y=>y.id===active)?.id || ys[0]?.id || "";
    }

    fillSelect(yearSelect, active);
  fillSelect(rptYearSelect, active);
    fillSelect(sieYearSelect, active);
    fillSelect(archiveYearSelect, active);
    fillSelect(carryFrom, ys[0]?.id || active);
    fillSelect(carryTo, active);
    fillSelect(invYearSelect, active);
    fillSelect(siYearSelect, active);
    fillSelect(lockYear, active);

    if (yearPillSelect){
      const prev = yearPillSelect.value;
      yearPillSelect.innerHTML = "";
      ys.forEach(y=>{
        const opt = document.createElement("option");
        opt.value = y.id;
        opt.textContent = `Räkenskapsår: ${y.id} (${y.start} – ${y.end})`;
        yearPillSelect.appendChild(opt);
      });
      yearPillSelect.value = ys.find(y=>y.id===active)?.id || ys.find(y=>y.id===prev)?.id || ys[0]?.id || "";
    }

    // period lock UI
    if (lockYear && lockUntil){
      const yid = lockYear.value || active;
      lockUntil.value = lockUntilForYear(yid);
    }
  }


  // --- Print helpers ---
  function printHtmlDocument(title, bodyHtml){
    const doc = `<!doctype html><html><head><meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>${title}</title>
      <style>
        body{ font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; padding:24px; color:#111; background:#fff; }
          div.addEventListener("click", async (e)=>{
        .muted{ color:#555; }
        .card{ border:1px solid #ddd; border-radius:12px; padding:12px; margin:0 0 12px 0; background:#fff; }
        table{ width:100%; border-collapse:collapse; margin-top:10px; }
        th,td{ border-bottom:1px solid #ddd; padding:6px 6px; text-align:left; vertical-align:top; }
        th{ font-size:12px; color:#333; }
        td{ font-size:12px; }
            if (act==="del") await deleteInvoice(id);
        .row{ display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:flex-start; }
        @media print{
          body{ padding:0; }
          .noprint{ display:none !important; }
          .card{ page-break-inside:avoid; }
        }
      </style>
    </head><body>${bodyHtml}<script>window.onload=()=>window.print();<\/script></body></html>`;
    const w = window.open("", "_blank");
    if (!w) return showToast("Popup blockerad. Tillåt popup för att skriva ut.", 6000);
    w.document.open();
    w.document.write(doc);
    w.document.close();
  }
  // --- IndexedDB (för att lagra fil-handle mellan sessioner) ---
  const IDB_DB = "mini_bokforing_idb";
  const IDB_STORE = "kv";

  function idbOpen(){
    return new Promise((resolve, reject)=>{
      const req = indexedDB.open(IDB_DB, 1);
      req.onupgradeneeded = ()=>{
        const db = req.result;
        if (!db.objectStoreNames.contains(IDB_STORE)) db.createObjectStore(IDB_STORE);
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbGet(key){
    const db = await idbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(IDB_STORE, "readonly");
      const st = tx.objectStore(IDB_STORE);
      const req = st.get(key);
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbSet(key, value){
    const db = await idbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(IDB_STORE, "readwrite");
      const st = tx.objectStore(IDB_STORE);
      const req = st.put(value, key);
      req.onsuccess = ()=> resolve(true);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbDel(key){
    const db = await idbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(IDB_STORE, "readwrite");
      const st = tx.objectStore(IDB_STORE);
      const req = st.delete(key);
      req.onsuccess = ()=> resolve(true);
      req.onerror = ()=> reject(req.error);
    });
  }


  // --- Company Registry (multi-company; metadata in localStorage, handles in separate IndexedDB) ---
  const COMPANY_REGISTRY_KEY = "fu_company_registry_v1";
  const COMPANY_REGISTRY_MIGRATED_FLAG = "fu_company_registry_migrated_v1";
  const HANDLES_DB = "fu_handles_db";
  const HANDLES_STORE = "handles";

  function nowISO(){
    return new Date().toISOString();
  }

  function companyEmptyRegistry(){
    return { version: 1, activeCompanyId: null, companies: {} };
  }

  function companyLoadRegistry(){
    try {
      const raw = localStorage.getItem(COMPANY_REGISTRY_KEY);
      if (!raw) return null;
      const r = JSON.parse(raw);
      if (!r || typeof r !== "object") return null;
      if (r.version !== 1) return null;
      if (!r.companies || typeof r.companies !== "object") r.companies = {};
      if (r.activeCompanyId != null) r.activeCompanyId = String(r.activeCompanyId || "").trim() || null;

      // normalize company metas
      for (const [id, c] of Object.entries(r.companies)){
        if (!c || typeof c !== "object"){
          delete r.companies[id];
          continue;
        }
        c.id = String(c.id || id);
        c.name = String(c.name || "").trim() || "(namnlöst företag)";
        c.orgnr = String(c.orgnr || "").trim();
        c.createdAtISO = String(c.createdAtISO || "").trim() || nowISO();
        c.lastOpenedISO = String(c.lastOpenedISO || "").trim();
        c.lastBackupDate = c.lastBackupDate ? String(c.lastBackupDate) : null;
        c.colorTag = c.colorTag ? String(c.colorTag) : null;
        // Handles are stored in IndexedDB; keep only metadata here.
      }
      if (r.activeCompanyId && !r.companies[r.activeCompanyId]) r.activeCompanyId = null;
      return r;
    } catch {
      return null;
    }
  }

  function companySaveRegistry(reg){
    try {
      localStorage.setItem(COMPANY_REGISTRY_KEY, JSON.stringify(reg));
      return true;
    } catch (e){
      console.error(e);
      return false;
    }
  }

  function handlesDbOpen(){
    return new Promise((resolve, reject)=>{
      const req = indexedDB.open(HANDLES_DB, 1);
      req.onupgradeneeded = ()=>{
        const db = req.result;
        if (!db.objectStoreNames.contains(HANDLES_STORE)) db.createObjectStore(HANDLES_STORE);
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbGetHandle(key){
    const db = await handlesDbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(HANDLES_STORE, "readonly");
      const st = tx.objectStore(HANDLES_STORE);
      const req = st.get(key);
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbSetHandle(key, handle){
    const db = await handlesDbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(HANDLES_STORE, "readwrite");
      const st = tx.objectStore(HANDLES_STORE);
      const req = st.put(handle, key);
      req.onsuccess = ()=> resolve(true);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbDelHandle(key){
    const db = await handlesDbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(HANDLES_STORE, "readwrite");
      const st = tx.objectStore(HANDLES_STORE);
      const req = st.delete(key);
      req.onsuccess = ()=> resolve(true);
      req.onerror = ()=> reject(req.error);
    });
  }

  function companyHandleKey(companyId, kind){
    return `${companyId}:${kind}`;
  }

  function companyNewId(prefix="c_"){
    try {
      return prefix + crypto.randomUUID();
    } catch {
      return prefix + String(Date.now()) + "_" + Math.random().toString(16).slice(2);
    }
  }

  const CompanyManager = (()=>{
    let registry = null;

    function getRegistry(){
      if (!registry) registry = companyLoadRegistry() || companyEmptyRegistry();
      return registry;
    }

    function saveRegistry(){
      const r = getRegistry();
      return companySaveRegistry(r);
    }

    function getActiveCompanyId(){
      const r = getRegistry();
      return r.activeCompanyId || null;
    }

    function getCompanyMeta(companyId){
      const r = getRegistry();
      const id = String(companyId || "").trim();
      if (!id) return null;
      return r.companies && r.companies[id] ? r.companies[id] : null;
    }

    function listCompanies(){
      const r = getRegistry();
      return Object.values(r.companies || {});
    }

    function hasActiveCompany(){
      return !!getActiveCompanyId();
    }

    function activeCompanyDisplayName(){
      const c = getCompanyMeta(getActiveCompanyId());
      return c ? (c.name || "") : "";
    }

    function updateCompanySelectUI(){
      const sel = document.getElementById("companySelect");
      if (!sel) return;
      const r = getRegistry();
      const active = r.activeCompanyId || "";

      const companies = Object.values(r.companies || {})
        .slice()
        .sort((a,b)=> String(a.name||"").localeCompare(String(b.name||""), "sv"));

      const prevVal = sel.value;
      sel.innerHTML = "";

      const opt0 = document.createElement("option");
      opt0.value = "";
      opt0.textContent = companies.length ? "— Välj företag —" : "— Inga företag kopplade —";
      sel.appendChild(opt0);

      companies.forEach(c=>{
        const opt = document.createElement("option");
        opt.value = c.id;
        opt.textContent = c.name || c.id;
        sel.appendChild(opt);
      });

      sel.value = active || "";
    }

    async function setActiveCompany(companyId, opts = {}){
      const r = getRegistry();
      const id = String(companyId || "").trim() || null;
      if (id && !r.companies[id]) throw new Error("Okänt företag");

      r.activeCompanyId = id;
      if (id){
        r.companies[id].lastOpenedISO = nowISO();
      }
      saveRegistry();

      // Update header immediately to reduce risk of posting to wrong company
      try {
        const h1 = document.getElementById("companyName");
        if (h1){
          if (!id) h1.textContent = "FU-BOOKKEEPING";
          else h1.textContent = (r.companies[id] && r.companies[id].name) ? r.companies[id].name : "FU-BOOKKEEPING";
        }
      } catch {}

      // Load handles into global vars used by existing code.
      if (!id){
        fsHandle = null;
        backupDirHandle = null;
        fsLastError = null;
        fsLastSavedAt = null;
        updateCompanySelectUI();
        try { updateFsUI(); } catch {}
        try { updateBackupUI(); } catch {}
        return;
      }

      const dataH = await idbGetHandle(companyHandleKey(id, "data"));
      const backupH = await idbGetHandle(companyHandleKey(id, "backup"));
      fsHandle = dataH || null;
      backupDirHandle = backupH || null;
      fsLastError = null;
      fsLastSavedAt = null;

      updateCompanySelectUI();
      try { updateFsUI(); } catch {}
      try { updateBackupUI(); } catch {}

      if (opts.autoLoad){
        try { await opts.autoLoad(); } catch (e){ console.error(e); }
      }
    }

    async function upsertCompany(meta, handles){
      const r = getRegistry();
      const id = String(meta.id || "").trim() || companyNewId();
      const createdAt = String(meta.createdAtISO || "").trim() || nowISO();
      r.companies[id] = {
        id,
        name: String(meta.name || "").trim() || "(namnlöst företag)",
        orgnr: String(meta.orgnr || "").trim(),
        createdAtISO: createdAt,
        lastOpenedISO: String(meta.lastOpenedISO || "").trim(),
        lastBackupDate: meta.lastBackupDate ? String(meta.lastBackupDate) : null,
        colorTag: meta.colorTag ? String(meta.colorTag) : null,
      };
      saveRegistry();

      if (handles && handles.dataFileHandle) await idbSetHandle(companyHandleKey(id, "data"), handles.dataFileHandle);
      if (handles && ("backupDirHandle" in handles)){
        if (handles.backupDirHandle) await idbSetHandle(companyHandleKey(id, "backup"), handles.backupDirHandle);
        else await idbDelHandle(companyHandleKey(id, "backup"));
      }
      return id;
    }

    async function setActiveBackupDirHandle(dirHandle){
      const id = getActiveCompanyId();
      if (!id) throw new Error("Inget aktivt företag");
      backupDirHandle = dirHandle || null;
      if (backupDirHandle) await idbSetHandle(companyHandleKey(id, "backup"), backupDirHandle);
      else await idbDelHandle(companyHandleKey(id, "backup"));
      saveRegistry();
      try { updateBackupUI(); } catch {}
    }

    function updateActiveCompanyMeta(patch){
      const id = getActiveCompanyId();
      if (!id) return false;
      const r = getRegistry();
      const c = r.companies[id];
      if (!c) return false;
      Object.assign(c, patch || {});
      return saveRegistry();
    }

    async function migrateFromSingleCompanyIfNeeded(){
      const existing = companyLoadRegistry();
      if (existing) return existing;

      // Detect old single-company handles in legacy KV store.
      let oldData = null;
      let oldBackup = null;
      try { oldData = await idbGet("dataFileHandle"); } catch {}
      try { oldBackup = await idbGet("backupDirHandle"); } catch {}

      if (!oldData && !oldBackup) return null;

      const r = companyEmptyRegistry();
      const id = "c_migrated";
      const nameFromState = (state && state.company && state.company.name) ? String(state.company.name).trim() : "";
      const orgnrFromState = (state && state.company && state.company.orgnr) ? String(state.company.orgnr).trim() : "";

      // Use old global autobackup last day if present
      let lastBackupDate = null;
      try {
        const v = String(localStorage.getItem("FU_AUTOBACKUP_LAST_DAY_V1") || "").trim();
        if (v) lastBackupDate = v;
      } catch {}

      r.companies[id] = {
        id,
        name: nameFromState || "Företag 1",
        orgnr: orgnrFromState,
        createdAtISO: nowISO(),
        lastOpenedISO: nowISO(),
        lastBackupDate,
        colorTag: null,
      };
      r.activeCompanyId = id;

      companySaveRegistry(r);

      try { if (oldData) await idbSetHandle(companyHandleKey(id, "data"), oldData); } catch (e){ console.error(e); }
      try { if (oldBackup) await idbSetHandle(companyHandleKey(id, "backup"), oldBackup); } catch (e){ console.error(e); }

      // Do NOT delete old keys yet (safe-by-default). We'll mark migration complete after we have loaded once.
      return r;
    }

    async function init(){
      registry = await migrateFromSingleCompanyIfNeeded() || companyLoadRegistry() || companyEmptyRegistry();
      updateCompanySelectUI();

      const active = registry.activeCompanyId || null;
      if (!active){
        fsHandle = null;
        backupDirHandle = null;
        fsLastError = null;
        fsLastSavedAt = null;
        try { updateFsUI(); } catch {}
        try { updateBackupUI(); } catch {}
        return;
      }

      // Header indicator
      try {
        const h1 = document.getElementById("companyName");
        if (h1){
          const c = registry.companies && registry.companies[active] ? registry.companies[active] : null;
          if (c && c.name) h1.textContent = c.name;
        }
      } catch {}

      // Load handles for active company.
      try {
        fsHandle = await idbGetHandle(companyHandleKey(active, "data"));
      } catch { fsHandle = null; }
      try {
        backupDirHandle = await idbGetHandle(companyHandleKey(active, "backup"));
      } catch { backupDirHandle = null; }

      fsLastError = null;
      fsLastSavedAt = null;

      try { updateFsUI(); } catch {}
      try { updateBackupUI(); } catch {}
    }

    return {
      init,
      getRegistry,
      listCompanies,
      getActiveCompanyId,
      getCompanyMeta,
      hasActiveCompany,
      activeCompanyDisplayName,
      updateCompanySelectUI,
      setActiveCompany,
      upsertCompany,
      setActiveBackupDirHandle,
      updateActiveCompanyMeta,
    };
  })();

  function defaultData(){
    const now = new Date();
    const y = now.getFullYear();
    return {
      company: { name: "FU-BOOKKEEPING", orgnr: "", currency: "SEK", defaultSign: "", addr:"", zip:"", city:"", country:"", email:"", phone:"", web:"", vat:"", payDays:30, bankgiro:"", plusgiro:"", swishPhone:"", bankAccountNo:"", iban:"", swift:"", invoiceNote:"", invoiceFooter:"", logoDataUrl:"" },
      features: { sruEnabled: false },
      fileSync: { autosave: true, requireFile: false },
      fiscalYears: [
        { id: String(y-1), start: `${y-1}-01-01`, end: `${y-1}-12-31` },
        { id: String(y),   start: `${y}-01-01`,   end: `${y}-12-31` },
      ],
      activeYearId: String(y),
      accounts: demoAccounts(),
      vouchers: [],
      underlag: [],
      customers: {},
      suppliers: {},
      supplierInvoices: [],
      invoices: [],
      locks: {},
      compliance: { immutableVouchers: true },
      auditSeq: 0,
      auditLog: [],
      sru: { enabled: false, periodSuffix: "P4", neMappings: [] },
      bankImport: {
        batches: {},
        items: {},
        fingerprints: {},
        rules: [],
        settings: { lastSource: "bank", defaultBankAccount: "1930", defaultTaxAccount: "1630" }
      }
    };
  }

  function demoAccounts(){
    // Minimal BAS-ish set (du kan lägga fler i Kontoplan)
    return {
      "1510": { name: "Kundfordringar", type: "asset" },
      "1630": { name: "Skattekonto", type: "asset" },
      "1930": { name: "Företagskonto/bank", type: "asset" },
      "1460": { name: "Varulager", type: "asset" },
      "2013": { name: "Eget uttag", type: "liability" },
      "2019": { name: "Årets resultat", type: "liability" },
      "2611": { name: "Utgående moms 25 %", type: "liability" },
      "3001": { name: "Försäljning varor 25 %", type: "income" },
      "4960": { name: "Förändring av lager", type: "expense" },
      "8999": { name: "Årets resultat (resultatkonto)", type: "other" }
    };
      
  }

  function load(){
    let raw = "";
    try {
      raw = localStorage.getItem(STORAGE_KEY) || "";
      localStorageOk = true;
    } catch (e){
      console.error(e);
      localStorageOk = false;
      return defaultData();
    }
    if (!raw) return defaultData();
    try {
      const d = JSON.parse(raw);
      // very light migration defaults
      if (!d.company) d.company = defaultData().company;
            // company invoice defaults
      const cdef = defaultData().company;
      d.company = d.company || {};
      for (const k of Object.keys(cdef)) if (d.company[k] == null) d.company[k] = cdef[k];
if (!d.features) d.features = { sruEnabled: false };
      if (typeof d.features.sruEnabled !== "boolean") d.features.sruEnabled = false;
      if (!d.fileSync) d.fileSync = { autosave: true, requireFile: false };
      if (typeof d.fileSync.requireFile !== "boolean") d.fileSync.requireFile = false;
      if (!d.fiscalYears) d.fiscalYears = defaultData().fiscalYears;
      if (!d.accounts) d.accounts = demoAccounts();
      if (!d.vouchers) d.vouchers = [];
      if (!d.customers) d.customers = {};
      if (!d.suppliers) d.suppliers = {};
      if (!d.supplierInvoices) d.supplierInvoices = [];
      if (!d.invoices) d.invoices = [];
      
      
      if (!d.locks || typeof d.locks !== "object") d.locks = {};
      if (!d.compliance) d.compliance = { immutableVouchers: true };
      if (!d.auditLog) d.auditLog = [];
      if (!d.sru) d.sru = { enabled:false, periodSuffix:"P4", neMappings: [] };
      if (typeof d.sru.enabled !== "boolean") d.sru.enabled = false;
      if (!d.sru.periodSuffix) d.sru.periodSuffix = "P4";
      if (!Array.isArray(d.sru.neMappings)) d.sru.neMappings = [];
      if (!d.activeYearId) d.activeYearId = d.fiscalYears[0]?.id ?? String(new Date().getFullYear());
      return d;
    } catch {
      return defaultData();
    }
  }
  function save(opts){
    const doRenderAll = !opts || opts.renderAll !== false;
    const isQuotaError = (e) => {
      const name = e && e.name ? String(e.name) : "";
      const msg = e && e.message ? String(e.message) : "";
      return name === "QuotaExceededError" || /quota/i.test(msg) || e?.code === 22 || e?.code === 1014;
    };

    const pruneForStorage = () => {
      // Keep this conservative: drop large/diagnostic fields first.
      let changed = false;
      try {
        const bi = state?.bankImport;
        const items = bi?.items || {};
        Object.values(items).forEach((it)=>{
          if (!it || typeof it !== "object") return;
          if (it.raw != null){ it.raw = null; changed = true; }
        });
      } catch {}
      return changed;
    };

    let persisted = false;
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      persisted = true;
    } catch (e){
      console.error(e);

      localStorageOk = false;

      // If state is too large, the most common culprit is an embedded logo.
      if (isQuotaError(e) && state?.company?.logoDataUrl){
        const prev = state.company.logoDataUrl;
        try {
          state.company.logoDataUrl = "";
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
          persisted = true;
          showToast("Kunde inte spara p.g.a. lagringsutrymme. Logotypen var troligen för stor och togs bort – försök med en mindre bild.", 8000);
        } catch (e2){
          console.error(e2);
          state.company.logoDataUrl = prev;
          // Try one more pass by pruning large optional fields (e.g. bankimport raw rows)
          try {
            if (pruneForStorage()){
              localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
              persisted = true;
              showToast("Kunde inte spara p.g.a. lagringsutrymme. Rensade rådata från importerade bankrader för att få plats.", 9000);
            } else {
              showToast("Kunde inte spara data till webbläsarens lagring. Se konsolen för detaljer.", 8000);
            }
          } catch (e3){
            console.error(e3);
            showToast("Kunde inte spara data till webbläsarens lagring. Se konsolen för detaljer.", 8000);
          }
        }
      } else {
        // If quota is hit without a logo, bank import raw rows is a common culprit.
        if (isQuotaError(e)){
          try {
            if (pruneForStorage()){
              localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
              persisted = true;
              showToast("Kunde inte spara p.g.a. lagringsutrymme. Rensade rådata från importerade bankrader för att få plats.", 9000);
            } else {
              showToast("Kunde inte spara data till webbläsarens lagring. Se konsolen för detaljer.", 8000);
            }
          } catch (e2){
            console.error(e2);
            showToast("Kunde inte spara data till webbläsarens lagring. Se konsolen för detaljer.", 8000);
          }
        } else {
          showToast("Kunde inte spara data till webbläsarens lagring. Se konsolen för detaljer.", 8000);
        }
      }
    }

    if (persisted) localStorageOk = true;

    if (doRenderAll){
      try { renderAll(); } catch (e){ console.error(e); }
    }
    try { scheduleFileAutosave(); } catch (e){ console.error(e); }
    return persisted;
  }


  // När användaren väljer en NY datafil ska inget gammalt ligga kvar lokalt och riskera att blandas ihop.
  // Detta körs automatiskt innan filen laddas/ansluts.
  async function wipeLocalDataForNewDataFile(){
    try { localStorage.removeItem(STORAGE_KEY); } catch (e){ /* ignore */ }
    // Reset in-memory state (UI kommer ändå att uppdateras av fil-inläsningen)
    try { state = defaultData(); } catch (e){ /* ignore */ }

    // OBS: I multi-company-läge ska vi INTE rensa IndexedDB här.
    // Den kan innehålla bilagor/underlag samt handles för flera företag.

    // Spara ett rent state (om localStorage är aktivt) så UI inte visar gammal data innan fil laddas
    try { save(); } catch (e){ /* ignore */ }
  }

  // --- Fil-synk (Drive-synkad mapp) ---
  // OBS: Om hela UI:t "dör" beror det nästan alltid på att scriptet inte kan parsas
  // (SyntaxError). Den här sektionen är avsiktligt skriven utan dubletter/konstiga block.

  function fsApiSupported(){
    return !!(window.showOpenFilePicker && window.showSaveFilePicker && window.isSecureContext);
  }

  function getActiveCompanyHandles(){
    return { dataFileHandle: fsHandle, backupDirHandle };
  }

  function setFsStatus(kind, text){
    if (!fsStatus) return;
    fsStatus.className = "status " + (kind === "ok" ? "ok" : "bad");
    fsStatus.textContent = text;
  }

  function setEditingLocked(locked){
    // Lock core editing actions if user requires a file but none is connected.
    const ids = [
      "btnNewVoucher","btnAddLine","btnClearVoucher","btnSaveVoucher",
      "btnAddAccount",
      "btnAddYear","btnCarry",
      "btnWipe",
      "btnBankImportOpen","btnBankImportOpen2","btnBankInboxRefresh",
      "btnBankImportRun","btnBankPostCreate","btnBankBulkConfirm",
      "btnInvNew","btnInvSave","btnInvPickCustomer","btnInvAddItem","btnInvAddComment","btnInvClear","btnInvToVoucher",
      "btnSupNew","btnSupSave","btnSiNew","btnSiSave","btnSiToVoucher","btnCustomerSave",
      "btnImportSie","btnExportSie4"
    ];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = !!locked;
    });

    // Disable important fields
    const fields = ["vDate","vSeries","vNo","vText","vSign","aNo","aName","aType","fyStart","fyEnd"]; 
    fields.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = !!locked;
    });

  }

  function updateFsUI(){
    if (!fsStatus) return;

    // Header storage indicator (reacts to file connection)
    if (storagePill){
      const supported = fsApiSupported();
      const hasCompany = CompanyManager.hasActiveCompany();
      const connected = hasCompany && !!fsHandle;

      if (!hasCompany){
        storagePill.textContent = "Lagring: inget företag";
        setPillState(storagePill, "bad");
      } else if (supported && connected){
        const name = fsHandle && fsHandle.name ? fsHandle.name : "datafil";
        const cn = CompanyManager.activeCompanyDisplayName() || "Företag";
        storagePill.textContent = `Lagring: ${cn} · datafil (${name})`;
        setPillState(storagePill, fsLastError ? "bad" : "ok");
      } else {
        storagePill.textContent = localStorageOk ? "Lagring: localStorage (offline)" : "Lagring: localStorage blockerad";
        // Offline storage is considered an error state in this app.
        setPillState(storagePill, "bad");
      }
    }

    // checkboxes
    if (fsAutosave){
      fsAutosave.checked = !!(state.fileSync && state.fileSync.autosave);
      fsAutosave.disabled = !fsApiSupported();
    }
    if (fsRequireFile){
      fsRequireFile.checked = !!(state.fileSync && state.fileSync.requireFile);
      // Important: never disable this checkbox.
      // Otherwise users can get locked out (buttons disabled) when opening the app in
      // a context where the File System Access API isn't available (e.g. file://).
      fsRequireFile.disabled = false;
    }

    const hasCompany = CompanyManager.hasActiveCompany();
    const connected = hasCompany && !!fsHandle;
    if (btnLoadFromFile) btnLoadFromFile.disabled = !connected;
    if (btnSaveToFile) btnSaveToFile.disabled = !connected;
    if (btnDisconnectFile) btnDisconnectFile.disabled = !hasCompany;

    const requireFile = !!(state.fileSync && state.fileSync.requireFile);

    if (!fsApiSupported()){
      setFsStatus("bad", requireFile ? "Kräver HTTPS/localhost + Chrome/Edge (fil krävs)" : "Kräver HTTPS/localhost + Chrome/Edge");
      setEditingLocked(true);
      return;
    }

    if (!hasCompany){
      setFsStatus("bad", "Inget företag valt");
      setEditingLocked(true);
      return;
    }

    if (!connected){
      setFsStatus("bad", requireFile ? "Inte ansluten · kräver datafil" : "Inte ansluten");
      setEditingLocked(true);
      return;
    }

    const name = fsHandle && fsHandle.name ? fsHandle.name : "(fil)";
    if (fsLastError){
      setFsStatus("bad", `${name} · fel`);
    } else if (fsLastSavedAt){
      setFsStatus("ok", `${name} · sparad ${fsLastSavedAt}`);
    } else {
      setFsStatus("ok", `${name} · ansluten`);
    }

    setEditingLocked(false);
  }

  async function fsEnsurePermission(request){
    if (!fsHandle) return false;
    const opts = { mode: "readwrite" };
    try {
      const q = await fsHandle.queryPermission(opts);
      if (q === "granted") return true;
      if (!request) return false;
      const r = await fsHandle.requestPermission(opts);
      return r === "granted";
    } catch (e){
      fsLastError = e;
      updateFsUI();
      return false;
    }
  }

  async function fsWriteState(){
    if (!fsHandle) throw new Error("Ingen fil ansluten");
    const ok = await fsEnsurePermission(false);
    if (!ok) throw new Error("Ingen behörighet (klicka 'Spara nu' för att tillåta)");

    const writable = await fsHandle.createWritable();
    await writable.write(JSON.stringify(state, null, 2));
    await writable.close();

    fsLastSavedAt = new Date().toLocaleString("sv-SE", { hour12:false });
    fsLastError = null;
    updateFsUI();
  }

  async function fsLoadState(){
    if (!fsHandle) throw new Error("Ingen fil ansluten");
    const ok = await fsEnsurePermission(true);
    if (!ok) throw new Error("Behörighet nekad");

    const file = await fsHandle.getFile();
    const txt = await file.text();
    if (!txt.trim()) throw new Error("Filen är tom");

    const d = JSON.parse(txt);
    if (!d || typeof d !== "object" || !Array.isArray(d.fiscalYears) || !d.accounts || !Array.isArray(d.vouchers)){
      throw new Error("Filen ser inte ut som en backup från appen");
    }

    state = d;
    // migration defaults
    if (!state.company) state.company = defaultData().company;
    { const cdef = defaultData().company; state.company = state.company || {}; for (const k of Object.keys(cdef)) if (state.company[k] == null) state.company[k] = cdef[k]; }
    if (!state.features) state.features = { sruEnabled: false };
    if (typeof state.features.sruEnabled !== "boolean") state.features.sruEnabled = false;
    if (!state.fileSync) state.fileSync = { autosave: true, requireFile: false };
    if (typeof state.fileSync.requireFile !== "boolean") state.fileSync.requireFile = false;

    // Auto-repair corrupted kontonamn via standardlista (utan SIE)
    try { if (typeof applyStdAccountsMapRepair === "function") applyStdAccountsMapRepair({ onlyReplacement: true }); } catch (e){ console.error(e); }

    save();
    try { updateBackupUI(); } catch (e){}
    try { await maybeDailyAutoBackup("fsLoadState"); } catch (e){}

    // Mark migration complete after a successful load
    try {
      if (CompanyManager.getActiveCompanyId && CompanyManager.getActiveCompanyId() === "c_migrated"){
        if (!localStorage.getItem(COMPANY_REGISTRY_MIGRATED_FLAG)){
          localStorage.setItem(COMPANY_REGISTRY_MIGRATED_FLAG, "true");
        }
      }
    } catch {}
  }

  async function maybeSilentAutosaveToFile(reason){
    try {
      if (!fsApiSupported()) return false;
      if (!fsHandle) return false;
      if (!state.fileSync || !state.fileSync.autosave) return false;
      const ok = await fsEnsurePermission(false);
      if (!ok) return false;
      await fsWriteState();
      console.info("[Company] silent autosave ok", reason || "");
      return true;
    } catch (e){
      console.warn("[Company] silent autosave failed", reason || "", e);
      return false;
    }
  }

  async function fsDisconnect(){
    // Best-effort silent autosave before disconnect (no prompts)
    try { await maybeSilentAutosaveToFile("disconnect"); } catch {}

    fsHandle = null;
    fsLastError = null;
    fsLastSavedAt = null;
    backupDirHandle = null;
    try { await CompanyManager.setActiveCompany(null); } catch {}
    updateFsUI();
    try { updateBackupUI(); } catch {}
  }

  async function fsConnectExisting(){
    if (!fsApiSupported()) return showToast("Fil-synk kräver Chrome/Edge och secure context (HTTPS eller localhost).", 6500);
    try {
      const picked = await window.showOpenFilePicker({
        multiple: false,
        types: [{ description: "Bokföringsdata (JSON)", accept: { "application/json": [".json"] } }]
      });
      const handle = picked && picked[0] ? picked[0] : null;
      if (!handle) return;

      // Create registry entry for this company (separate handle store)
      let preName = "";
      let preOrgnr = "";
      let looksValid = true;
      try {
        const f = await handle.getFile();
        const txt = await f.text();
        const d = JSON.parse(txt);
        looksValid = !!(d && typeof d === "object" && Array.isArray(d.fiscalYears) && d.accounts && typeof d.accounts === "object" && Array.isArray(d.vouchers));
        preName = d && d.company && d.company.name ? String(d.company.name).trim() : "";
        preOrgnr = d && d.company && d.company.orgnr ? String(d.company.orgnr).trim() : "";
      } catch {}

      if (!looksValid){
        showToast("Filen ser inte ut som FU-Bookkeeping-data (fel format).", 6500);
        return;
      }

      const name = await promptAsync("Företagsnamn", { defaultValue: preName || "Företag" , placeholder:"Innovatio AB" });
      if (name == null) return;
      const orgnr = await promptAsync("Org.nr (valfritt)", { defaultValue: preOrgnr || "", placeholder:"770314-3516" });
      if (orgnr == null) return;

      const newId = await CompanyManager.upsertCompany({
        id: companyNewId(),
        name: String(name||"").trim() || "Företag",
        orgnr: String(orgnr||"").trim(),
        createdAtISO: nowISO(),
        lastOpenedISO: nowISO(),
        lastBackupDate: null,
        colorTag: null,
      }, { dataFileHandle: handle, backupDirHandle: null });

      await CompanyManager.setActiveCompany(newId);

      // Clear local state to avoid mixing companies if load fails
      try { await wipeLocalDataForNewDataFile(); } catch {}

      // Ask permission now (user click), and auto-load immediately
      try {
        await fsLoadState();
        showToast("Företag kopplat · laddade data från fil.", 3000);
      } catch (err){
        console.error(err);
        showToast("Företag kopplat · men kunde inte läsa filen (tom/ogiltig).", 6500);
      }

      updateFsUI();
    } catch (e){
      if (e && e.name === "AbortError") return;
      fsLastError = e;
      updateFsUI();
      showToast("Kunde inte välja fil. Är du på HTTPS/localhost och i Chrome/Edge?", 6500);
    }
  }

  async function fsCreateNew(){
    if (!fsApiSupported()) return showToast("Fil-synk kräver Chrome/Edge och secure context (HTTPS eller localhost).", 6500);
    try {
      const name = await promptAsync("Företagsnamn", { placeholder:"Innovatio AB" });
      if (name == null) return;
      const orgnr = await promptAsync("Org.nr (valfritt)", { placeholder:"770314-3516" });
      if (orgnr == null) return;

      const slug = safeFilename(name);
      const suggested = `${todayISO()}_${slug}_fu.json`;

      const handle = await window.showSaveFilePicker({
        suggestedName: suggested,
        types: [{ description: "Bokföringsdata (JSON)", accept: { "application/json": [".json"] } }]
      });
      if (!handle) return;

      // Prepare fresh state for the new company
      state = defaultData();
      state.company = state.company || defaultData().company;
      state.company.name = String(name||"").trim();
      state.company.orgnr = String(orgnr||"").trim();
      try { if (companyNameEl) companyNameEl.textContent = state.company.name || "FU-BOOKKEEPING"; } catch {}
      save();

      const id = await CompanyManager.upsertCompany({
        id: companyNewId(),
        name: String(name||"").trim() || "Företag",
        orgnr: String(orgnr||"").trim(),
        createdAtISO: nowISO(),
        lastOpenedISO: nowISO(),
        lastBackupDate: null,
        colorTag: null,
      }, { dataFileHandle: handle, backupDirHandle: null });

      await CompanyManager.setActiveCompany(id);

      // write initial
      try {
        const ok = await fsEnsurePermission(true);
        if (ok){
          await fsWriteState();
          showToast("Företag skapat · sparade första versionen.", 3000);
        }
      } catch (e){
        console.error(e);
        showToast("Företag skapat · men kunde inte skriva filen.", 6500);
      }

      // Ask for backup folder (recommended)
      try {
        const yes = await confirmAsync("Vill du välja en backup-mapp för detta företag nu? (Rekommenderas)");
        if (yes) await chooseBackupFolder();
      } catch {}

      updateFsUI();
    } catch (e){
      if (e && e.name === "AbortError") return;
      fsLastError = e;
      updateFsUI();
      showToast("Kunde inte skapa fil. Är du på HTTPS/localhost och i Chrome/Edge?", 6500);
    }
  }

  function scheduleFileAutosave(){
    if (!fsApiSupported()) return;
    if (!fsHandle) return;
    if (!state.fileSync || !state.fileSync.autosave) return;

    if (fsAutosaveTimer) clearTimeout(fsAutosaveTimer);
    fsAutosaveTimer = setTimeout(async ()=>{
      try {
        // Only autosave if permission is already granted (no prompts without click)
        const ok = await fsEnsurePermission(false);
        if (!ok) return;
        await fsWriteState();
      } catch (e){
        fsLastError = e;
        updateFsUI();
      }
    }, 600);
  }

  // --- State ---
  let state = normalizeImportedState(load());
  let editingVoucherId = null;
  let correctionOfId = null;
  let draftVoucherId = crypto.randomUUID();

  // File sync handle (stored in IndexedDB, not in state)
  let fsHandle = null;
  let fsLastSavedAt = null;
  let fsLastError = null;
  let fsAutosaveTimer = null;

  // --- DOM ---
  const tabs = Array.from(document.querySelectorAll(".tab[data-tab]"));
  const sections = {
    vouchers: document.getElementById("tab-vouchers"),
    accounts: document.getElementById("tab-accounts"),
    reports: document.getElementById("tab-reports"),
    bank_inbox: document.getElementById("tab-bank_inbox"),
    customers: document.getElementById("tab-customers"),
    suppliers: document.getElementById("tab-suppliers"),
    supplier_invoices: document.getElementById("tab-supplier_invoices"),
    invoices: document.getElementById("tab-invoices"),
    export: document.getElementById("tab-export"),
    settings: document.getElementById("tab-settings"),
    sru: document.getElementById("tab-sru"),
  };

  const companyNameEl = document.getElementById("companyName");
  const companySelect = document.getElementById("companySelect");
  const yearPillSelect = document.getElementById("yearPillSelect");
  const storagePill = document.getElementById("storagePill");

  const yearSelect = document.getElementById("yearSelect");
  const voucherList = document.getElementById("voucherList");

  const vDate = document.getElementById("vDate");
  const vSeries = document.getElementById("vSeries");
  const vNo = document.getElementById("vNo");
  const vText = document.getElementById("vText");
  const vSign = document.getElementById("vSign");
  const linesTbody = document.getElementById("linesTbody");
  const balanceBadge = document.getElementById("balanceBadge");
  const btnFillExample = document.getElementById("btnFillExample");
  const btnNewVoucher = document.getElementById("btnNewVoucher");
  const btnAddLine = document.getElementById("btnAddLine");
  const btnClearVoucher = document.getElementById("btnClearVoucher");
  const btnSaveVoucher = document.getElementById("btnSaveVoucher");
  const btnRefresh = document.getElementById("btnRefresh");

  const uType = document.getElementById("uType");
  const uRef = document.getElementById("uRef");
  const uNote = document.getElementById("uNote");
  const uFiles = document.getElementById("uFiles");
  const uList = document.getElementById("uList");

  const aNo = document.getElementById("aNo");
  const aName = document.getElementById("aName");
  const aType = document.getElementById("aType");
  const accountsTbody = document.getElementById("accountsTbody");
  const accountSearch = document.getElementById("accountSearch");
  const btnAddAccount = document.getElementById("btnAddAccount");
  const btnResetDemo = document.getElementById("btnResetDemo");
  const btnExportAccountNameTemplate = document.getElementById("btnExportAccountNameTemplate");
  const stdAccountsFile = document.getElementById("stdAccountsFile");
  // Reports (Rapportgenerator)
  const rptYearSelect = document.getElementById("rptYearSelect");
  const rptFrom = document.getElementById("rptFrom");
  const rptTo = document.getElementById("rptTo");
  const rptType = document.getElementById("rptType");
  const btnRptGenerate = document.getElementById("btnRptGenerate");
  const btnRptPrint = document.getElementById("btnRptPrint");
  const btnRptCsv = document.getElementById("btnRptCsv");
  const btnRptXls = document.getElementById("btnRptXls");
  const reportOutput = document.getElementById("reportOutput");
  const btnRptFullYear = document.getElementById("btnRptFullYear");
  const btnRptThisMonth = document.getElementById("btnRptThisMonth");
  const btnRptThisQuarter = document.getElementById("btnRptThisQuarter");

  // Last generated report (HTML fragment)
  let lastReportHtml = "";
  let lastReportTitle = "";

  // SIE export/import
  const sieYearSelect = document.getElementById("sieYearSelect");
  const sieImportFile = document.getElementById("sieImportFile");
  const btnImportSie = document.getElementById("btnImportSie");
  const sieImportEncoding = document.getElementById("sieImportEncoding");
  const sieImportWipe = document.getElementById("sieImportWipe");
  const sieImportParallel = document.getElementById("sieImportParallel");

  
  const sieImportFileName = document.getElementById("sieImportFileName");
// File sync (Drive-synkad mapp via File System Access API)
  const btnConnectFile = document.getElementById("btnConnectFile");
  const btnCreateFile = document.getElementById("btnCreateFile");
  const btnLoadFromFile = document.getElementById("btnLoadFromFile");
  const btnSaveToFile = document.getElementById("btnSaveToFile");
  const btnDisconnectFile = document.getElementById("btnDisconnectFile");
  const fsAutosave = document.getElementById("fsAutosave");
  const fsRequireFile = document.getElementById("fsRequireFile");
  const fsStatus = document.getElementById("fsStatus");

  // Settings
  const sCompany = document.getElementById("sCompany");
  const sOrgnr = document.getElementById("sOrgnr");
  const sCurrency = document.getElementById("sCurrency");
  const sSign = document.getElementById("sSign");
  const sAddr = document.getElementById("sAddr");
  const sZip = document.getElementById("sZip");
  const sCity = document.getElementById("sCity");
  const sCountry = document.getElementById("sCountry");
  const sEmail = document.getElementById("sEmail");
  const sPhone = document.getElementById("sPhone");
  const sWeb = document.getElementById("sWeb");
  const sVat = document.getElementById("sVat");
  const sPayDays = document.getElementById("sPayDays");
  const sBg = document.getElementById("sBg");
  const sPg = document.getElementById("sPg");
  const sSwish = document.getElementById("sSwish");
  const sBankAccount = document.getElementById("sBankAccount");
  const sIban = document.getElementById("sIban");
  const sSwift = document.getElementById("sSwift");
  const sInvNote = document.getElementById("sInvNote");
  const sInvFooter = document.getElementById("sInvFooter");
  const sSruEnabled = document.getElementById("sSruEnabled");
  const btnSaveSettings = document.getElementById("btnSaveSettings");
  const sLogo = document.getElementById("sLogo");
  const btnRemoveLogo = document.getElementById("btnRemoveLogo");
  const logoPreview = document.getElementById("logoPreview");

  function renderLogoPreview(){
    if (!logoPreview) return;
    const url = state && state.company && state.company.logoDataUrl ? String(state.company.logoDataUrl) : "";
    if (!url){
      logoPreview.textContent = "Ingen logotyp vald.";
      return;
    }
    logoPreview.innerHTML = `<img src="${escapeAttr(url)}" alt="Logotyp" style="max-height:64px; max-width:240px; display:block;" />`;
  }

  function saveSettings(){
    state.company = state.company || defaultData().company;
    state.features = state.features || { sruEnabled: false };

    const payDays = parseInt(String(sPayDays?.value || "").trim(), 10);

    state.company.name = (sCompany?.value || "").trim();
    state.company.orgnr = (sOrgnr?.value || "").trim();
    state.company.currency = (sCurrency?.value || "SEK").trim() || "SEK";
    state.company.defaultSign = (sSign?.value || "").trim();

    state.company.addr = (sAddr?.value || "").trim();
    state.company.zip = (sZip?.value || "").trim();
    state.company.city = (sCity?.value || "").trim();
    state.company.country = (sCountry?.value || "").trim();

    state.company.email = (sEmail?.value || "").trim();
    state.company.phone = (sPhone?.value || "").trim();
    state.company.web = (sWeb?.value || "").trim();
    state.company.vat = (sVat?.value || "").trim();
    state.company.payDays = Number.isFinite(payDays) && payDays > 0 ? payDays : 30;

    state.company.bankgiro = (sBg?.value || "").trim();
    state.company.plusgiro = (sPg?.value || "").trim();
    state.company.swishPhone = (sSwish?.value || "").trim();
    state.company.bankAccountNo = (sBankAccount?.value || "").trim();
    state.company.iban = (sIban?.value || "").trim();
    state.company.swift = (sSwift?.value || "").trim();

    state.company.invoiceNote = (sInvNote?.value || "").trim();
    state.company.invoiceFooter = (sInvFooter?.value || "").trim();

    state.features.sruEnabled = !!(sSruEnabled && sSruEnabled.checked);

    if (companyNameEl) companyNameEl.textContent = state.company.name || "FU-BOOKKEEPING";
    const ok = save();
    if (ok) showToast("Dina inställningar är sparade");
  }

  const fyStart = document.getElementById("fyStart");
  const fyEnd = document.getElementById("fyEnd");
  const yearsTbody = document.getElementById("yearsTbody");

  // SRU tab
  const sruLockedBox = document.getElementById("sruLockedBox");
  const sruStatusText = document.getElementById("sruStatusText");
  const btnSruExport = document.getElementById("btnSruExport");
  const carryFrom = document.getElementById("carryFrom");
  const carryTo = document.getElementById("carryTo");

  // Period lock
  const lockYear = document.getElementById("lockYear");
  const lockUntil = document.getElementById("lockUntil");
  const btnSetLock = document.getElementById("btnSetLock");
  const btnClearLock = document.getElementById("btnClearLock");


  // --- Tab logic (single delegated handler; avoids overlay/propagation edge-cases) ---
  const sidebar = document.querySelector(".sidebar");

  // --- Grouped sidebar (fly-out + accordion on mobile) ---
  const navGroups = Array.from(document.querySelectorAll(".sidebar .navGroup"));

  function closeAllNavGroups(exceptEl){
    navGroups.forEach(g=>{
      if (exceptEl && g === exceptEl) return;
      g.classList.remove("open");
      const b = g.querySelector(".navGroupBtn");
      if (b) b.setAttribute("aria-expanded","false");
    });
  }

  function openNavGroup(groupEl){
    if (!groupEl) return;
    closeAllNavGroups(groupEl);
    groupEl.classList.add("open");
    const b = groupEl.querySelector(".navGroupBtn");
    if (b) b.setAttribute("aria-expanded","true");
  }

  function _escapeSel(s){
    try { return (window.CSS && CSS.escape) ? CSS.escape(String(s)) : String(s).replace(/"/g, '\\"'); }
    catch(e){ return String(s).replace(/"/g, '\\"'); }
  }

  function openGroupForTab(tabKey){
    if (!tabKey) return;
    const key = _escapeSel(tabKey);
    const btn = document.querySelector(`.sidebar button.tab[data-tab="${key}"]`);
    const group = btn ? btn.closest(".navGroup") : null;
    if (group) openNavGroup(group);
  }

  function setActiveGroupIndicator(tabKey){
    // Marks the group that contains the active tab (without keeping the flyout open)
    navGroups.forEach(g=>g.classList.remove("hasActive"));
    if (!tabKey) return;
    const key = _escapeSel(tabKey);
    const btn = document.querySelector(`.sidebar button.tab[data-tab="${key}"]`);
    const group = btn ? btn.closest(".navGroup") : null;
    if (group) group.classList.add("hasActive");
  }


  (function initGroupedNav(){
    if (!sidebar || !navGroups.length) return;

    // Group toggle buttons
    navGroups.forEach(g=>{
      const gb = g.querySelector(".navGroupBtn");
      if (!gb) return;

      gb.addEventListener("click", (e)=>{
        e.preventDefault();
        const isOpen = g.classList.contains("open");
        if (isOpen) closeAllNavGroups();
        else openNavGroup(g);
      });
    });

    // Click outside closes any open flyouts
    document.addEventListener("click", (e)=>{
      if (!sidebar.contains(e.target)){
        closeAllNavGroups();
      }
    });

    // Mark active group on first load (but keep flyouts closed)
    const activeBtn = sidebar.querySelector("button.tab.active[data-tab]");
    if (activeBtn && activeBtn.dataset && activeBtn.dataset.tab){
      setActiveGroupIndicator(activeBtn.dataset.tab);
    } else if (navGroups[0]){
      navGroups[0].classList.add("hasActive");
    }
    closeAllNavGroups();
  })();


  function setActiveYear(yearId){
    const yid = (yearId || "").trim();
    if (!yid) return;
    state.activeYearId = yid;
    save();
    try { fillYearSelectors(); } catch (e){ console.error(e); }
    try { if (typeof renderVouchers === "function") renderVouchers(); } catch (e){ console.error(e); }
    try { if (typeof renderInvoices === "function") renderInvoices(); } catch (e){ console.error(e); }
  }

  function safeUiCall(fn){
    try { if (typeof fn === "function") fn(); }
    catch (err) { console.error(err); }
  }


  // --- UI sync helpers ---
  function applyCompanyBranding(){
    try {
      if (!state.company) state.company = defaultData().company;
      if (companyNameEl) companyNameEl.textContent = state.company.name || "FU-BOOKKEEPING";
    } catch (e){ /* ignore */ }
  }

  function renderSettings(){
    // Populate settings form from current state (prevents "blank settings" from overwriting data)
    try { if (!state.company) state.company = defaultData().company; } catch {}
    const c = state.company || {};

    if (sCompany) sCompany.value = c.name || "";
    if (sOrgnr) sOrgnr.value = c.orgnr || "";
    if (sCurrency) sCurrency.value = c.currency || "SEK";
    if (sSign) sSign.value = c.defaultSign || "";

    if (sAddr) sAddr.value = c.addr || "";
    if (sZip) sZip.value = c.zip || "";
    if (sCity) sCity.value = c.city || "";
    if (sCountry) sCountry.value = c.country || "";

    if (sEmail) sEmail.value = c.email || "";
    if (sPhone) sPhone.value = c.phone || "";
    if (sWeb) sWeb.value = c.web || "";
    if (sVat) sVat.value = c.vat || "";
    if (sPayDays) sPayDays.value = String((c.payDays ?? 30));

    if (sBg) sBg.value = c.bankgiro || "";
    if (sPg) sPg.value = c.plusgiro || "";
    if (sSwish) sSwish.value = c.swishPhone || "";
    if (sBankAccount) sBankAccount.value = c.bankAccountNo || "";
    if (sIban) sIban.value = c.iban || "";
    if (sSwift) sSwift.value = c.swift || "";

    if (sInvNote) sInvNote.value = c.invoiceNote || "";
    if (sInvFooter) sInvFooter.value = c.invoiceFooter || "";

    if (sSruEnabled) sSruEnabled.checked = !!(state.features && state.features.sruEnabled);

    // File sync controls reflect state
    if (fsAutosave){
      fsAutosave.checked = !!(state.fileSync && state.fileSync.autosave);
      fsAutosave.disabled = !fsApiSupported();
    }
    if (fsRequireFile){
      fsRequireFile.checked = !!(state.fileSync && state.fileSync.requireFile);
      fsRequireFile.disabled = false;
    }

    try { renderLogoPreview(); } catch (e){ console.error(e); }
    applyCompanyBranding();
    try { updateFsUI(); } catch (e){ /* ignore */ }
  }

  function renderAll(){
    // Safe "refresh everything" used by save(), imports and file reloads.
    applyCompanyBranding();
    safeUiCall(typeof fillYearSelectors === "function" ? fillYearSelectors : null);
    safeUiCall(typeof renderVouchers === "function" ? renderVouchers : null);

    // These are heavier; keep safe and optional
    safeUiCall(typeof renderAccounts === "function" ? renderAccounts : null);
    safeUiCall(typeof renderCustomers === "function" ? renderCustomers : null);
    safeUiCall(typeof renderSuppliers === "function" ? renderSuppliers : null);
    safeUiCall(typeof renderSupplierInvoices === "function" ? renderSupplierInvoices : null);
    safeUiCall(typeof renderInvoices === "function" ? renderInvoices : null);

    // Only hydrate settings fields if Settings tab is currently visible (avoid overriding user typing)
    try { if (sections && sections.settings && !sections.settings.hidden) renderSettings(); } catch {}
    try { updateFsUI(); } catch {}
  }

  function activateTab(tabKey){
    if (!tabKey) return;

    tabs.forEach(b => { b.classList.remove("active"); b.removeAttribute("aria-current"); });
    const btn = tabs.find(b => (b.dataset && b.dataset.tab) === tabKey);
    if (btn){ btn.classList.add("active"); btn.setAttribute("aria-current","page"); }

    // Mark the correct group as active, but close any open flyouts so they don't cover content
    try { if (typeof setActiveGroupIndicator === "function") setActiveGroupIndicator(tabKey); } catch(e){}
    try { if (typeof closeAllNavGroups === "function") closeAllNavGroups(); } catch(e){}

    Object.entries(sections).forEach(([k, el]) => {
      if (el) el.hidden = (k !== tabKey);
    });

    // Lazy renders
    if (tabKey === "reports") safeUiCall(typeof renderReports === "function" ? renderReports : null);
    if (tabKey === "bank_inbox") safeUiCall(typeof BankImportModule !== "undefined" && BankImportModule && typeof BankImportModule.renderInbox === "function" ? BankImportModule.renderInbox : null);
    if (tabKey === "accounts") safeUiCall(typeof renderAccounts === "function" ? renderAccounts : null);
    if (tabKey === "invoices") safeUiCall(typeof renderInvoices === "function" ? renderInvoices : null);
    if (tabKey === "customers") safeUiCall(typeof renderCustomers === "function" ? renderCustomers : null);
    if (tabKey === "suppliers") safeUiCall(typeof renderSuppliers === "function" ? renderSuppliers : null);
    if (tabKey === "supplier_invoices") safeUiCall(typeof renderSupplierInvoices === "function" ? renderSupplierInvoices : null);
    if (tabKey === "settings") safeUiCall(typeof renderSettings === "function" ? renderSettings : null);
  }

  if (sidebar){
    sidebar.addEventListener("click", (e)=>{
      const btn = e.target && e.target.closest ? e.target.closest("button.tab[data-tab]") : null;
      if (!btn) return;
      e.preventDefault();
      activateTab(btn.dataset.tab);
    });

    // Keyboard (Enter/Space) on focused tab buttons
    sidebar.addEventListener("keydown", (e)=>{
      if (e.key !== "Enter" && e.key !== " ") return;
      const btn = e.target && e.target.closest ? e.target.closest("button.tab[data-tab]") : null;
      if (!btn) return;
      e.preventDefault();
      activateTab(btn.dataset.tab);
    });
  }

  // Global fallbacks: if any overlay/grid bug blocks clicks on tabs, still switch.
  document.addEventListener("click", (e)=>{
    const el = e.target && e.target.closest ? e.target.closest(".tab[data-tab]") : null;
    if (!el) return;
    e.preventDefault();
    activateTab(el.dataset.tab);
  }, true);

  document.addEventListener("pointerdown", (e)=>{
    if (!document.elementsFromPoint) return;
    const els = document.elementsFromPoint(e.clientX, e.clientY) || [];
    const btn = els.find(x => x && x.classList && x.classList.contains("tab") && x.dataset && x.dataset.tab);
    if (!btn) return;
    e.preventDefault();
    e.stopPropagation();
    activateTab(btn.dataset.tab);
  }, true);

  document.addEventListener("keydown", (e)=>{
    if (e.key !== "Enter" && e.key !== " ") return;
    const el = document.activeElement;
    const btn = el && el.closest ? el.closest(".tab[data-tab]") : null;
    if (!btn) return;
    e.preventDefault();
    activateTab(btn.dataset.tab);
  }, true);



  // Ensure initial tab is consistent with markup (first .tab.active)
  const initial = (tabs.find(b => b.classList.contains("active"))?.dataset?.tab) || "vouchers";
  activateTab(initial);

  // Keep year selectors in sync (top pill <-> vouchers list)
  if (yearPillSelect){
    yearPillSelect.addEventListener("change", ()=> setActiveYear(yearPillSelect.value));
  }
  if (yearSelect){
    yearSelect.addEventListener("change", ()=> setActiveYear(yearSelect.value));
  }

  // --- Accounts helpers ---

  function accountLabel(no){
    const a = state.accounts ? state.accounts[no] : null;
    return a ? `${no} – ${a.name}` : `${no} – (okänt konto)`;
  }

  function guessTypeFromAccountNo(no){
    const first = String(no)[0];
    if (first === "1") return "asset";
    if (first === "2") return "liability";
    if (first === "3") return "income";
    if (["4","5","6","7","8"].includes(first)) return "expense";
    return "other";
  }

  function accountTypeLabel(t){
    if (t === "asset") return "Tillgång";
    if (t === "liability") return "EK/skuld";
    if (t === "income") return "Intäkt";
    if (t === "expense") return "Kostnad";
    return "Övrigt";
  }

  function normalizeAccountNo(no){
    return String(no || "").trim();
  }

  function downloadTextFile(filename, text, mime){
    const blob = new Blob([String(text || "")], { type: mime || "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename || "download.txt";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=> URL.revokeObjectURL(url), 5000);
  }

  function toCsvCell(v){
    const s = String(v ?? "");
    // use semicolon-separated CSV; escape quotes
    if (/["\r\n;]/.test(s)) return '"' + s.replaceAll('"', '""') + '"';
    return s;
  }

  const STD_ACCOUNTS_KEY = "FU_STD_ACCOUNTS_MAP_V1";

  function loadStdAccountsMap(){
    try {
      const raw = localStorage.getItem(STD_ACCOUNTS_KEY);
      if (!raw) return null;
      const obj = JSON.parse(raw);
      return (obj && typeof obj === "object") ? obj : null;
    } catch {
      return null;
    }
  }
  function saveStdAccountsMap(map){
    try {
      localStorage.setItem(STD_ACCOUNTS_KEY, JSON.stringify(map || {}));
      return true;
    } catch (e){
      console.error(e);
      return false;
    }
  }

  // --- Bank import / skattekonto import (staging inbox) ---
  // Safety goals:
  // - Import NEVER creates vouchers automatically (only stages inbox rows)
  // - Posting requires explicit user action (row-by-row or bulk with checkbox)
  // - Duplicate protection via fingerprint (idempotent re-import)
  // - Undo uses contra vouchers (append-only)
  const BankImportModule = (function(){
    const el = (id)=> document.getElementById(id);

    const ui = {
      // open buttons
      btnOpen1: el("btnBankImportOpen"),
      btnOpen2: el("btnBankImportOpen2"),

      // inbox
      btnRefresh: el("btnBankInboxRefresh"),
      batchFilter: el("biBatchFilter"),
      statusFilter: el("biStatusFilter"),
      selectAll: el("biSelectAll"),
      tbody: el("biTbody"),
      stats: el("biStats"),
      btnBulkPost: el("btnBiBulkPost"),
      btnBulkDelete: el("btnBiBulkDelete"),
      btnDeleteBatch: el("btnBiDeleteBatch"),
      btnUndoBatch: el("btnBiUndoBatch"),

      // import modal
      modal: el("bankImportModal"),
      btnClose: el("btnBankImportClose"),
      btnReset: el("btnBankImportReset"),
      file: el("biFile"),
      fileName: el("biFileName"),
      source: el("biSource"),
      bankAccount: el("biBankAccount"),
      dateFrom: el("biDateFrom"),
      dateTo: el("biDateTo"),
      sheetBox: el("biSheetBox"),
      sheet: el("biSheet"),
      mapDate: el("biMapDate"),
      mapAmount: el("biMapAmount"),
      mapVat: el("biMapVat"),
      mapText: el("biMapText"),
      mapRef: el("biMapRef"),
      mapDebit: el("biMapDebit"),
      mapCredit: el("biMapCredit"),
      flipSign: el("biFlipSign"),
      previewTbody: el("biPreviewTbody"),
      warnings: el("biWarnings"),
      riskBox: el("biRiskBox"),
      riskOk: el("biRiskOk"),
      btnRun: el("btnBankImportRun"),

      // per row post modal
      postModal: el("bankPostModal"),
      btnPostClose: el("btnBankPostClose"),
      postMeta: el("bankPostMeta"),
      postAccount: el("bankPostAccount"),
      postReviewed: el("bankPostReviewed"),
      btnPostCreate: el("btnBankPostCreate"),
      btnPostIgnore: el("btnBankPostIgnore"),

      // bulk post modal
      bulkModal: el("bankBulkModal"),
      btnBulkClose: el("btnBankBulkClose"),
      btnBulkCancel: el("btnBankBulkCancel"),
      bulkSummary: el("bankBulkSummary"),
      bulkReviewed: el("bankBulkReviewed"),
      btnBulkConfirm: el("btnBankBulkConfirm"),
    };

    const selectedIds = new Set();
    let parsedFile = null; // { fileName, ext, workbook?, sheetName?, rows, fields }
    let prepared = null;   // { source, bankAccount, fileName, sheetName, mapping, rowsNorm, stats, severity }
    let openPostItemId = null;
    let softSaveTimer = null;
    let rebuildTimer = null;
    let importing = false;

    function scheduleBuildPrepared(delayMs){
      if (rebuildTimer) clearTimeout(rebuildTimer);
      const d = (typeof delayMs === "number" && Number.isFinite(delayMs)) ? Math.max(0, delayMs) : 80;
      rebuildTimer = setTimeout(()=>{
        rebuildTimer = null;
        try { buildPrepared(); } catch (e){ console.error(e); }
      }, d);
    }

    function clamp01(x){
      const n = Number(x);
      if (!Number.isFinite(n)) return 0;
      return Math.max(0, Math.min(1, n));
    }

    function softSave(){
      if (softSaveTimer) clearTimeout(softSaveTimer);
      softSaveTimer = setTimeout(()=>{
        try { save({ renderAll:false }); } catch (e){ console.error(e); showToast("Kunde inte spara (localStorage).", 6000); }
      }, 250);
    }

    function openModal(){
      if (!ui.modal) return;
      resetModal(false);
      // defaults
      try {
        const s = state.bankImport?.settings || {};
        if (ui.source) ui.source.value = s.lastSource || "bank";
      } catch {}
      fillBankAccountSelect();
      updateModalButtons();
      ui.modal.hidden = false;
    }
    function closeModal(){
      if (!ui.modal) return;
      ui.modal.hidden = true;
    }
    function openPostModal(itemId){
      openPostItemId = itemId;
      const item = getItem(itemId);
      if (!item || !ui.postModal) return;
      fillAccountSelect(ui.postAccount, { includeEmpty: true, emptyLabel: "Välj motkonto…" });
      if (ui.postAccount){
        ui.postAccount.value = (item.suggestedAccount && state.accounts?.[item.suggestedAccount]) ? item.suggestedAccount : "";
      }
      if (ui.postReviewed) ui.postReviewed.checked = false;
      if (ui.btnPostCreate) ui.btnPostCreate.disabled = true;
      if (ui.postMeta){
        const a = Number(item.amount)||0;
        const v = Number(item.vat)||0;
        const ref = String(item.ref ?? "").trim();
        ui.postMeta.textContent = `${item.dateISO} · ${fmtSEK(a)}${(Number.isFinite(v) && Math.abs(v) > 0.00001) ? (" · Moms: " + fmtSEK(v)) : ""} · ${(item.text||"").slice(0,120)}${ref ? " · Ref: " + ref.slice(0,60) : ""}`;
      }
      ui.postModal.hidden = false;
    }
    function closePostModal(){
      if (!ui.postModal) return;
      ui.postModal.hidden = true;
      openPostItemId = null;
    }

    function openBulkModal(summaryHtml){
      if (!ui.bulkModal) return;
      if (ui.bulkSummary) ui.bulkSummary.innerHTML = summaryHtml || "";
      if (ui.bulkReviewed) ui.bulkReviewed.checked = false;
      if (ui.btnBulkConfirm) ui.btnBulkConfirm.disabled = true;
      ui.bulkModal.hidden = false;
    }
    function closeBulkModal(){
      if (!ui.bulkModal) return;
      ui.bulkModal.hidden = true;
    }

    function resetModal(keepFile){
      prepared = null;
      if (!keepFile){
        parsedFile = null;
        if (ui.file) ui.file.value = "";
        if (ui.fileName) ui.fileName.textContent = "Ingen fil vald";
      }
      if (ui.sheetBox) ui.sheetBox.hidden = true;
      if (ui.sheet) ui.sheet.innerHTML = "";
      [ui.mapDate, ui.mapAmount, ui.mapVat, ui.mapText, ui.mapRef, ui.mapDebit, ui.mapCredit].filter(Boolean).forEach(s=>{
        s.innerHTML = "";
      });
      if (ui.flipSign) ui.flipSign.checked = false;
      if (ui.previewTbody) ui.previewTbody.innerHTML = "";
      if (ui.warnings) ui.warnings.innerHTML = "";
      if (ui.riskBox) ui.riskBox.hidden = true;
      if (ui.riskOk) ui.riskOk.checked = false;
      updateModalButtons();
    }

    function fillAccountSelect(select, opts){
      if (!select) return;
      const includeEmpty = !!opts?.includeEmpty;
      const emptyLabel = opts?.emptyLabel || "–";

      const accs = Object.keys(state.accounts || {}).slice().sort((a,b)=> String(a).localeCompare(String(b), "sv"));
      select.innerHTML = "";
      if (includeEmpty){
        const o = document.createElement("option");
        o.value = "";
        o.textContent = emptyLabel;
        select.appendChild(o);
      }
      for (const no of accs){
        const o = document.createElement("option");
        o.value = no;
        o.textContent = accountLabel(no);
        select.appendChild(o);
      }
    }

    function fillBankAccountSelect(){
      if (!ui.bankAccount) return;
      fillAccountSelect(ui.bankAccount, { includeEmpty: true, emptyLabel: "Välj konto…" });
      const src = ui.source ? ui.source.value : "bank";
      const s = state.bankImport?.settings || {};
      const preferred = src === "skattekonto" ? (s.defaultTaxAccount || "1630") : (s.defaultBankAccount || "1930");
      if (preferred && state.accounts?.[preferred]) ui.bankAccount.value = preferred;
      else if (src === "skattekonto" && state.accounts?.["1630"]) ui.bankAccount.value = "1630";
      else if (src === "bank" && state.accounts?.["1930"]) ui.bankAccount.value = "1930";
    }

    function setPreparedNull(msg){
      prepared = null;
      if (ui.warnings) ui.warnings.innerHTML = msg ? `<div>${escapeHtml(String(msg))}</div>` : "";
      if (ui.previewTbody) ui.previewTbody.innerHTML = "";
      updateModalButtons();
    }

    function fileExt(name){
      const t = String(name||"").toLowerCase();
      const m = /\.([a-z0-9]+)$/.exec(t);
      return m ? m[1] : "";
    }

    function pad2(n){
      return String(Number(n) || 0).padStart(2, "0");
    }
    function rand4(){
      try {
        const b = new Uint8Array(2);
        crypto.getRandomValues(b);
        const n = ((b[0] << 8) | b[1]) % (36*36*36*36);
        return n.toString(36).toUpperCase().padStart(4, "0");
      } catch {
        return Math.random().toString(36).slice(2,6).toUpperCase().padEnd(4, "0");
      }
    }
    function makeBatchId(){
      const d = new Date();
      const y = d.getFullYear();
      const mo = pad2(d.getMonth()+1);
      const da = pad2(d.getDate());
      const hh = pad2(d.getHours());
      const mm = pad2(d.getMinutes());
      const ss = pad2(d.getSeconds());
      return `bankimport_${y}${mo}${da}_${hh}${mm}${ss}_${rand4()}`;
    }

    function loadScript(url){
      return new Promise((resolve, reject)=>{
        const s = document.createElement("script");
        s.src = url;
        s.async = true;
        s.onload = ()=> resolve(true);
        s.onerror = ()=> reject(new Error("Kunde inte ladda script: " + url));
        document.head.appendChild(s);
      });
    }
    async function ensurePapa(){
      if (window.Papa) return true;
      const urls = [
        "https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js",
      ];
      for (const url of urls){
        try {
          await loadScript(url);
          if (window.Papa) return true;
        } catch (e){
          console.error(e);
        }
      }
      return !!window.Papa;
    }
    async function ensureXlsx(){
      if (window.XLSX) return true;
      const urls = [
        // Optional offline/local copy (place the file next to this HTML in ./vendor/)
        "./vendor/xlsx.full.min.js",
        "./vendor/xlsx.min.js",
        "https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js",
      ];
      for (const url of urls){
        try {
          await loadScript(url);
          if (window.XLSX) return true;
        } catch (e){
          console.error(e);
        }
      }
      return !!window.XLSX;
    }

    function getFieldsFromRows(rows){
      const set = new Set();
      (rows||[]).forEach(r=>{
        if (!r || typeof r !== "object") return;
        Object.keys(r).forEach(k=> set.add(k));
      });
      return Array.from(set);
    }

    function pickField(fields, patterns){
      const f = (fields||[]).map(x=> String(x||"").trim()).filter(Boolean);
      const norm = (s)=> String(s||"").toLowerCase().replaceAll(" ", "").replaceAll("_", "");
      const fNorm = f.map(x=> ({ raw:x, n:norm(x) }));
      for (const p of patterns){
        const pn = norm(p);
        const exact = fNorm.find(x=> x.n === pn);
        if (exact) return exact.raw;
      }
      for (const p of patterns){
        const pn = norm(p);
        const incl = fNorm.find(x=> x.n.includes(pn));
        if (incl) return incl.raw;
      }
      return "";
    }

    function fillMappingSelect(select, fields, prefer, allowNone){
      if (!select) return;

      const fieldLabel = (raw)=>{
        const s = String(raw || "").trim();
        let m = /^col(\d+)$/i.exec(s);
        if (m) return `Kolumn ${Number(m[1])}`;
        // Legacy SheetJS placeholders when header cells are blank
        m = /^__empty(?:_(\d+))?$/i.exec(s);
        if (m){
          const n = (m[1] == null) ? 1 : (Number(m[1]) + 2);
          return `Kolumn ${n}`;
        }
        return s;
      };

      select.innerHTML = "";
      const o0 = document.createElement("option");
      o0.value = "";
      o0.textContent = allowNone ? "(ingen)" : "Välj…";
      select.appendChild(o0);
      (fields||[]).forEach(f=>{
        const o = document.createElement("option");
        o.value = f;
        o.textContent = fieldLabel(f);
        select.appendChild(o);
      });
      // Only auto-select for required fields. Optional mappings should default to "(ingen)"
      // to avoid accidentally switching import mode (e.g. enabling Debit/Kredit).
      if (!allowNone && prefer && fields.includes(prefer)) select.value = prefer;
    }

    function parseDateToISO(v){
      if (v == null) return "";

      // Native Date object
      try {
        if (v instanceof Date && Number.isFinite(v.getTime())){
          return v.toISOString().slice(0,10);
        }
      } catch {}

      const excelSerialToISO = (n)=>{
        const serial = Number(n);
        if (!Number.isFinite(serial)) return "";
        // Typical modern Excel serial dates are ~40k-50k.
        if (serial < 10_000 || serial > 100_000) return "";

        // Excel 1900 date system with leap-year bug at 1900-02-29 (serial 60).
        const wholeDays = Math.floor(serial);
        const adj = wholeDays >= 60 ? (wholeDays - 1) : wholeDays;
        const ms = Math.round((adj - 25569) * 86400 * 1000);
        const d = new Date(ms);
        if (!Number.isFinite(d.getTime())) return "";
        return d.toISOString().slice(0,10);
      };

      // Handle numbers directly (can happen for some CSV sources).
      if (typeof v === "number"){
        // YYYYMMDD as number
        if (Number.isFinite(v) && v >= 19000101 && v <= 20991231){
          const s8 = String(Math.trunc(v));
          if (/^\d{8}$/.test(s8)) return `${s8.slice(0,4)}-${s8.slice(4,6)}-${s8.slice(6,8)}`;
        }
        const iso = excelSerialToISO(v);
        if (iso) return iso;
      }

      const s0 = String(v).replace(/^\uFEFF/, "").trim();
      if (!s0) return "";

      // Already ISO date
      if (/^\d{4}-\d{2}-\d{2}$/.test(s0)) return s0;
      // ISO date-time or date with time appended (keep the date part)
      if (/^\d{4}-\d{2}-\d{2}[T\s]/.test(s0)) return s0.slice(0,10);

      // Pure YYYYMMDD
      if (/^\d{8}$/.test(s0)) return `${s0.slice(0,4)}-${s0.slice(4,6)}-${s0.slice(6,8)}`;

      // Excel serial as string (common when saving XLSX -> CSV)
      if (/^\d{5}(?:\.\d+)?$/.test(s0)){
        const iso = excelSerialToISO(s0);
        if (iso) return iso;
      }

      // Find a date anywhere in the string (e.g. "2024-01-31 00:00:00")
      let m = /\b([12]\d{3})[-\/.](\d{1,2})[-\/.](\d{1,2})\b/.exec(s0);
      if (m){
        const yy = m[1];
        const mm = String(m[2]).padStart(2, "0");
        const dd = String(m[3]).padStart(2, "0");
        return `${yy}-${mm}-${dd}`;
      }
      m = /\b(\d{1,2})[-\/.](\d{1,2})[-\/.]([12]\d{3})\b/.exec(s0);
      if (m){
        const dd = String(m[1]).padStart(2, "0");
        const mm = String(m[2]).padStart(2, "0");
        return `${m[3]}-${mm}-${dd}`;
      }

      // Two-digit year variants (common in some exports, e.g. 31/01/24)
      m = /\b(\d{1,2})[-\/.](\d{1,2})[-\/.](\d{2})\b/.exec(s0);
      if (m){
        const dd = String(m[1]).padStart(2, "0");
        const mm = String(m[2]).padStart(2, "0");
        const yy2 = Number(m[3]);
        if (Number.isFinite(yy2)){
          const yyyy = (yy2 <= 79) ? (2000 + yy2) : (1900 + yy2);
          return `${yyyy}-${mm}-${dd}`;
        }
      }

      return "";
    }

    function parseNumberSE(v){
      if (v == null) return NaN;
      if (typeof v === "number") return v;
      let s = String(v).trim();
      if (!s) return NaN;
      // Remove all whitespace (space, NBSP, etc.)
      s = s.replace(/\s+/g, "");
      // allow parentheses for negative
      let neg = false;
      if (s.startsWith("(") && s.endsWith(")")) { neg = true; s = s.slice(1,-1); }
      s = s.replaceAll("kr", "").replaceAll("sek", "");
      s = s.replaceAll("'", "");
      // if both comma and dot exist, assume dot thousands, comma decimal (sv)
      if (s.includes(",") && s.includes(".")){
        s = s.replaceAll(".", "");
        s = s.replace(",", ".");
      } else if (s.includes(",") && !s.includes(".")){
        s = s.replace(",", ".");
      }
      const n = Number(s);
      if (!Number.isFinite(n)) return NaN;
      return neg ? -n : n;
    }

    function colStats(rows, col){
      let nonEmpty = 0;
      let dateOk = 0;
      let numOk = 0;
      let totalLen = 0;
      let maxLen = 0;
      const uniq = new Set();
      for (const r of (rows || [])){
        if (!r || typeof r !== "object") continue;
        const v = r[col];
        if (v == null) continue;
        const s = String(v).trim();
        if (!s) continue;
        nonEmpty++;
        totalLen += s.length;
        if (s.length > maxLen) maxLen = s.length;
        uniq.add(bankImportNormFpText(s));
        if (parseDateToISO(s)) dateOk++;
        const n = parseNumberSE(s);
        if (Number.isFinite(n)) numOk++;
      }
      return {
        nonEmpty,
        dateRate: nonEmpty ? (dateOk / nonEmpty) : 0,
        numRate: nonEmpty ? (numOk / nonEmpty) : 0,
        avgLen: nonEmpty ? (totalLen / nonEmpty) : 0,
        maxLen,
        uniqRate: nonEmpty ? (uniq.size / nonEmpty) : 0,
      };
    }

    function detectMapping(rows, columns){
      const cols = (columns || []).slice();
      // Performance: auto-detection is heuristic; sample rows to avoid UI freezes on large imports.
      const sampleRows = Array.isArray(rows) ? rows.slice(0, Math.min(rows.length, 2000)) : [];
      const stats = {};
      cols.forEach(c=> stats[c] = colStats(sampleRows, c));

      const nameDate = pickField(cols, ["datum","date","transaktionsdatum","bokforingsdag","bokföringsdag","valutadag","transactiondate"]);
      const nameText = pickField(cols, ["text","beskrivning","förklaring","forklaring","memo","motpart","namn","description","specifikation","kategori"]);
      const nameAmount = pickField(cols, ["belopp","amount","summa","total","amountsek"]);
      const nameVat = pickField(cols, ["moms","vat","momssek","vatsek","momsbelopp","vatamount"]);
      const nameRef = pickField(cols, ["referens","reference","ref","ocr","meddelande","message","ver","trans","id"]);
      const nameDebit = pickField(cols, ["debet","debit","ut","withdrawal"]);
      const nameCredit = pickField(cols, ["kredit","credit","in","deposit"]);

      const scoreDate = (c)=>{
        const st = stats[c] || {};
        let s = (st.dateRate || 0);
        if (c === nameDate) s += 0.18;
        return s;
      };
      const scoreNum = (c)=>{
        const st = stats[c] || {};
        let s = (st.numRate || 0);
        if (c === nameAmount) s += 0.18;
        if (c === nameDebit || c === nameCredit) s += 0.1;
        // penalize number columns that look like dates
        s -= (st.dateRate || 0) * 0.35;
        return s;
      };

      const date = cols.slice().sort((a,b)=> scoreDate(b) - scoreDate(a))[0] || "";

      // debit/credit via name match if distinct
      let debit = nameDebit || "";
      let credit = nameCredit || "";
      if (debit && credit && debit === credit){ debit = ""; credit = ""; }
      if (debit && stats[debit] && stats[debit].numRate < 0.2) debit = "";
      if (credit && stats[credit] && stats[credit].numRate < 0.2) credit = "";

      let amount = "";
      if (!(debit && credit)){
        const excluded = new Set([date, debit, credit].filter(Boolean));
        amount = cols
          .filter(c=> !excluded.has(c))
          .slice()
          .sort((a,b)=> scoreNum(b) - scoreNum(a))[0] || "";
      }

      // VAT is optional. Prefer explicit header match if it looks numeric.
      let vat = nameVat || "";
      if (vat && stats[vat] && (stats[vat].numRate || 0) < 0.2) vat = "";
      if (vat && vat === amount) vat = "";

      const excludedText = new Set([date, amount, debit, credit].filter(Boolean));
      let text = cols
        .filter(c=> !excludedText.has(c))
        .slice()
        .sort((a,b)=> (stats[b]?.avgLen || 0) - (stats[a]?.avgLen || 0))[0] || "";
      if (nameText) text = nameText;

      const excludedRef = new Set([date, amount, debit, credit, text].filter(Boolean));
      let ref = "";
      if (nameRef && !excludedRef.has(nameRef)) ref = nameRef;
      if (!ref){
        const candidates = cols.filter(c=> !excludedRef.has(c));
        ref = candidates
          .slice()
          .sort((a,b)=>{
            const sa = stats[a] || {};
            const sb = stats[b] || {};
            // want high uniqueness, short-ish strings
            const qa = (sa.uniqRate || 0) - (Math.max(0, (sa.avgLen || 0) - 24) / 200);
            const qb = (sb.uniqRate || 0) - (Math.max(0, (sb.avgLen || 0) - 24) / 200);
            return qb - qa;
          })[0] || "";
      }

      return { date, amount, vat, text, ref, debit, credit };
    }

    function normText(t){
      return String(t||"")
        .toLowerCase()
        .replace(/\s+/g, " ")
        .trim();
    }

    function fingerprintForRow(r){
      try {
        return bankImportFingerprintKey(r.dateISO, r.amount, r.text, r.ref);
      } catch {
        return "";
      }
    }

    function normWhitespaceKeepCase(s){
      return String(s || "").replace(/\s+/g, " ").trim();
    }

    function normalizeRows(rows, mapping, options){
      const from = options && options.from ? String(options.from) : (options && options.dateFrom ? String(options.dateFrom) : "");
      const to = options && options.to ? String(options.to) : (options && options.dateTo ? String(options.dateTo) : "");
      const m = mapping || {};
      const useDebCred = !!(m.debit && m.credit && !m.amount);

      const drafts = [];
      let invalidDate = 0;
      let invalidAmount = 0;
      let invalidText = 0;
      let outOfRange = 0;
      let zeroAmounts = 0;
      const uniqueDates = new Set();
      let maxTextLen = 0;
      let totalTextLen = 0;

      let considered = 0; // non-empty rows considered for validation rates
      for (const r of (rows || [])){
        if (!r || typeof r !== "object") continue;

        const rawDate = m.date ? r[m.date] : "";
        const rawText = m.text ? r[m.text] : "";
        const rawRef = m.ref ? r[m.ref] : "";
        const rawAmount = m.amount ? r[m.amount] : "";
        const rawVat = m.vat ? r[m.vat] : "";
        const rawDebit = m.debit ? r[m.debit] : "";
        const rawCredit = m.credit ? r[m.credit] : "";

        const isEmptyRow = !String(rawDate ?? "").trim() && !String(rawText ?? "").trim() && !String(rawRef ?? "").trim() &&
          (!useDebCred ? !String(rawAmount ?? "").trim() : (!String(rawDebit ?? "").trim() && !String(rawCredit ?? "").trim()));
        if (isEmptyRow) continue;

        considered++;

        const dateISO = parseDateToISO(rawDate);
        if (!dateISO) invalidDate++;

        const text = normWhitespaceKeepCase(rawText);
        if (!text) invalidText++;

        let amount = NaN;
        if (useDebCred){
          const deb = parseNumberSE(rawDebit);
          const cre = parseNumberSE(rawCredit);
          const d = Number.isFinite(deb) ? deb : 0;
          const c = Number.isFinite(cre) ? cre : 0;
          amount = c - d;
        } else {
          amount = parseNumberSE(rawAmount);
        }
        amount = Math.round(amount * 100) / 100;

        // Optional: flip sign (useful for some exports where purchases are positive)
        if (m.flipSign) amount = -amount;
        amount = Math.round(amount * 100) / 100;

        if (!Number.isFinite(amount)) invalidAmount++;

        // Optional VAT (Moms)
        let vat = NaN;
        if (m.vat){
          vat = parseNumberSE(rawVat);
          vat = Math.round(vat * 100) / 100;
          if (!Number.isFinite(vat)) vat = NaN;
        }

        // Keep only fully valid rows
        if (!dateISO || !text || !Number.isFinite(amount)) continue;
        if (from && dateISO < from) { outOfRange++; continue; }
        if (to && dateISO > to) { outOfRange++; continue; }

        const ref = normWhitespaceKeepCase(rawRef);
        if (Math.abs(amount) < 0.00001) zeroAmounts++;
        uniqueDates.add(dateISO);
        maxTextLen = Math.max(maxTextLen, text.length);
        totalTextLen += text.length;

        const fp = bankImportFingerprintKey(dateISO, amount, text, ref);
        drafts.push({ dateISO, amount, vat: Number.isFinite(vat) ? vat : null, text: clampText(text, 200), ref: clampText(ref, 120), raw: r, fingerprint: fp });
      }

      const kept = drafts.length;
      const avgTextLen = kept ? (totalTextLen / kept) : 0;

      let severity = "ok";
      const warnings = [];

      const invalidDateRate = considered ? (invalidDate / considered) : 1;
      const invalidAmountRate = considered ? (invalidAmount / considered) : 1;

      if (kept === 0) {
        severity = "red";
        warnings.push("Inga rader kunde tolkas med vald mappning.");
      }
      if (invalidDateRate > 0.20) {
        severity = "red";
        warnings.push("Mer än 20% rader saknar giltigt datum – kontrollera kolumnmappningen.");
      }
      if (invalidAmountRate > 0.20) {
        severity = "red";
        warnings.push("Mer än 20% rader saknar giltigt belopp – kontrollera kolumnmappningen.");
      }
      if (kept > 0 && zeroAmounts === kept) {
        severity = "red";
        warnings.push("Alla belopp blev 0 – sannolikt fel kolumn för belopp/debet/kredit.");
      }

      if (invalidDate > 0) warnings.push(`${invalidDate} rader saknar giltigt datum.`);
      if (invalidAmount > 0) warnings.push(`${invalidAmount} rader saknar giltigt belopp.`);
      if (invalidText > 0) warnings.push(`${invalidText} rader saknar text/beskrivning.`);
      if (outOfRange > 0) warnings.push(`${outOfRange} rader filtrerades bort av datumintervall.`);

      // Yellow warnings
      if (severity !== "red"){
        if (kept >= 10 && uniqueDates.size <= 2){
          warnings.push("Ovanligt få unika datum – kan tyda på fel datumkolumn.");
          severity = "yellow";
        }
        if (maxTextLen >= 170 || avgTextLen >= 80){
          warnings.push("Ovanligt långa texter – kan tyda på att fel kolumn valts som Text.");
          severity = "yellow";
        }
        try {
          if (m.amount){
            const stA = colStats(rows, m.amount);
            if ((stA.dateRate || 0) > 0.45){
              warnings.push("Belopp-kolumnen ser ut att innehålla datum – kontrollera mappningen.");
              severity = "yellow";
            }
          }
          if (m.date){
            const stD = colStats(rows, m.date);
            if ((stD.numRate || 0) > 0.80 && (stD.dateRate || 0) < 0.25){
              warnings.push("Datum-kolumnen ser ut att innehålla tal – kontrollera mappningen.");
              severity = "yellow";
            }
          }
        } catch {}
      }

      if (!warnings.length) warnings.push("OK");

      return {
        drafts,
        warnings,
        stats: { total: (rows || []).length, considered, kept, invalidDate, invalidAmount, invalidText, outOfRange, uniqueDates: uniqueDates.size, avgTextLen, maxTextLen },
        severity,
      };
    }

    function setModalWarning(severity, lines){
      const sev = severity || "ok";
      const items = (lines||[]).map(x=> `<div>${escapeHtml(x)}</div>`).join("");
      if (ui.warnings) ui.warnings.innerHTML = items || "<div>OK</div>";
      if (ui.riskBox) ui.riskBox.hidden = (sev !== "red");
      updateModalButtons();
    }

    function updateModalButtons(){
      const rows = prepared?.rowsNorm || [];
      const count = rows.length;
      if (ui.btnRun) ui.btnRun.textContent = `Importera ${count} rader till inkorg`;

      const hasPrepared = !!prepared && count > 0;
      const red = prepared?.severity === "red";
      const riskOk = ui.riskOk ? ui.riskOk.checked : false;
      if (ui.btnRun) ui.btnRun.disabled = !hasPrepared || (red && !riskOk);
    }

    function getItem(id){
      return (state.bankImport && state.bankImport.items) ? state.bankImport.items[id] : null;
    }

    function listBatches(){
      const m = state.bankImport?.batches || {};
      const list = Object.values(m).filter(x=>x && typeof x === "object");
      list.sort((a,b)=> String(b.createdAtISO||b.createdAt||"").localeCompare(String(a.createdAtISO||a.createdAt||""), "sv"));
      return list;
    }

    function listItems(){
      const m = state.bankImport?.items || {};
      return Object.values(m).filter(x=>x && typeof x === "object");
    }

    function visibleItems(){
      const batchId = ui.batchFilter ? ui.batchFilter.value : "";
      const status = ui.statusFilter ? ui.statusFilter.value : "";
      let items = listItems();
      if (batchId) items = items.filter(x=> x.batchId === batchId);
      if (status) items = items.filter(x=> String(x.status||"") === status);
      items.sort((a,b)=> (String(b.dateISO||"") + String(b.createdAtISO||b.createdAt||"")).localeCompare(String(a.dateISO||"")+String(a.createdAtISO||a.createdAt||""), "sv"));
      return items;
    }

    function suggestCounterAccount(normRow){
      const t = normText(normRow.text);
      // Strong-ish supplier invoice match (outgoing payments)
      try {
        const si = (state.supplierInvoices||[]).find(x=>{
          if (!x) return false;
          const ocr = String(x.ocr||"").trim();
          const invNo = String(x.invoiceNo||"").trim();
          if (!ocr && !invNo) return false;
          const hasRef = (ocr && t.includes(normText(ocr))) || (invNo && t.includes(normText(invNo)));
          if (!hasRef) return false;
          const gross = Number(x.gross)||0;
          return Math.abs(Math.abs(Number(normRow.amount)||0) - Math.abs(gross)) < 0.01;
        });
        if (si){
          return { account: si.liabAccount || "2440", invoiceId: si.id, confidence: 0.9 };
        }
      } catch {}

      // Simple heuristics
      if (/skatteverket|skattekonto|f-skatt|moms/.test(t)) return { account: "1630", invoiceId: null, confidence: 0.35 };
      if (/swish/.test(t)) return { account: "3041", invoiceId: null, confidence: 0.25 };
      if (/kort|card|visa|mastercard/.test(t)) return { account: "6570", invoiceId: null, confidence: 0.2 };
      return { account: "", invoiceId: null, confidence: 0 };
    }

    function detectCsvDelimiter(line){
      const s = String(line || "");
      const cSemi = (s.match(/;/g) || []).length;
      const cComma = (s.match(/,/g) || []).length;
      const cTab = (s.match(/\t/g) || []).length;
      if (cTab > cSemi && cTab > cComma) return "\t";
      if (cSemi >= cComma) return ";";
      return ",";
    }

    function splitCsvLine(line, delim){
      const out = [];
      let cur = "";
      let inQ = false;
      const s = String(line || "");
      for (let i=0;i<s.length;i++){
        const ch = s[i];
        if (inQ){
          if (ch === '"'){
            const next = s[i+1];
            if (next === '"') { cur += '"'; i++; }
            else inQ = false;
          } else {
            cur += ch;
          }
        } else {
          if (ch === '"') inQ = true;
          else if (ch === delim){ out.push(cur); cur = ""; }
          else cur += ch;
        }
      }
      out.push(cur);
      return out.map(x=> String(x ?? "").trim());
    }

    function normalizeHeaderFields(fields){
      const clean = (v)=> String(v ?? "").replace(/^\uFEFF/, "").trim();
      const out = (fields||[]).map(clean);
      const hasAny = out.some(x=> !!x);
      if (!hasAny){
        return out.map((_,i)=> `Col${i+1}`);
      }
      return out.map((f,i)=> f ? f : `Col${i+1}`);
    }

    function simpleCsvToRows(text){
      const lines = String(text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n");

      const headerKeywords = [
        "datum","date","transaktionsdatum","bokforingsdag","bokföringsdag","valutadag",
        "belopp","amount","summa","moms","vat","text","beskrivning","förklaring","forklaring","memo",
        "referens","reference","ocr","meddelande","message","saldo","verifikationsnummer"
      ];
      const hasKeyword = (s)=>{
        const t = String(s||"").toLowerCase();
        return headerKeywords.some(k=> t.includes(k));
      };
      const norm = (s)=> String(s ?? "").trim();
      const scoreCandidate = (cells)=>{
        const nonEmpty = (cells||[]).map(norm).filter(Boolean);
        if (nonEmpty.length < 2) return -1;
        let score = nonEmpty.length;
        score += nonEmpty.filter(hasKeyword).length * 5;
        if (nonEmpty.length >= 4) score += 2;
        let numericish = 0;
        let dateish = 0;
        for (const c of nonEmpty){
          if (/^[+-]?[0-9\s'.,()]+$/.test(c)) numericish++;
          if (parseDateToISO(c)) dateish++;
        }
        score -= numericish * 0.6;
        score -= dateish * 0.6;
        return score;
      };

      // Pick best header row among first non-empty lines
      let headerLineIdx = -1;
      let headerDelim = ";";
      let bestScore = -1;
      const scan = Math.min(lines.length, 80);
      for (let i=0; i<scan; i++){
        const ln = String(lines[i] || "");
        if (!ln.trim()) continue;
        const d = detectCsvDelimiter(ln);
        const cells = splitCsvLine(ln, d);
        const s = scoreCandidate(cells);
        if (s > bestScore){
          bestScore = s;
          headerLineIdx = i;
          headerDelim = d;
        }
      }

      if (headerLineIdx < 0) return { rows: [], fields: [] };

      const headerRaw = splitCsvLine(String(lines[headerLineIdx] || ""), headerDelim);
      const fields = normalizeHeaderFields(headerRaw);

      const rows = [];
      for (let i=headerLineIdx + 1; i<lines.length; i++){
        const ln = String(lines[i] || "");
        if (!ln.trim()) continue;
        const parts = splitCsvLine(ln, headerDelim);
        const isEmpty = parts.every(x=> !String(x||"").trim());
        if (isEmpty) continue;
        const obj = {};
        for (let c=0; c<fields.length; c++) obj[fields[c]] = parts[c] ?? "";
        rows.push(obj);
      }
      return { rows, fields };
    }

    async function parseCsvFile(file){
      const ok = await ensurePapa();
      if (ok){
        return await new Promise((resolve, reject)=>{
          try {
            // Parse as arrays first so we can auto-detect which row is the header
            // (SEB exports often have metadata lines before the real header row).
            window.Papa.parse(file, {
              header: false,
              skipEmptyLines: true,
              complete: (res)=>{
                try {
                  const data = (res && Array.isArray(res.data)) ? res.data : [];
                  const headerKeywords = [
                    "datum","date","transaktionsdatum","bokforingsdag","bokföringsdag","valutadag",
                    "belopp","amount","summa","moms","vat","text","beskrivning","förklaring","forklaring","memo",
                    "referens","reference","ocr","meddelande","message","saldo","verifikationsnummer"
                  ];
                  const hasKeyword = (s)=>{
                    const t = String(s||"").toLowerCase();
                    return headerKeywords.some(k=> t.includes(k));
                  };
                  const norm = (v)=> String(v ?? "").trim();
                  const scoreRow = (row)=>{
                    const cells = (Array.isArray(row) ? row : []).map(norm);
                    const nonEmpty = cells.filter(Boolean);
                    if (nonEmpty.length < 2) return -1;
                    let score = nonEmpty.length;
                    score += nonEmpty.filter(hasKeyword).length * 5;
                    if (nonEmpty.length >= 4) score += 2;
                    let numericish = 0;
                    let dateish = 0;
                    for (const c of nonEmpty){
                      if (/^[+-]?[0-9\s'.,()]+$/.test(c)) numericish++;
                      if (parseDateToISO(c)) dateish++;
                    }
                    score -= numericish * 0.6;
                    score -= dateish * 0.6;
                    return score;
                  };

                  let headerIdx = 0;
                  let best = -1;
                  const scan = Math.min(data.length, 80);
                  for (let i=0; i<scan; i++){
                    const s = scoreRow(data[i]);
                    if (s > best){ best = s; headerIdx = i; }
                  }

                  const headerRaw = Array.isArray(data[headerIdx]) ? data[headerIdx].map(norm) : [];
                  const fields = normalizeHeaderFields(headerRaw);

                  const maxCols = Math.max(fields.length, ...data.slice(headerIdx+1, headerIdx+6).map(r=> Array.isArray(r) ? r.length : 0));
                  const fieldsPadded = fields.concat(Array.from({length: Math.max(0, maxCols - fields.length)}, (_,i)=> `Col${fields.length + i + 1}`));

                  const rows = [];
                  for (let i=headerIdx+1; i<data.length; i++){
                    const r = Array.isArray(data[i]) ? data[i] : [];
                    const parts = r.slice(0, maxCols).map(v=> (v == null ? "" : String(v)));
                    const isEmpty = parts.every(x=> !String(x||"").trim());
                    if (isEmpty) continue;
                    const obj = {};
                    for (let c=0; c<fieldsPadded.length; c++) obj[fieldsPadded[c]] = parts[c] ?? "";
                    rows.push(obj);
                  }

                  resolve({ rows, fields: fieldsPadded });
                } catch (e){
                  reject(e);
                }
              },
              error: (err)=> reject(err)
            });
          } catch (e){ reject(e); }
        });
      }

      // Fallback when PapaParse is blocked/unavailable
      const text = await file.text();
      return simpleCsvToRows(text);
    }

    async function parseTabularFile(file, opts){
      const sheetName = opts && opts.sheetName ? String(opts.sheetName) : "";
      const name = file && file.name ? file.name : "";
      const ext = fileExt(name);
      if (ext === "csv"){
        const { rows, fields } = await parseCsvFile(file);
        return { rows, columns: fields, sheetNames: [], sheetName: "" };
      }
      if (ext === "xlsx" || ext === "xls"){
        const wb = await readWorkbook(file);
        const sheetNames = (wb && Array.isArray(wb.SheetNames)) ? wb.SheetNames.slice() : [];
        const chosen = sheetName || sheetNames[0] || "";
        const { rows, fields, sheetName: used } = workbookSheetToRows(wb, chosen);
        return { rows, columns: fields, sheetNames, sheetName: used || chosen, workbook: wb };
      }
      throw new Error("Okänt filformat. Välj .csv, .xlsx eller .xls.");
    }

    async function readWorkbook(file){
      const ok = await ensureXlsx();
      if (!ok) throw new Error("Excel-parser kunde inte laddas (SheetJS/xlsx). Kontrollera internet eller lägg en lokal kopia i ./vendor/xlsx.full.min.js bredvid HTML-filen.");
      const buf = await file.arrayBuffer();
      const wb = window.XLSX.read(buf, { type: "array" });
      return wb;
    }

    function workbookSheetToRows(wb, sheetName){
      const name = sheetName || (wb && wb.SheetNames ? wb.SheetNames[0] : "");
      const ws = wb && wb.Sheets ? wb.Sheets[name] : null;
      if (!ws) return { rows: [], fields: [] };

      // Excel exports often contain one or more "title" rows above the actual header.
      // SheetJS will then create placeholder header names like "__EMPTY".
      // To avoid that we parse as array-of-arrays, detect a likely header row,
      // and normalize blank headers to ColN.

      const aoa = window.XLSX.utils.sheet_to_json(ws, { header: 1, defval: "", raw: false });
      if (!Array.isArray(aoa) || !aoa.length) return { rows: [], fields: [], sheetName: name };

      const normCell = (v)=> String(v ?? "").trim();
      const headerKeywords = [
        // dates
        "datum","date","transaktionsdatum","bokforingsdag","bokföringsdag","bokforingsdatum","bokföringsdatum","valutadag","valutadatum",
        // amounts
        "belopp","amount","summa","saldo","balance","moms","vat",
        // text / reference
        "text","beskrivning","förklaring","forklaring","memo","motpart","namn","description","specifikation","kategori","reference","referens","ref","ocr","meddelande","message",
        // ids
        "verifikationsnummer","verifikationsnr","verifikationsnum","verification"
      ];
      const hasKeyword = (s)=>{
        const t = String(s||"").toLowerCase();
        return headerKeywords.some(k=> t.includes(k));
      };
      const scoreHeaderRow = (row)=>{
        // Cap width while scoring; avoids scanning far-right empty formatted columns.
        const cells = (Array.isArray(row) ? row : []).slice(0, 80).map(normCell);
        const nonEmpty = cells.filter(Boolean);
        if (nonEmpty.length < 2) return -1;
        let score = nonEmpty.length;
        // Reward header-like keywords
        const kwHits = nonEmpty.filter(hasKeyword).length;
        score += kwHits * 6;
        // SEB metadata/title rows often contain these words; penalize them.
        const joined = nonEmpty.join(" ").toLowerCase();
        if (/(export|exporterad|internetbank|privatperson|konto\b|kontonr|kund\b|org\.?nr|\bseb\b)/.test(joined)) score -= 8;
        // Penalize a single very long "title" cell
        if (nonEmpty.length === 1 && nonEmpty[0].length > 30) score -= 8;
        // Penalize rows that look like pure data (many numeric/date-like values)
        let numericish = 0;
        let dateish = 0;
        for (const c of nonEmpty){
          if (/^[+-]?[0-9\s'.,()]+$/.test(c)) numericish++;
          if (parseDateToISO(c)) dateish++;
        }
        score -= numericish * 0.6;
        score -= dateish * 0.6;
        // Prefer rows with at least two header-like keywords.
        if (kwHits >= 2) score += 6;
        return score;
      };

      let headerRowIdx = 0;
      let bestScore = -1;
      const scan = Math.min(aoa.length, 80);
      for (let i=0; i<scan; i++){
        const s = scoreHeaderRow(aoa[i]);
        if (s > bestScore){ bestScore = s; headerRowIdx = i; }
      }

      // Compute effective column count (avoid including far-right formatted empty columns)
      const effectiveMaxCols = (()=>{
        let max = 0;
        const end = Math.min(aoa.length, headerRowIdx + 250);
        for (let r=headerRowIdx; r<end; r++){
          const row = Array.isArray(aoa[r]) ? aoa[r] : [];
          let last = -1;
          for (let c=row.length-1; c>=0; c--){
            if (normCell(row[c])) { last = c; break; }
          }
          if (last >= 0) max = Math.max(max, last + 1);
        }
        // sanity cap
        if (max <= 0) max = (Array.isArray(aoa[headerRowIdx]) ? aoa[headerRowIdx].length : 0);
        return Math.min(Math.max(1, max), 80);
      })();

      const headerRaw = (Array.isArray(aoa[headerRowIdx]) ? aoa[headerRowIdx] : []).slice(0, effectiveMaxCols).map(normCell);
      const headerPadded = headerRaw.concat(Array.from({length: Math.max(0, effectiveMaxCols - headerRaw.length)}, ()=>""));
      const fields = normalizeHeaderFields(headerPadded);

      const rows = [];
      for (let i=headerRowIdx + 1; i<aoa.length; i++){
        const r = Array.isArray(aoa[i]) ? aoa[i] : [];
        const parts = r.slice(0, effectiveMaxCols).map(v=> (v == null ? "" : String(v)));
        const isEmpty = parts.every(x=> !String(x||"").trim());
        if (isEmpty) continue;
        const obj = {};
        for (let c=0; c<fields.length; c++) obj[fields[c]] = parts[c] ?? "";
        rows.push(obj);
      }

      return { rows, fields, sheetName: name };
    }

    function hydrateMappingFields(fields, autoMap){
      const f = (fields||[]).slice();

      const a = autoMap || {};
      const guessDate = a.date || pickField(f, ["datum","date","transaktionsdatum","bokforingsdag","bokföringsdag","valutadag","transactiondate"]);
      const guessText = a.text || pickField(f, ["text","beskrivning","förklaring","forklaring","memo","motpart","namn","description","specifikation","kategori"]);
      const guessAmount = a.amount || pickField(f, ["belopp","amount","summa","total","amountsek"]);
      const guessVat = a.vat || pickField(f, ["moms","vat","momssek","vatsek","momsbelopp","vatamount"]);
      const guessRef = a.ref || pickField(f, ["referens","reference","ref","ocr","meddelande","message"]);
      // Avoid overly generic tokens like "ut"/"in" which can false-match Swedish words
      // (e.g. "valutadatum" contains "ut").
      const guessDebit = a.debit || pickField(f, ["debet","debit","withdrawal","uttag","utbetalning"]);
      const guessCredit = a.credit || pickField(f, ["kredit","credit","deposit","insättning","inbetalning"]);

      fillMappingSelect(ui.mapDate, f, guessDate, false);
      fillMappingSelect(ui.mapText, f, guessText, false);
      fillMappingSelect(ui.mapAmount, f, guessAmount, false);
      fillMappingSelect(ui.mapVat, f, guessVat, true);
      fillMappingSelect(ui.mapRef, f, guessRef, true);
      fillMappingSelect(ui.mapDebit, f, guessDebit, true);
      fillMappingSelect(ui.mapCredit, f, guessCredit, true);
    }

    function readMapping(){
      return {
        date: ui.mapDate ? ui.mapDate.value : "",
        text: ui.mapText ? ui.mapText.value : "",
        amount: ui.mapAmount ? ui.mapAmount.value : "",
        vat: ui.mapVat ? ui.mapVat.value : "",
        ref: ui.mapRef ? ui.mapRef.value : "",
        debit: ui.mapDebit ? ui.mapDebit.value : "",
        credit: ui.mapCredit ? ui.mapCredit.value : "",
        flipSign: !!(ui.flipSign && ui.flipSign.checked),
      };
    }

    function buildPrepared(){
      if (!parsedFile) return setPreparedNull("Välj en fil.");
      const src = ui.source ? ui.source.value : "bank";
      const bankAcc = ui.bankAccount ? ui.bankAccount.value : "";
      if (!bankAcc) return setPreparedNull("Välj balans-konto (t.ex. 1930 eller 1630).");

      const mapping = readMapping();
      if (!mapping.date || !mapping.text) return setPreparedNull("Mappa minst Datum och Text/Beskrivning.");
      // Only use Debit/Kredit mode when the user has NOT mapped Belopp.
      // This avoids accidental 0-belopp when optional fields get selected.
      const useDebCred = !!(mapping.debit && mapping.credit && !mapping.amount);
      if (!useDebCred && !mapping.amount) return setPreparedNull("Mappa Belopp eller både Debet och Kredit.");

      const from = ui.dateFrom ? ui.dateFrom.value : "";
      const to = ui.dateTo ? ui.dateTo.value : "";
      const rows = parsedFile.rows || [];
      const norm = normalizeRows(rows, mapping, { dateFrom: from, dateTo: to });
      const rowsNorm = (norm.drafts || []).map(d=>{
        const base = {
          source: src,
          bankAccount: bankAcc,
          dateISO: d.dateISO,
          amount: d.amount,
          vat: d.vat,
          text: d.text,
          ref: d.ref,
          raw: d.raw || null,
          fingerprint: d.fingerprint,
        };
        // Keep modal responsive: do not run expensive suggestion logic per row here.
        // Suggestions are computed once during import into inbox instead.
        base.suggestedAccount = "";
        base.suggestedInvoiceId = null;
        base.confidence = 0;
        base.status = "unmatched";
        return base;
      });

      prepared = {
        source: src,
        bankAccount: bankAcc,
        fileName: parsedFile.fileName,
        fileHash: parsedFile.fileHash || "",
        sheetName: parsedFile.sheetName || "",
        mapping,
        rowsNorm,
        stats: norm.stats,
        severity: norm.severity,
        warnings: norm.warnings,
      };

      renderPreview(rowsNorm);
      setModalWarning(prepared.severity, (prepared.warnings && prepared.warnings.length) ? prepared.warnings : ["OK"]);
      updateModalButtons();
    }

    function renderPreview(rowsNorm){
      if (!ui.previewTbody) return;
      ui.previewTbody.innerHTML = "";
      (rowsNorm||[]).slice(0,20).forEach(r=>{
        const tr = document.createElement("tr");
        const vat = Number(r.vat);
        tr.innerHTML = `
          <td>${escapeHtml(r.dateISO)}</td>
          <td style="text-align:right;">${escapeHtml(String(r.amount))}</td>
          <td style="text-align:right;">${(Number.isFinite(vat) && Math.abs(vat) > 0.00001) ? escapeHtml(String(vat)) : ""}</td>
          <td>${escapeHtml(String(r.text ?? ""))}</td>
          <td>${escapeHtml(String(r.ref ?? ""))}</td>
        `;
        ui.previewTbody.appendChild(tr);
      });
    }

    function bufToHex(buf){
      try {
        const b = new Uint8Array(buf);
        let s = "";
        for (let i=0;i<b.length;i++) s += b[i].toString(16).padStart(2, "0");
        return s;
      } catch {
        return "";
      }
    }
    async function tryFileSha256Hex(file){
      try {
        if (!window.crypto || !crypto.subtle) return "";
        if (file && typeof file.size === "number" && file.size > 40*1024*1024) return ""; // avoid huge files
        const buf = await file.arrayBuffer();
        const dig = await crypto.subtle.digest("SHA-256", buf);
        return bufToHex(dig);
      } catch {
        return "";
      }
    }

    async function handleFileSelected(){
      const f = ui.file && ui.file.files ? ui.file.files[0] : null;
      if (!f) return;
      resetModal(true);
      if (ui.fileName) ui.fileName.textContent = f.name;
      const ext = fileExt(f.name);
      try {
        // Hash is optional metadata; skip for larger files to avoid extra memory/CPU.
        const hash = (f && typeof f.size === "number" && f.size > 8*1024*1024) ? "" : await tryFileSha256Hex(f);
        const res = await parseTabularFile(f, { sheetName: ui.sheet ? ui.sheet.value : "" });
        const fields = res.columns || [];
        const sheetNames = res.sheetNames || [];

        if (ui.sheet){
          ui.sheet.innerHTML = "";
          sheetNames.forEach(n=>{
            const o = document.createElement("option");
            o.value = n;
            o.textContent = n;
            ui.sheet.appendChild(o);
          });
        }
        if (ui.sheetBox) ui.sheetBox.hidden = !(ext === "xlsx" || ext === "xls") || sheetNames.length <= 1;

        parsedFile = {
          fileName: f.name,
          ext,
          fileHash: hash,
          workbook: res.workbook || null,
          sheetName: res.sheetName || "",
          rows: res.rows || [],
          fields,
        };

        const auto = detectMapping(parsedFile.rows, parsedFile.fields);
        hydrateMappingFields(fields, auto);
        // Yield so mapping UI paints before processing.
        scheduleBuildPrepared(0);
      } catch (e){
        console.error(e);
        setPreparedNull(e && e.message ? e.message : "Kunde inte läsa filen.");
      }
    }

    function handleSheetChanged(){
      if (!parsedFile || !parsedFile.workbook) return;
      try {
        const chosen = ui.sheet ? ui.sheet.value : "";
        const { rows, fields, sheetName } = workbookSheetToRows(parsedFile.workbook, chosen);
        parsedFile.rows = rows;
        parsedFile.fields = fields;
        parsedFile.sheetName = sheetName;
        const auto = detectMapping(rows, fields);
        hydrateMappingFields(fields, auto);
        scheduleBuildPrepared(0);
      } catch (e){
        console.error(e);
        setPreparedNull("Kunde inte läsa sheet.");
      }
    }

    async function importIntoInbox(){
      if (importing) return;
      if (!prepared) return;
      ensureBankImportState();
      importing = true;
      if (ui.btnRun) ui.btnRun.disabled = true;
      const src = prepared.source;
      const bankAcc = prepared.bankAccount;
      const rows = prepared.rowsNorm || [];

      const fpMap = state.bankImport.fingerprints || (state.bankImport.fingerprints = {});
      const batches = state.bankImport.batches || (state.bankImport.batches = {});
      const items = state.bankImport.items || (state.bankImport.items = {});

      const batchId = makeBatchId();
      const now = new Date().toISOString();
      const batch = {
        id: batchId,
        createdAtISO: now,
        source: src,
        filename: prepared.fileName || "",
        fileHash: prepared.fileHash || "",
        rowCount: rows.length,
        accountBank: bankAcc,
        mapping: prepared.mapping || {},
        warnings: prepared.warnings || [],
        sheetName: prepared.sheetName || "",
      };

      let importedCount = 0;
      let skippedDuplicates = 0;

      try {
        for (let i=0; i<rows.length; i++){
          const r = rows[i];
          const fp = r.fingerprint;
          if (fp && fpMap[fp]){ skippedDuplicates++; continue; }

        // Compute suggestions once per imported row (can be expensive on large batches).
        // Yield occasionally to keep the UI responsive.
        let suggestedAccount = "";
        let suggestedInvoiceId = null;
        let confidence = 0;
        try {
          const sug = suggestCounterAccount(r);
          suggestedAccount = (sug && sug.account && state.accounts?.[sug.account]) ? String(sug.account) : "";
          suggestedInvoiceId = (sug && sug.invoiceId) ? sug.invoiceId : null;
          confidence = clamp01(sug && sug.confidence);
        } catch {}

          const id = crypto.randomUUID();
          const it = {
            id,
            batchId,
            source: src,
            createdAtISO: now,
            dateISO: r.dateISO,
            amount: Math.round((Number(r.amount)||0)*100)/100,
            vat: (()=>{ const v = Number(r.vat); return Number.isFinite(v) ? Math.round(v*100)/100 : null; })(),
            text: clampText(r.text||"", 200),
            ref: clampText(String(r.ref ?? "").trim(), 120),
            // Avoid storing the full raw row payload in state (can easily exceed localStorage quota).
            raw: null,
            status: suggestedAccount ? "matched" : "unmatched",
            suggestedAccount,
            suggestedInvoiceId,
            confidence,
            postedVoucherId: null,
            undoVoucherId: null,
            fingerprint: fp || "",
          };
          items[id] = it;
          if (fp) fpMap[fp] = id;
          importedCount++;

          if (i % 200 === 0) await new Promise(r=> setTimeout(r, 0));
        }
        batches[batchId] = batch;

      // persist settings
      try {
        state.bankImport.settings.lastSource = src;
        if (src === "skattekonto") state.bankImport.settings.defaultTaxAccount = bankAcc;
        else state.bankImport.settings.defaultBankAccount = bankAcc;
      } catch {}

      appendAudit({
        action: "bankimport.import",
        entityType: "bankimport.batch",
        entityId: batchId,
        yearId: state.activeYearId,
        details: { filename: batch.filename, sheetName: batch.sheetName, source: src, accountBank: bankAcc, rowCount: batch.rowCount, importedCount, skippedDuplicates, fileHash: batch.fileHash || "" }
      });

        const persisted = save({ renderAll:false });
        if (!persisted){
          showToast("Importerade till inkorg, men kunde inte spara till webbläsarens lagring. Prova att minska data (t.ex. logotyp), eller använd fil-synk/backup.", 10000);
        }
        showToast(`Importerade ${importedCount} rader. Dubbletter: ${skippedDuplicates}.`, 5500);
        closeModal();
        // switch to inbox tab
        try { activateTab("bank_inbox"); } catch {}
        renderInbox();
      } catch (e){
        console.error(e);
        showToast(e && e.message ? e.message : "Import misslyckades.", 6500);
      } finally {
        importing = false;
        // If modal is still open (error paths), restore button state.
        try { updateModalButtons(); } catch {}
      }
    }

    function ensureBankImportState(){
      if (!state.bankImport || typeof state.bankImport !== "object") state.bankImport = defaultData().bankImport;
      if (!state.bankImport.batches || typeof state.bankImport.batches !== "object") state.bankImport.batches = {};
      if (!state.bankImport.items || typeof state.bankImport.items !== "object") state.bankImport.items = {};
      if (!state.bankImport.fingerprints || typeof state.bankImport.fingerprints !== "object") state.bankImport.fingerprints = {};
      if (!Array.isArray(state.bankImport.rules)) state.bankImport.rules = [];
      if (!state.bankImport.settings || typeof state.bankImport.settings !== "object") state.bankImport.settings = { lastSource:"bank", defaultBankAccount:"", defaultTaxAccount:"" };
    }

    function renderBatchFilter(){
      if (!ui.batchFilter) return;
      const old = ui.batchFilter.value || "";
      const batches = listBatches();
      ui.batchFilter.innerHTML = "";
      const optAll = document.createElement("option");
      optAll.value = "";
      optAll.textContent = "Alla batchar";
      ui.batchFilter.appendChild(optAll);
      for (const b of batches){
        const o = document.createElement("option");
        o.value = b.id;
        const label = `${(b.createdAtISO||b.createdAt||"").slice(0,19).replace("T"," ")} · ${b.source || ""} · ${b.filename || b.fileName || b.id}`;
        o.textContent = label.slice(0, 120);
        ui.batchFilter.appendChild(o);
      }
      if (old && Array.from(ui.batchFilter.options).some(x=>x.value===old)) ui.batchFilter.value = old;
    }

    function statusBadge(item){
      const st = String(item.status||"");
      if (st === "posted"){
        if (item.undoVoucherId) return "posted (undo)";
        return "posted";
      }
      return st || "unmatched";
    }

    function renderInbox(){
      ensureBankImportState();
      renderBatchFilter();
      const items = visibleItems();
      const total = listItems().length;
      const matched = listItems().filter(x=>x.status==="matched").length;
      const posted = listItems().filter(x=>x.status==="posted").length;
      const sel = Array.from(selectedIds).filter(id=> !!getItem(id)).length;
      if (ui.stats) ui.stats.textContent = `Visar ${items.length} · Totalt ${total} · matched ${matched} · posted ${posted} · markerade ${sel}`;

      if (ui.selectAll) ui.selectAll.checked = (items.length > 0) && items.every(x=> selectedIds.has(x.id));
      if (!ui.tbody) return;
      ui.tbody.innerHTML = "";

      for (const it of items){
        const tr = document.createElement("tr");

        const checked = selectedIds.has(it.id);
        const acc = it.suggestedAccount ? accountLabel(it.suggestedAccount) : "";
        const inv = it.suggestedInvoiceId ? "SI:" + String(it.suggestedInvoiceId).slice(0,8) : "";
        const conf = Math.round(clamp01(it.confidence||0) * 100);
        const st = statusBadge(it);

        tr.innerHTML = `
          <td><input type="checkbox" data-act="sel" data-id="${it.id}" ${checked ? "checked" : ""} /></td>
          <td>${escapeHtml(it.dateISO||"")}</td>
          <td style="text-align:right;">${escapeHtml(fmtSEK(Number(it.amount)||0))}</td>
          <td style="text-align:right;">${(()=>{ const v = Number(it.vat); return (Number.isFinite(v) && Math.abs(v) > 0.00001) ? escapeHtml(fmtSEK(v)) : ""; })()}</td>
          <td title="${escapeHtml(it.text||"")}">${escapeHtml(String(it.text||""))}</td>
          <td class="muted small" title="${escapeHtml(String(it.ref ?? ""))}">${escapeHtml(String(it.ref ?? ""))}</td>
          <td>${escapeHtml(st)}</td>
          <td class="muted small" title="${escapeHtml(it.batchId||"")}">${escapeHtml(String(it.batchId||"").slice(0, 8))}</td>
          <td>
            <select data-act="acc" data-id="${it.id}" ${it.status==="posted" ? "disabled" : ""}></select>
          </td>
          <td class="muted small">${escapeHtml(inv)}</td>
          <td style="text-align:right;">${conf}%</td>
          <td>
            <div class="row" style="gap:8px; flex-wrap:wrap;">
              <button class="btn secondary" data-act="post" data-id="${it.id}" ${it.status==="posted" ? "disabled" : ""}>Kontera…</button>
              <button class="btn secondary" data-act="undo" data-id="${it.id}" ${(!it.postedVoucherId || it.undoVoucherId) ? "disabled" : ""}>Ångra</button>
              <button class="btn danger" data-act="del" data-id="${it.id}" ${(it.status==="posted") ? "disabled" : ""}>Radera</button>
            </div>
          </td>
        `;

        ui.tbody.appendChild(tr);

        // populate account select
        const selEl = tr.querySelector('select[data-act="acc"]');
        if (selEl){
          fillAccountSelect(selEl, { includeEmpty: true, emptyLabel: "(ingen)" });
          selEl.value = it.suggestedAccount && state.accounts?.[it.suggestedAccount] ? it.suggestedAccount : "";
        }
      }
    }

    function bankAccountForItem(item){
      try {
        const b = state.bankImport?.batches?.[item.batchId];
        const acc = (b && (b.accountBank || b.bankAccount)) ? String(b.accountBank || b.bankAccount) : (item && item.bankAccount ? String(item.bankAccount) : "");
        if (acc && state.accounts?.[acc]) return acc;
      } catch {}
      // Fallback: best-effort defaults
      const guess = (item && item.source === "skattekonto") ? "1630" : "1930";
      return guess;
    }

    function buildVoucherLines(bankAccount, counterAccount, amount, text){
      const a = Math.round((Number(amount)||0)*100)/100;
      if (!Number.isFinite(a) || Math.abs(a) < 0.00001) return [];
      return [
        { account: String(bankAccount||"").trim(), text: clampText(text||"", 200), amount: a },
        { account: String(counterAccount||"").trim(), text: clampText(text||"", 200), amount: -a },
      ].filter(l=>l.account && Math.abs(l.amount)>0.00001);
    }

    function createVoucherFromItem(item, counterAccount){
      const yearId = String(item.dateISO||"").slice(0,4) || state.activeYearId;
      const date = item.dateISO || todayISO();
      const series = "A";
      const no = nextVerno(yearId, series);
      const sign = clampText((state.company?.defaultSign || "").trim());
      const regDate = todayISO();
      const text = clampText(item.text || "Bankrad", 200);
      const bankAcc = bankAccountForItem(item);
      const lines = buildVoucherLines(bankAcc, counterAccount, item.amount, text);
      const sum = lines.reduce((s,l)=> s + (Number(l.amount)||0), 0);
      if (Math.abs(sum) > 0.00001) throw new Error("Verifikation ej i balans");

      const v = {
        id: crypto.randomUUID(),
        yearId,
        series,
        no,
        date,
        text,
        regDate,
        sign,
        lines,
        correctionOf: null,
        status: "active"
      };
      if (isLockedVoucher(v)) throw new Error("Datum ligger i låst period. Ändra lås eller boka manuellt med annat datum.");

      state.vouchers.push(v);
      state.vouchers.sort((a,b)=> (a.yearId+b.series+a.no+a.date).localeCompare(b.yearId+a.series+b.no+b.date, "sv"));

      appendAudit({
        action: "bankimport.post",
        entityType: "bankimport.item",
        entityId: item.id,
        yearId,
        details: { date: v.date, voucherId: v.id, accountBank: bankAcc, counterAccount, amount: item.amount }
      });

      return v;
    }

    function undoDateForYear(yearId){
      const year = getYear(yearId);
      let d = todayISO();
      if (year && year.start && d < year.start) d = year.start;
      if (year && year.end && d > year.end) d = year.end;
      const until = lockUntilForYear(yearId);
      if (until && d <= until) d = addDays(until, 1);
      if (year && year.end && d > year.end) d = year.end;
      return d;
    }

    function createContraVoucherForVoucher(origVoucherId, item){
      const orig = state.vouchers.find(x=>x.id===origVoucherId);
      if (!orig) throw new Error("Hittar inte originalverifikation.");
      const yearId = orig.yearId;
      const date = undoDateForYear(yearId);
      const series = orig.series || "A";
      const no = nextVerno(yearId, series);
      const sign = clampText((state.company?.defaultSign || "").trim());
      const regDate = todayISO();
      const text = clampText(`Ångring: ${orig.text || (item?.text||"")}`.trim(), 200);
      const lines = (orig.lines||[]).map(l=> ({ account: l.account, text: l.text || "", amount: Math.round(-(Number(l.amount)||0)*100)/100 })).filter(l=>l.account && Math.abs(l.amount)>0.00001);
      const sum = lines.reduce((s,l)=> s + (Number(l.amount)||0), 0);
      if (Math.abs(sum) > 0.00001) throw new Error("Kontra-verifikation ej i balans");
      const v = {
        id: crypto.randomUUID(),
        yearId,
        series,
        no,
        date,
        text,
        regDate,
        sign,
        lines,
        correctionOf: orig.id,
        status: "active"
      };
      if (isLockedVoucher(v)) throw new Error("Ångring hamnar i låst period. Justera lås eller datum.");
      state.vouchers.push(v);
      state.vouchers.sort((a,b)=> (a.yearId+b.series+a.no+a.date).localeCompare(b.yearId+a.series+b.no+b.date, "sv"));
      return v;
    }

    function deleteItem(itemId){
      ensureBankImportState();
      const it = getItem(itemId);
      if (!it) return;
      if (it.status === "posted") return showToast("Kan inte radera bokförd rad. Ångra först.", 5500);
      try {
        // remove fingerprint mapping if it still points to this item
        const fp = it.fingerprint;
        if (fp && state.bankImport.fingerprints && state.bankImport.fingerprints[fp] === it.id) delete state.bankImport.fingerprints[fp];
      } catch {}
      delete state.bankImport.items[itemId];
      selectedIds.delete(itemId);
      save();
      renderInbox();
    }

    async function deleteBatch(){
      ensureBankImportState();
      const batchId = ui.batchFilter ? ui.batchFilter.value : "";
      if (!batchId) return showToast("Välj en batch i filtret först.", 4500);
      const batch = state.bankImport?.batches?.[batchId];
      if (!batch) return;

      const items = listItems().filter(x=>x.batchId===batchId);
      const posted = items.filter(x=>x.status==="posted" && x.postedVoucherId);
      if (posted.length){
        showToast("Batchen innehåller bokförda rader. Ångra bokföring för batch först.", 6500);
        return;
      }

      const ok = await confirmAsync(`Radera batchen?\n\n${batch.filename || batch.fileName || batch.id}\nRader: ${items.length}\n\nDetta påverkar inte bokföringen (inga verifikationer finns i batchen).`, {
        okText: "Radera",
        cancelText: "Avbryt",
        danger: true
      });
      if (!ok) return;

      for (const it of items){
        try {
          const fp = it.fingerprint;
          if (fp && state.bankImport.fingerprints && state.bankImport.fingerprints[fp] === it.id) delete state.bankImport.fingerprints[fp];
        } catch {}
        delete state.bankImport.items[it.id];
        selectedIds.delete(it.id);
      }
      delete state.bankImport.batches[batchId];
      save();
      renderInbox();
      showToast("Batch raderad.", 3000);
    }

    async function undoBatch(){
      ensureBankImportState();
      const batchId = ui.batchFilter ? ui.batchFilter.value : "";
      if (!batchId) return showToast("Välj en batch i filtret först.", 4500);
      const items = listItems().filter(x=>x.batchId===batchId);
      const targets = items.filter(x=>x.status==="posted" && x.postedVoucherId && !x.undoVoucherId);
      if (!targets.length) return showToast("Inga bokförda rader att ångra i batchen.", 4500);

      const ok = await confirmAsync(`Ångra bokföring för batch?\n\nSkapar kontra-verifikationer (append-only).\nRader att ångra: ${targets.length}`, {
        okText: "Ångra",
        cancelText: "Avbryt",
        danger: false
      });
      if (!ok) return;

      let okCount = 0;
      let failCount = 0;
      for (const it of targets){
        try {
          const contra = createContraVoucherForVoucher(it.postedVoucherId, it);
          it.undoVoucherId = contra.id;
          it.undoneAt = new Date().toISOString();
          appendAudit({
            action: "bankimport.undo",
            entityType: "bankimport.item",
            entityId: it.id,
            yearId: String(it.dateISO||"").slice(0,4) || state.activeYearId,
            details: { postedVoucherId: it.postedVoucherId, contraVoucherId: contra.id }
          });
          okCount++;
        } catch (e){
          console.error(e);
          failCount++;
        }
      }
      save();
      try { if (typeof renderVouchers === "function") renderVouchers(); } catch {}
      try { if (lastReportHtml) generateReport(); } catch {}
      renderInbox();
      showToast(`Ångrade ${okCount}. Misslyckade: ${failCount}.`, 6000);
    }

    async function bulkDeleteSelected(){
      const ids = Array.from(selectedIds);
      if (!ids.length) return showToast("Inga rader markerade.", 3000);
      const items = ids.map(getItem).filter(Boolean);
      const posted = items.filter(x=>x.status==="posted");
      if (posted.length) return showToast("Markerade innehåller bokförda rader. Ångra först.", 6500);
      const ok = await confirmAsync(`Radera markerade rader?\n\nAntal: ${items.length}`, { okText:"Radera", cancelText:"Avbryt", danger:true });
      if (!ok) return;
      items.forEach(x=> deleteItem(x.id));
      selectedIds.clear();
      save();
      renderInbox();
    }

    function bulkPostCandidates(){
      const ids = Array.from(selectedIds);
      const items = ids.map(getItem).filter(Boolean);
      const candidates = items.filter(x=> x.status !== "posted" && x.suggestedAccount);
      const blocked = items.filter(x=> x.status === "posted");
      const needs = items.filter(x=> x.status !== "posted" && !x.suggestedAccount);
      return { items, candidates, blocked, needs };
    }

    async function bulkPost(){
      const { items, candidates, blocked, needs } = bulkPostCandidates();
      if (!items.length) return showToast("Inga rader markerade.", 3000);
      if (!candidates.length) return showToast("Inga markerade rader har föreslaget konto. Kontera radvis först.", 6000);

      const totalSum = candidates.reduce((s,x)=> s + (Number(x.amount)||0), 0);
      const summary = `
        <div>Markerade: <b>${items.length}</b></div>
        <div>Kommer bokföras: <b>${candidates.length}</b></div>
        <div class="muted small">Saknar motkonto: ${needs.length} · Redan bokförda: ${blocked.length}</div>
        <div style="margin-top:8px;">Netto (sum belopp): <b>${escapeHtml(fmtSEK(totalSum))}</b></div>
        <div class="muted small" style="margin-top:8px;">Bulk skapar en verifikation per rad (inte en klumpsumma).</div>
      `;
      openBulkModal(summary);
    }

    function performBulkPost(){
      const { candidates } = bulkPostCandidates();
      if (!candidates.length) return;
      let okCount = 0;
      let failCount = 0;
      for (const it of candidates){
        try {
          const v = createVoucherFromItem(it, it.suggestedAccount);
          it.status = "posted";
          it.postedVoucherId = v.id;
          it.postedAt = new Date().toISOString();
          okCount++;
        } catch (e){
          console.error(e);
          failCount++;
        }
      }
      save();
      try { if (typeof renderVouchers === "function") renderVouchers(); } catch {}
      try { if (lastReportHtml) generateReport(); } catch {}
      renderInbox();
      showToast(`Bokförde ${okCount}. Misslyckade: ${failCount}.`, 6000);
    }

    function onInboxClick(e){
      const actEl = e.target && e.target.closest ? e.target.closest("[data-act]") : null;
      if (!actEl) return;
      const act = actEl.dataset.act;
      const id = actEl.dataset.id;
      if (!id) return;
      if (act === "sel"){
        const checked = !!actEl.checked;
        if (checked) selectedIds.add(id);
        else selectedIds.delete(id);
        renderInbox();
        return;
      }
      if (act === "post"){
        openPostModal(id);
        return;
      }
      if (act === "del"){
        deleteItem(id);
        return;
      }
      if (act === "undo"){
        const it = getItem(id);
        if (!it || !it.postedVoucherId || it.undoVoucherId) return;
        confirmAsync("Ångra bokföring? Skapar kontra-verifikation (append-only).", { okText:"Ångra", cancelText:"Avbryt" })
          .then(ok=>{
            if (!ok) return;
            try {
              const contra = createContraVoucherForVoucher(it.postedVoucherId, it);
              it.undoVoucherId = contra.id;
              it.undoneAt = new Date().toISOString();
              appendAudit({ action:"bankimport.undo", entityType:"bankimport.item", entityId: it.id, yearId: String(it.dateISO||"").slice(0,4) || state.activeYearId, details:{ postedVoucherId: it.postedVoucherId, contraVoucherId: contra.id } });
              save();
              try { if (typeof renderVouchers === "function") renderVouchers(); } catch {}
              try { if (lastReportHtml) generateReport(); } catch {}
              renderInbox();
              showToast("Ångrat med kontra-verifikation.", 4500);
            } catch (e){
              console.error(e);
              showToast(e && e.message ? e.message : "Ångring misslyckades.", 6500);
            }
          });
        return;
      }
      if (act === "acc"){
        const it = getItem(id);
        if (!it) return;
        const v = actEl.value || "";
        it.suggestedAccount = (v && state.accounts?.[v]) ? v : "";
        it.confidence = it.suggestedAccount ? 1 : 0;
        if (it.status !== "posted") it.status = it.suggestedAccount ? "matched" : "unmatched";
        softSave();
        renderInbox();
        return;
      }
    }

    function onSelectAllChanged(){
      const items = visibleItems();
      const on = !!(ui.selectAll && ui.selectAll.checked);
      items.forEach(it=>{
        if (on) selectedIds.add(it.id);
        else selectedIds.delete(it.id);
      });
      renderInbox();
    }

    function wire(){
      if (ui.btnOpen1) ui.btnOpen1.addEventListener("click", (e)=>{ e.preventDefault(); openModal(); });
      if (ui.btnOpen2) ui.btnOpen2.addEventListener("click", (e)=>{ e.preventDefault(); openModal(); });
      if (ui.btnRefresh) ui.btnRefresh.addEventListener("click", (e)=>{ e.preventDefault(); renderInbox(); });

      if (ui.btnClose) ui.btnClose.addEventListener("click", (e)=>{ e.preventDefault(); closeModal(); });
      if (ui.btnReset) ui.btnReset.addEventListener("click", (e)=>{ e.preventDefault(); resetModal(false); });
      if (ui.file) ui.file.addEventListener("change", ()=>{ handleFileSelected(); });
      if (ui.source) ui.source.addEventListener("change", ()=>{ fillBankAccountSelect(); scheduleBuildPrepared(); });
      if (ui.bankAccount) ui.bankAccount.addEventListener("change", ()=>{ scheduleBuildPrepared(); });
      if (ui.dateFrom) ui.dateFrom.addEventListener("change", ()=>{ scheduleBuildPrepared(); });
      if (ui.dateTo) ui.dateTo.addEventListener("change", ()=>{ scheduleBuildPrepared(); });
      if (ui.sheet) ui.sheet.addEventListener("change", ()=>{ handleSheetChanged(); });
      [ui.mapDate, ui.mapText, ui.mapAmount, ui.mapVat, ui.mapRef, ui.mapDebit, ui.mapCredit].filter(Boolean).forEach(s=>{
        s.addEventListener("change", ()=> scheduleBuildPrepared());
      });
      if (ui.flipSign) ui.flipSign.addEventListener("change", ()=> scheduleBuildPrepared(0));
      if (ui.riskOk) ui.riskOk.addEventListener("change", ()=> updateModalButtons());
      if (ui.btnRun) ui.btnRun.addEventListener("click", (e)=>{ e.preventDefault(); importIntoInbox(); });

      // inbox handlers
      if (ui.batchFilter) ui.batchFilter.addEventListener("change", ()=> renderInbox());
      if (ui.statusFilter) ui.statusFilter.addEventListener("change", ()=> renderInbox());
      if (ui.selectAll) ui.selectAll.addEventListener("change", ()=> onSelectAllChanged());
      if (ui.tbody) ui.tbody.addEventListener("change", (e)=>{
        // account select and checkbox
        const t = e.target;
        if (!t) return;
        if (t.matches('input[type="checkbox"][data-act="sel"]')) return onInboxClick({ target: t });
        if (t.matches('select[data-act="acc"]')) return onInboxClick({ target: t });
      });
      if (ui.tbody) ui.tbody.addEventListener("click", (e)=>{
        const t = e.target;
        // Avoid double-handling clicks on native controls; the change handler above
        // will handle these and prevent re-render while the dropdown is open.
        if (t && (t.closest('select[data-act="acc"]') || t.closest('input[type="checkbox"][data-act="sel"]'))) return;
        onInboxClick(e);
      });

      if (ui.btnBulkDelete) ui.btnBulkDelete.addEventListener("click", (e)=>{ e.preventDefault(); bulkDeleteSelected(); });
      if (ui.btnDeleteBatch) ui.btnDeleteBatch.addEventListener("click", (e)=>{ e.preventDefault(); deleteBatch(); });
      if (ui.btnUndoBatch) ui.btnUndoBatch.addEventListener("click", (e)=>{ e.preventDefault(); undoBatch(); });
      if (ui.btnBulkPost) ui.btnBulkPost.addEventListener("click", (e)=>{ e.preventDefault(); bulkPost(); });

      // per-row post modal
      if (ui.btnPostClose) ui.btnPostClose.addEventListener("click", (e)=>{ e.preventDefault(); closePostModal(); });
      if (ui.postAccount) ui.postAccount.addEventListener("change", ()=>{
        const ok = !!(ui.postReviewed && ui.postReviewed.checked) && !!(ui.postAccount && ui.postAccount.value);
        if (ui.btnPostCreate) ui.btnPostCreate.disabled = !ok;
      });
      if (ui.postReviewed) ui.postReviewed.addEventListener("change", ()=>{
        const ok = !!(ui.postReviewed && ui.postReviewed.checked) && !!(ui.postAccount && ui.postAccount.value);
        if (ui.btnPostCreate) ui.btnPostCreate.disabled = !ok;
      });
      if (ui.btnPostIgnore) ui.btnPostIgnore.addEventListener("click", (e)=>{
        e.preventDefault();
        const it = getItem(openPostItemId);
        if (!it) return;
        it.status = "ignored";
        it.suggestedAccount = "";
        it.confidence = 0;
        save();
        closePostModal();
        renderInbox();
        showToast("Markerad som ej bokföringshändelse.", 3500);
      });
      if (ui.btnPostCreate) ui.btnPostCreate.addEventListener("click", (e)=>{
        e.preventDefault();
        const it = getItem(openPostItemId);
        if (!it) return;
        const counter = ui.postAccount ? ui.postAccount.value : "";
        if (!counter) return;
        try {
          const v = createVoucherFromItem(it, counter);
          it.status = "posted";
          it.postedVoucherId = v.id;
          it.postedAt = new Date().toISOString();
          save();
          try { if (typeof renderVouchers === "function") renderVouchers(); } catch {}
          try { if (lastReportHtml) generateReport(); } catch {}
          closePostModal();
          renderInbox();
          showToast("Verifikation skapad.", 3500);
        } catch (err){
          console.error(err);
          showToast(err && err.message ? err.message : "Kunde inte skapa verifikation.", 6500);
        }
      });

      // bulk modal
      if (ui.btnBulkClose) ui.btnBulkClose.addEventListener("click", (e)=>{ e.preventDefault(); closeBulkModal(); });
      if (ui.btnBulkCancel) ui.btnBulkCancel.addEventListener("click", (e)=>{ e.preventDefault(); closeBulkModal(); });
      if (ui.bulkReviewed) ui.bulkReviewed.addEventListener("change", ()=>{
        if (ui.btnBulkConfirm) ui.btnBulkConfirm.disabled = !(ui.bulkReviewed && ui.bulkReviewed.checked);
      });
      if (ui.btnBulkConfirm) ui.btnBulkConfirm.addEventListener("click", (e)=>{
        e.preventDefault();
        if (!(ui.bulkReviewed && ui.bulkReviewed.checked)) return;
        closeBulkModal();
        performBulkPost();
      });
    }

    wire();

    return {
      open: openModal,
      renderInbox,
    };
  })();

  function normalizeStdAccountsMap(map){
    const out = {};
    if (!map) return out;
    if (Array.isArray(map)){
      for (const it of map){
        if (!it) continue;
        const no = String(it.no ?? it.account ?? it.konto ?? it.nr ?? "").trim();
        const name = String(it.name ?? it.namn ?? it.title ?? "").trim();
        if (no && name) out[no] = name;
      }
      return out;
    }
    if (typeof map === "object"){
      for (const k of Object.keys(map)){
        const v = map[k];
        const no = String(k || "").trim();
        const name = (typeof v === "string") ? v : (v && typeof v === "object" ? String(v.name ?? v.namn ?? "").trim() : "");
        if (no && name) out[no] = name;
      }
    }
    return out;
  }

  function parseStdAccountsText(txt){
    const s = String(txt || "").trim();
    if (!s) return {};
    // JSON object/array support
    if (s.startsWith("{") || s.startsWith("[")){
      const obj = JSON.parse(s);
      return normalizeStdAccountsMap(obj);
    }

    // CSV / TXT: konto;namn or konto,namn or tab
    const out = {};
    const lines = s.split(/\r?\n/);
    for (const raw of lines){
      const line = raw.trim();
      if (!line) continue;
      if (line.startsWith("#")) continue;
      // detect delimiter
      const delim = line.includes(";") ? ";" : (line.includes("\t") ? "\t" : ",");
      const parts = line.split(delim);
      if (parts.length < 2) continue;
      const no = String(parts[0] || "").trim().replace(/^"|"$/g, "");
      const name = String(parts.slice(1).join(delim) || "").trim().replace(/^"|"$/g, "");
      if (!no || !name) continue;
      // skip header rows
      const low = no.toLowerCase();
      if (low === "konto" || low === "account" || low === "nr") continue;
      out[no] = name;
    }
    return out;
  }

  function applyStdAccountsMapRepair(opts){
    const onlyReplacement = (opts && typeof opts.onlyReplacement === "boolean") ? opts.onlyReplacement : true;
    const stdMap = loadStdAccountsMap();
    if (!stdMap) return { updated: 0 };

    state.accounts = state.accounts || {};
    let updated = 0;
    for (const no of Object.keys(state.accounts)){
      const a = state.accounts[no];
      if (!a) continue;
      const curName = String(a.name || "");
      if (onlyReplacement && !curName.includes("\uFFFD")) continue;

      const stdName = stdMap[String(no)] || stdMap[String(no).trim()];
      if (!stdName) continue;

      const nextName = String(stdName);
      if (curName !== nextName){
        a.name = nextName;
        updated++;
      }
      if (!a.type) a.type = guessTypeFromAccountNo(no);
    }
    return { updated };
  }

  function countReplacementChars(s){
    // U+FFFD replacement character means decoding already lost information.
    return (String(s ?? "").match(/\uFFFD/g) || []).length;
  }

  function decodeWithBestEncoding(buf, preferredEncoding){
    const preferred = String(preferredEncoding || "utf-8").trim() || "utf-8";
    const candidates = [preferred, "windows-1252", "ibm437", "utf-8"].filter((v, i, a)=> a.indexOf(v) === i);
    let best = { enc: preferred, text: "", bad: Number.POSITIVE_INFINITY };
    for (const enc of candidates){
      try {
        const text = new TextDecoder(enc).decode(buf);
        const bad = countReplacementChars(text);
        if (bad < best.bad){
          best = { enc, text, bad };
          if (bad === 0) break;
        }
      } catch (e){
        // ignore unsupported encodings
      }
    }
    return best;
  }

  function extractAccountsFromSieText(txt){
    const imported = {};
    const lines = String(txt || "").split(/\r?\n/);
    for (const rawLine of lines){
      const line = rawLine.trim();
      if (!line || !line.startsWith("#")) continue;
      if (!line.startsWith("#KONTO")) continue;
      const t = sieTokens(line);
      if (t[0] !== "#KONTO" || t.length < 3) continue;
      const acc = String(t[1] || "").trim();
      const name = String(t[2] || "").trim();
      if (acc) imported[acc] = name;
    }
    return imported;
  }

  async function repairAccountNamesFromSieFile(file, preferredEncoding){
    if (!file) return { updated: 0, added: 0, encoding: "", bad: 0 };
    const buf = await file.arrayBuffer();
    const dec = decodeWithBestEncoding(buf, preferredEncoding);
    const imported = extractAccountsFromSieText(dec.text);

    state.accounts = state.accounts || {};
    let updated = 0;
    let added = 0;
    for (const acc of Object.keys(imported)){
      const name = imported[acc];
      if (state.accounts[acc]){
        if (String(state.accounts[acc].name || "") !== name){
          state.accounts[acc].name = name;
          updated++;
        }
        if (!state.accounts[acc].type) state.accounts[acc].type = guessTypeFromAccountNo(acc);
      } else {
        state.accounts[acc] = { name, type: guessTypeFromAccountNo(acc) };
        added++;
      }
    }

    return { updated, added, encoding: dec.enc, bad: dec.bad };
  }

  function renderAccounts(){
    if (!accountsTbody) return;
    state.accounts = state.accounts || {};

    const q = (accountSearch && accountSearch.value ? String(accountSearch.value) : "").trim().toLowerCase();
    const rows = Object.keys(state.accounts)
      .map(no => ({ no, meta: state.accounts[no] || {} }))
      .filter(r => {
        const name = String(r.meta.name || "").toLowerCase();
        if (!q) return true;
        return String(r.no).toLowerCase().includes(q) || name.includes(q);
      })
      .sort((a,b)=> String(a.no).localeCompare(String(b.no), "sv"));

    accountsTbody.innerHTML = "";
    if (!rows.length){
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 4;
      td.className = "muted small";
      td.textContent = q ? "Inga matchande konton." : "Inga konton ännu. Lägg till ett konto eller återställ demo-kontoplan.";
      tr.appendChild(td);
      accountsTbody.appendChild(tr);
      return;
    }

    rows.forEach(r=>{
      const meta = r.meta || {};
      const tr = document.createElement("tr");

      const tdNo = document.createElement("td");
      tdNo.textContent = String(r.no);

      const tdName = document.createElement("td");
      tdName.textContent = String(meta.name || "");

      const tdType = document.createElement("td");
      tdType.textContent = accountTypeLabel(meta.type || guessTypeFromAccountNo(r.no));

      const tdAct = document.createElement("td");
      const btnDel = document.createElement("button");
      btnDel.type = "button";
      btnDel.className = "btn danger";
      btnDel.textContent = "Ta bort";
      btnDel.dataset.act = "del";
      btnDel.dataset.no = String(r.no);
      tdAct.appendChild(btnDel);

      tr.appendChild(tdNo);
      tr.appendChild(tdName);
      tr.appendChild(tdType);
      tr.appendChild(tdAct);
      accountsTbody.appendChild(tr);
    });
  }

  let editingAccountNo = null;
  function setAccountEditMode(no){
    editingAccountNo = no ? String(no) : null;
    if (btnAddAccount) btnAddAccount.textContent = editingAccountNo ? "Spara" : "Lägg till";
    if (aNo) aNo.disabled = !!editingAccountNo;
  }

  function startAccountEdit(no){
    const n = normalizeAccountNo(no);
    if (!n) return;
    const a = state.accounts && state.accounts[n];
    if (!a) return;
    if (aNo) aNo.value = n;
    if (aName) aName.value = String(a.name || "");
    if (aType) aType.value = a.type || guessTypeFromAccountNo(n);
    setAccountEditMode(n);
    try { aName && aName.focus(); } catch {}
  }

  let accountsWired = false;
  function wireAccountEvents(){
    if (accountsWired) return;
    accountsWired = true;

    if (btnAddAccount){
      btnAddAccount.addEventListener("click", (e)=>{
        e.preventDefault();
        const no = normalizeAccountNo(aNo && aNo.value);
        const name = String(aName && aName.value ? aName.value : "").trim();
        if (!no) return showToast("Ange kontonummer.", 3500);
        if (!name) return showToast("Ange kontonamn.", 3500);

        state.accounts = state.accounts || {};
        const type = (aType && aType.value) ? aType.value : guessTypeFromAccountNo(no);
        const existed = !!state.accounts[no];
        state.accounts[no] = { name, type };
        save();
        renderAccounts();

        // Refresh voucher editor account selects if visible
        try { if (typeof renderLines === "function") renderLines(); } catch {}

        setAccountEditMode(null);
        if (aNo) aNo.value = "";
        if (aName) aName.value = "";
        if (aType) aType.value = guessTypeFromAccountNo(no);
        if (aNo) aNo.focus();

        showToast(existed ? "Konto uppdaterat." : "Konto tillagt.", 2500);
      });
    }

    if (accountSearch){
      accountSearch.addEventListener("input", ()=> renderAccounts());
    }

    if (btnResetDemo){
      btnResetDemo.addEventListener("click", async (e)=>{
        e.preventDefault();
        const ok = await confirmAsync("Återställ demo-kontoplan? Detta skriver över din nuvarande kontoplan.", { okText:"Återställ", cancelText:"Avbryt", okKind:"danger" });
        if (!ok) return;
        state.accounts = demoAccounts();
        save();
        renderAccounts();
        try { if (typeof renderLines === "function") renderLines(); } catch {}
        showToast("Demo-kontoplan återställd.", 3500);
      });
    }

    if (btnExportAccountNameTemplate){
      btnExportAccountNameTemplate.addEventListener("click", (e)=>{
        e.preventDefault();
        state.accounts = state.accounts || {};
        const rows = Object.keys(state.accounts)
          .map(no => ({ no: String(no), a: state.accounts[no] || {} }))
          .sort((x,y)=> x.no.localeCompare(y.no, "sv"));

        let csv = "konto;namn;typ\n";
        for (const r of rows){
          csv += [toCsvCell(r.no), toCsvCell(r.a.name || ""), toCsvCell(r.a.type || "")].join(";") + "\n";
        }
        const fname = `kontoplan-mall-${new Date().toISOString().slice(0,10)}.csv`;
        downloadTextFile(fname, csv, "text/csv;charset=utf-8");
        showToast("Mall exporterad. Rätta namn i CSV och importera via Standardlista för att reparera \"�\".", 8000);
      });
    }

    if (stdAccountsFile){
      stdAccountsFile.addEventListener("change", async ()=>{
        const f = stdAccountsFile.files && stdAccountsFile.files[0];
        if (!f) return;
        try {
          const txt = await f.text();
          const map = parseStdAccountsText(txt);
          const keys = Object.keys(map);
          if (!keys.length){
            showToast("Standardlista: ingen data hittades (CSV/JSON).", 6500);
            return;
          }
          const ok = saveStdAccountsMap(map);
          if (!ok){
            showToast("Kunde inte spara standardlistan (localStorage).", 8000);
            return;
          }

          const r = applyStdAccountsMapRepair({ onlyReplacement: true });
          if (r.updated){
            save();
            showToast(`Standardlista laddad (${keys.length} konton). Reparerade ${r.updated} konton med "�".`, 8000);
          } else {
            showToast(`Standardlista laddad (${keys.length} konton). Inga konton med "�" matchade listan.`, 8000);
          }
        } catch (err){
          console.error(err);
          showToast("Standardlista: kunde inte läsa filen. Prova CSV (konto;namn) eller JSON.", 8000);
        } finally {
          stdAccountsFile.value = "";
        }
      });
    }

    if (accountsTbody){
      accountsTbody.addEventListener("click", async (e)=>{
        const b = e.target && e.target.closest ? e.target.closest("button[data-act]") : null;
        if (b){
          const act = b.dataset.act;
          const no = b.dataset.no;
          if (act !== "del" || !no) return;

          // Warn if used in vouchers
          const used = (state.vouchers || []).some(v => (v.lines || []).some(l => String(l.account) === String(no)));
          const msg = used
            ? `Kontot ${no} används i verifikationer. Ta bort ändå? (Det kommer visas som "okänt konto" i historik.)`
            : `Ta bort konto ${no}?`;
          if (!(await confirmAsync(msg, { okText:"Ta bort", cancelText:"Avbryt", okKind:"danger" }))) return;
          delete state.accounts[no];
          save();
          renderAccounts();
          try { if (typeof renderLines === "function") renderLines(); } catch {}
          if (editingAccountNo === String(no)){
            setAccountEditMode(null);
            if (aNo) aNo.value = "";
            if (aName) aName.value = "";
            if (aType) aType.value = guessTypeFromAccountNo(no);
          }
          return;
        }

        // Click row to edit
        const tr = e.target && e.target.closest ? e.target.closest("tr") : null;
        if (!tr) return;
        const firstCell = tr.querySelector("td");
        const no = firstCell ? firstCell.textContent : "";
        const n = normalizeAccountNo(no);
        if (!n) return;
        if (!state.accounts || !state.accounts[n]) return;
        startAccountEdit(n);
      });
    }
  }

  // --- Invoice helpers ---
  const invGrid = document.getElementById("invGrid");
  const invListCard = document.getElementById("invListCard");
  const invYearSelect = document.getElementById("invYearSelect");
  const invoiceList = document.getElementById("invoiceList");
  const invDate = document.getElementById("invDate");
  const invDue = document.getElementById("invDue");
  const invNo = document.getElementById("invNo");
  const invRef = document.getElementById("invRef");
  const invCustomerBox = document.getElementById("invCustomerBox");
  const invLinesTbody = document.getElementById("invLinesTbody");
  const invTotal = document.getElementById("invTotal");
  const invRounding = document.getElementById("invRounding");
  const btnInvToggleList = document.getElementById("btnInvToggleList");
  const btnInvNew = document.getElementById("btnInvNew");
  const btnInvSave = document.getElementById("btnInvSave");
  const btnInvClear = document.getElementById("btnInvClear");
  const btnInvAddItem = document.getElementById("btnInvAddItem");
  const btnInvAddComment = document.getElementById("btnInvAddComment");
  const btnInvPickCustomer = document.getElementById("btnInvPickCustomer");
  const btnInvPrint = document.getElementById("btnInvPrint");
  const btnInvToVoucher = document.getElementById("btnInvToVoucher");
  const btnInvRefresh = document.getElementById("btnInvRefresh");

  let invListCollapsed = false;
  function setInvoiceListCollapsed(collapsed){
    invListCollapsed = !!collapsed;
    if (invListCard) invListCard.hidden = invListCollapsed;
    if (invGrid){
      if (invListCollapsed) invGrid.classList.remove("two");
      else invGrid.classList.add("two");
    }
    if (btnInvToggleList) btnInvToggleList.textContent = invListCollapsed ? "Visa lista" : "Dölj lista";
  }

  const customerDialog = document.getElementById("customerDialog");
  const btnCustomerClose = document.getElementById("btnCustomerClose");
  const btnCustomerSave = document.getElementById("btnCustomerSave");
  const customerList = document.getElementById("customerList");
  const custName = document.getElementById("custName");
  const custAddr = document.getElementById("custAddr");
  const custEmail = document.getElementById("custEmail");
  const custOrgnr = document.getElementById("custOrgnr");
  // Customer registry (tab)
  const custEditId = document.getElementById("custEditId");
  const custRegName = document.getElementById("custRegName");
  const custRegAddr = document.getElementById("custRegAddr");
  const custRegEmail = document.getElementById("custRegEmail");
  const custRegOrgnr = document.getElementById("custRegOrgnr");
  const custSearch = document.getElementById("custSearch");
  const customersList = document.getElementById("customersList");
  const btnCustNew = document.getElementById("btnCustNew");
  const btnCustSave = document.getElementById("btnCustSave");
  const btnCustRefresh = document.getElementById("btnCustRefresh");

  // Supplier registry (tab)
  const supEditId = document.getElementById("supEditId");
  const supRegName = document.getElementById("supRegName");
  const supRegAddr = document.getElementById("supRegAddr");
  const supRegEmail = document.getElementById("supRegEmail");
  const supRegOrgnr = document.getElementById("supRegOrgnr");
  const supRegPayout = document.getElementById("supRegPayout");
  const supSearch = document.getElementById("supSearch");
  const suppliersList = document.getElementById("suppliersList");
  const btnSupNew = document.getElementById("btnSupNew");
  const btnSupSave = document.getElementById("btnSupSave");
  const btnSupRefresh = document.getElementById("btnSupRefresh");

  // Supplier invoices (tab)
  const siYearSelect = document.getElementById("siYearSelect");
  const supplierInvoiceList = document.getElementById("supplierInvoiceList");
  const siEditId = document.getElementById("siEditId");
  const siDate = document.getElementById("siDate");
  const siDue = document.getElementById("siDue");
  const siInvoiceNo = document.getElementById("siInvoiceNo");
  const siOcr = document.getElementById("siOcr");
  const siSeries = document.getElementById("siSeries");
  const siSupplierSelect = document.getElementById("siSupplierSelect");
  const siSupplierName = document.getElementById("siSupplierName");
  const siSupplierOrgnr = document.getElementById("siSupplierOrgnr");
  const siSupplierEmail = document.getElementById("siSupplierEmail");
  const siSupplierPayout = document.getElementById("siSupplierPayout");
  const siGross = document.getElementById("siGross");
  const siVat = document.getElementById("siVat");
  const siNet = document.getElementById("siNet");
  const siExpenseAcc = document.getElementById("siExpenseAcc");
  const siVatAcc = document.getElementById("siVatAcc");
  const siLiabAcc = document.getElementById("siLiabAcc");
  const siFiles = document.getElementById("siFiles");
  const siUnderlagList = document.getElementById("siUnderlagList");
  const btnSiNew = document.getElementById("btnSiNew");
  const btnSiSave = document.getElementById("btnSiSave");
  const btnSiToVoucher = document.getElementById("btnSiToVoucher");
  const btnSiRefresh = document.getElementById("btnSiRefresh");

  // Supplier invoice OCR (offline, via Tesseract.js)
  const siOcrPanel = document.getElementById("siOcrPanel");
  const siOcrStatus = document.getElementById("siOcrStatus");
  const siOcrFileInfo = document.getElementById("siOcrFileInfo");
  const siOcrLang = document.getElementById("siOcrLang");
  const siOcrPdfPages = document.getElementById("siOcrPdfPages");
  const btnSiOcrRun = document.getElementById("btnSiOcrRun");
  const btnSiOcrApply = document.getElementById("btnSiOcrApply");
  const btnSiOcrDiscard = document.getElementById("btnSiOcrDiscard");
  const siOcrFieldsTbody = document.getElementById("siOcrFieldsTbody");
  const siOcrText = document.getElementById("siOcrText");

  let siOcrCtx = { underlagId: null, lang: "swe+eng", pdfPages: "1", fields: {}, text: "", textSha256: "" };
  let currentSiOcrMeta = null;


  let editingSupplierInvoiceId = null;

  let editingInvoiceId = null;
  let invCustomerId = null;
  let invLines = [];

  function addDays(dateIso, days){
    const d = new Date(dateIso + "T00:00:00");
    d.setDate(d.getDate() + days);
    const pad = (n)=> String(n).padStart(2,"0");
    return d.getFullYear() + "-" + pad(d.getMonth()+1) + "-" + pad(d.getDate());
  }

  function nextInvoiceNo(yearId){
    const nums = (state.invoices||[])
      .filter(i => i.yearId === yearId)
      .map(i => Number(i.no))
      .filter(n => Number.isFinite(n));
    const max = nums.length ? Math.max(...nums) : 1000;
    return String(max + 1);
  }

  function newInvoice(){
    editingInvoiceId = null;
    invCustomerId = null;
    invDate.value = todayISO();
    invDue.value = addDays(invDate.value, (state.company.payDays||30));
    invNo.value = "";
    invRef.value = "";
    invLines = [ { kind:"item", desc:"", qty:"1", price:"", vat:"25" } ];
    renderInvoiceCustomer();
    renderInvoiceLines();
    updateInvoiceTotals();
  }

  function renderInvoiceCustomer(){
    if (!invCustomerBox) return;
    if (!invCustomerId){
      invCustomerBox.textContent = "Ingen kund vald.";
      return;
    }
    const c = state.customers?.[invCustomerId];
    if (!c){
      invCustomerBox.textContent = "Ingen kund vald.";
      invCustomerId = null;
      return;
    }
    invCustomerBox.innerHTML = `<div style="font-weight:800;">${escapeHtml(c.name||"(namn)")}</div>
      <div class="muted small">${escapeHtml(c.addr||"")}</div>
      <div class="muted small">${escapeHtml(c.email||"")}${c.orgnr?" · "+escapeHtml(c.orgnr):""}</div>`;
  }

  function lineAmount(ln){
    if (ln.kind !== "item") return { net:0, vat:0, gross:0 };
    const qty = Math.max(0, parseMoney(ln.qty));
    const price = Math.max(0, parseMoney(ln.price));
    const vatRate = Math.max(0, parseMoney(ln.vat));
    const net = Math.round(qty * price * 100) / 100;
    const vat = Math.round(net * (vatRate/100) * 100) / 100;
    const gross = Math.round((net + vat) * 100) / 100;
    return { net, vat, gross };
  }

  function updateInvoiceTotals(){
    let net = 0, vat = 0;
    for (const ln of invLines){
      const a = lineAmount(ln);
      net += a.net;
      vat += a.vat;
    }
    net = Math.round(net*100)/100;
    vat = Math.round(vat*100)/100;
    // "Öresavrundning" – round to nearest 0.01 already; keep placeholder for future cash rounding.
    const gross = Math.round((net+vat)*100)/100;

    if (invTotal) invTotal.textContent = fmtSEK(gross) + " " + (state.company.currency || "SEK");
    if (invRounding) invRounding.textContent = fmtSEK(0);

    const ok = !!invCustomerId && invLines.some(l=>l.kind==="item" && lineAmount(l).net>0);
    if (btnInvSave) btnInvSave.disabled = !ok;
    if (btnInvPrint) btnInvPrint.disabled = !ok;
    if (btnInvToVoucher) btnInvToVoucher.disabled = !ok;
  }

  function renderInvoiceLines(){
    if (!invLinesTbody) return;
    invLinesTbody.innerHTML = "";
    invLines.forEach((ln, idx)=>{
      const tr = document.createElement("tr");

      const tdSum = document.createElement("td"); tdSum.className = "right";

      const tdDesc = document.createElement("td");
      const inpDesc = document.createElement("input");
      inpDesc.value = ln.desc || "";
      inpDesc.placeholder = (ln.kind === "comment") ? "Kommentar…" : "Artikel / tjänst…";
      inpDesc.addEventListener("input", ()=>{ ln.desc = inpDesc.value; updateInvoiceTotals(); });
      tdDesc.appendChild(inpDesc);

      const tdQty = document.createElement("td"); tdQty.className = "right";
      const inpQty = document.createElement("input");
      inpQty.inputMode = "decimal";
      inpQty.value = ln.kind === "item" ? (ln.qty ?? "1") : "";
      inpQty.placeholder = ln.kind === "item" ? "1" : "–";
      inpQty.disabled = ln.kind !== "item";
      inpQty.addEventListener("input", ()=>{
        ln.qty = inpQty.value;
        updateInvoiceTotals();
        const a = lineAmount(ln);
        tdSum.textContent = ln.kind === "item" ? fmtSEK(a.gross) : "";
      });
      tdQty.appendChild(inpQty);

      const tdPrice = document.createElement("td"); tdPrice.className = "right";
      const inpPrice = document.createElement("input");
      inpPrice.inputMode = "decimal";
      inpPrice.value = ln.kind === "item" ? (ln.price ?? "") : "";
      inpPrice.placeholder = ln.kind === "item" ? "0" : "–";
      inpPrice.disabled = ln.kind !== "item";
      inpPrice.addEventListener("input", ()=>{
        ln.price = inpPrice.value;
        updateInvoiceTotals();
        const a = lineAmount(ln);
        tdSum.textContent = ln.kind === "item" ? fmtSEK(a.gross) : "";
      });
      tdPrice.appendChild(inpPrice);

      const tdVat = document.createElement("td"); tdVat.className = "right";
      const inpVat = document.createElement("input");
      inpVat.inputMode = "decimal";
      inpVat.value = ln.kind === "item" ? (ln.vat ?? "25") : "";
      inpVat.placeholder = ln.kind === "item" ? "25" : "–";
      inpVat.disabled = ln.kind !== "item";
      inpVat.addEventListener("input", ()=>{
        ln.vat = inpVat.value;
        updateInvoiceTotals();
        const a = lineAmount(ln);
        tdSum.textContent = ln.kind === "item" ? fmtSEK(a.gross) : "";
      });
      tdVat.appendChild(inpVat);

      {
        const a = lineAmount(ln);
        tdSum.textContent = ln.kind === "item" ? fmtSEK(a.gross) : "";
      }

      const tdX = document.createElement("td");
      const bx = document.createElement("button");
      bx.className = "btn secondary";
      bx.textContent = "✕";
      bx.addEventListener("click", ()=>{
        invLines.splice(idx,1);
        if (invLines.length===0) invLines.push({ kind:"item", desc:"", qty:"1", price:"", vat:"25" });
        renderInvoiceLines();
        updateInvoiceTotals();
      });
      tdX.appendChild(bx);

      tr.appendChild(tdDesc);
      tr.appendChild(tdQty);
      tr.appendChild(tdPrice);
      tr.appendChild(tdVat);
      tr.appendChild(tdSum);
      tr.appendChild(tdX);
      invLinesTbody.appendChild(tr);
    });
  }

  function invoiceYearId(){
    const y = (invYearSelect && invYearSelect.value) || state.activeYearId;
    return y;
  }

  function saveInvoice(){
    const yearId = invoiceYearId();
    const date = invDate.value || todayISO();
    const due = invDue.value || addDays(date, (state.company.payDays||30));
    const no = (invNo.value || "").trim() || nextInvoiceNo(yearId);
    const ref = clampText(invRef.value || "");

    const lines = invLines.map(l => ({
      kind: l.kind,
      desc: clampText(l.desc || "", 200),
      qty: l.kind === "item" ? Math.round(parseMoney(l.qty)*100)/100 : 0,
      price: l.kind === "item" ? Math.round(parseMoney(l.price)*100)/100 : 0,
      vat: l.kind === "item" ? Math.round(parseMoney(l.vat)*100)/100 : 0
    }));

    const inv = {
      id: editingInvoiceId ?? crypto.randomUUID(),
      yearId,
      no,
      date,
      due,
      customerId: invCustomerId,
      ref,
      lines
    };

    const idx = (state.invoices||[]).findIndex(x=>x.id===inv.id);
    if (idx>=0) state.invoices[idx] = inv; else state.invoices.push(inv);
    state.invoices.sort((a,b)=> (a.yearId+a.no+a.date).localeCompare(b.yearId+b.no+b.date, "sv"));

    save();
    newInvoice();
    renderInvoices();
  }

  function invoiceTotals(inv){
    let net=0, vat=0;
    for (const l of (inv.lines||[])){
      if (l.kind !== "item") continue;
      const n = Math.round((Number(l.qty)||0) * (Number(l.price)||0) * 100)/100;
      const v = Math.round(n * ((Number(l.vat)||0)/100) * 100)/100;
      net += n; vat += v;
    }
    net = Math.round(net*100)/100;
    vat = Math.round(vat*100)/100;
    const gross = Math.round((net+vat)*100)/100;
    return { net, vat, gross };
  }

  function renderInvoices(){
    // keep year selectors in sync
    fillYearSelectors();
    if (invYearSelect) invYearSelect.value = invYearSelect.value || state.activeYearId;

    const yid = (invYearSelect && invYearSelect.value) || state.activeYearId;
    const list = (state.invoices||[]).filter(i=>i.yearId===yid).slice().sort((a,b)=> (a.no+a.date).localeCompare(b.no+b.date, "sv"));

    if (invoiceList){
      invoiceList.innerHTML = "";
      if (!list.length){
        invoiceList.innerHTML = `<div class="muted small">Inga fakturor i detta år ännu.</div>`;
      } else {
        list.forEach(inv=>{
          const c = state.customers?.[inv.customerId];
          const tot = invoiceTotals(inv);
          const div = document.createElement("div");
          div.className = "item";
          div.innerHTML = `
            <div class="top">
              <div>
                <div class="title">Faktura #${escapeHtml(inv.no)} · ${escapeHtml(inv.date)} · ${escapeHtml(c?.name || "(kund)")}</div>
                <div class="meta">Förfaller ${escapeHtml(inv.due)} · Totalt ${fmtSEK(tot.gross)} ${escapeHtml(state.company.currency||"SEK")}</div>
              </div>
              <div class="row">
                <button class="btn secondary" data-act="edit" data-id="${inv.id}">Öppna</button>
                <button class="btn secondary" data-act="print" data-id="${inv.id}">Skriv ut</button>
                <button class="btn danger" data-act="del" data-id="${inv.id}">Ta bort</button>
              </div>
            </div>
          `;
          div.addEventListener("click", async (e)=>{
            const b = e.target.closest("button");
            if (!b) return;
            const id = b.dataset.id;
            const act = b.dataset.act;
            if (act==="edit") loadInvoiceToEditor(id);
            if (act==="print") printInvoice(id);
            if (act==="del") await deleteInvoice(id);
          });
          invoiceList.appendChild(div);
        });
      }
    }

    updateInvoiceTotals();
  }

  function loadInvoiceToEditor(id){
    const inv = (state.invoices||[]).find(x=>x.id===id);
    if (!inv) return;
    editingInvoiceId = inv.id;
    if (invYearSelect) invYearSelect.value = inv.yearId;
    invDate.value = inv.date;
    invDue.value = inv.due;
    invNo.value = inv.no;
    invRef.value = inv.ref || "";
    invCustomerId = inv.customerId || null;
    invLines = (inv.lines||[]).map(l => ({
      kind: l.kind || "item",
      desc: l.desc || "",
      qty: (l.kind==="item") ? String(l.qty ?? "1") : "",
      price: (l.kind==="item") ? String(l.price ?? "") : "",
      vat: (l.kind==="item") ? String(l.vat ?? "25") : ""
    }));
    if (!invLines.length) invLines = [ { kind:"item", desc:"", qty:"1", price:"", vat:"25" } ];
    renderInvoiceCustomer();
    renderInvoiceLines();
    updateInvoiceTotals();
  }

  async function deleteInvoice(id){
    if (!(await confirmAsync("Ta bort fakturan?"))) return;
    state.invoices = (state.invoices||[]).filter(i=>i.id!==id);
    save();
    renderInvoices();
  }

  function printInvoice(id){
    const inv = (state.invoices||[]).find(x=>x.id===id);
    if (!inv) return;
    const c = state.customers?.[inv.customerId] || {};
    const tot = invoiceTotals(inv);

    const rows = (inv.lines||[]).map(l=>{
      if (l.kind !== "item"){
        return `<tr><td colspan="5" style="padding:8px 0; color:#666;">${escapeHtml(l.desc||"")}</td></tr>`;
      }
      const net = Math.round((Number(l.qty)||0)*(Number(l.price)||0)*100)/100;
      const vat = Math.round(net*((Number(l.vat)||0)/100)*100)/100;
      const gross = Math.round((net+vat)*100)/100;
      return `<tr>
        <td>${escapeHtml(l.desc||"")}</td>
        <td style="text-align:right;">${(Number(l.qty)||0)}</td>
        <td style="text-align:right;">${fmtSEK(Number(l.price)||0)}</td>
        <td style="text-align:right;">${Number(l.vat)||0}%</td>
        <td style="text-align:right;">${fmtSEK(gross)}</td>
      </tr>`;
    }).join("");

    const html = `<!doctype html><html><head><meta charset="utf-8" />
      <title>Faktura ${escapeHtml(inv.no)}</title>
      <style>
        body{ font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; padding:24px; color:#111; }
        h1{ margin:0 0 8px 0; }
        .muted{ color:#555; }
        .top{ display:flex; justify-content:space-between; gap:20px; flex-wrap:wrap; align-items:flex-start; }
        .seller{ text-align:right; min-width:260px; }
        .logo{ max-height:72px; max-width:260px; object-fit:contain; }
        .box{ border:1px solid #ddd; border-radius:12px; padding:12px; background:#fafafa; }
        table{ width:100%; border-collapse:collapse; margin-top:16px; }
        th,td{ border-bottom:1px solid #ddd; padding:8px 6px; }
        th{ text-align:left; }
        .sum{ margin-top:12px; display:flex; justify-content:flex-end; }
        .sum div{ min-width:300px; }
        .paygrid{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:14px; }
        @media (max-width: 700px){ .paygrid{ grid-template-columns: 1fr; } .seller{ text-align:left; } }
        .kv{ display:flex; justify-content:space-between; gap:12px; }
        .footer{ margin-top:18px; font-size:12px; color:#555; white-space:pre-wrap; }
      </style></head><body>
      <div class="top">
        <div>
          ${state.company.logoDataUrl?`<img class="logo" alt="Logotyp" src="${state.company.logoDataUrl}">`:""}
          <h1>Faktura #${escapeHtml(inv.no)}</h1>
          <div class="muted">Fakturadatum: ${escapeHtml(inv.date)} · Förfallodatum: ${escapeHtml(inv.due)}</div>
          ${inv.ref?`<div class="muted">Referens: ${escapeHtml(inv.ref)}</div>`:""}
          ${state.company.invoiceNote?`<div class="muted" style="margin-top:6px;">${escapeHtml(state.company.invoiceNote)}</div>`:""}
        </div>
        <div class="seller">
          <div style="font-weight:800;">${escapeHtml(state.company.name||"")}</div>
          ${state.company.orgnr?`<div class="muted">Org.nr: ${escapeHtml(state.company.orgnr)}</div>`:""}
          ${state.company.vat?`<div class="muted">Momsreg.nr: ${escapeHtml(state.company.vat)}</div>`:""}
          ${[state.company.addr, [state.company.zip, state.company.city].filter(Boolean).join(" "), state.company.country].filter(x=>x&&String(x).trim()).map(x=>`<div class="muted">${escapeHtml(x)}</div>`).join("")}
          ${state.company.email?`<div class="muted">${escapeHtml(state.company.email)}</div>`:""}
          ${state.company.phone?`<div class="muted">${escapeHtml(state.company.phone)}</div>`:""}
          ${state.company.web?`<div class="muted">${escapeHtml(state.company.web)}</div>`:""}
        </div>
      </div>

      <div style="margin-top:18px;">
        <div class="muted">Kund</div>
        <div style="font-weight:800;">${escapeHtml(c.name||"")}</div>
        <div class="muted">${escapeHtml(c.addr||"")}</div>
        ${c.orgnr?`<div class="muted">Org.nr: ${escapeHtml(c.orgnr)}</div>`:""}
        ${c.email?`<div class="muted">${escapeHtml(c.email)}</div>`:""}
      </div>

      <table>
        <thead><tr><th>Rad</th><th style="text-align:right;">Antal</th><th style="text-align:right;">Á-pris</th><th style="text-align:right;">Moms</th><th style="text-align:right;">Belopp</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>

      <div class="sum"><div>
        <div class="kv"><span>Summa exkl. moms</span><span>${fmtSEK(tot.net)} ${escapeHtml(state.company.currency||"SEK")}</span></div>
        <div class="kv"><span>Moms</span><span>${fmtSEK(tot.vat)} ${escapeHtml(state.company.currency||"SEK")}</span></div>
        <div class="kv" style="font-weight:900; font-size:18px;"><span>Att betala</span><span>${fmtSEK(tot.gross)} ${escapeHtml(state.company.currency||"SEK")}</span></div>
      </div></div>

      <div class="paygrid">
        <div class="box">
          <div style="font-weight:800; margin-bottom:6px;">Betalningsuppgifter</div>
          ${state.company.bankgiro?`<div class="kv"><span>Bankgiro</span><span>${escapeHtml(state.company.bankgiro)}</span></div>`:""}
          ${state.company.plusgiro?`<div class="kv"><span>Plusgiro</span><span>${escapeHtml(state.company.plusgiro)}</span></div>`:""}
          ${state.company.swishPhone?`<div class="kv"><span>Swish</span><span>${escapeHtml(state.company.swishPhone)}</span></div>`:""}
          ${state.company.bankAccountNo?`<div class="kv"><span>Bankkonto</span><span>${escapeHtml(state.company.bankAccountNo)}</span></div>`:""}
          ${state.company.iban?`<div class="kv"><span>IBAN</span><span>${escapeHtml(state.company.iban)}</span></div>`:""}
          ${state.company.swift?`<div class="kv"><span>SWIFT/BIC</span><span>${escapeHtml(state.company.swift)}</span></div>`:""}
          <div class="kv"><span>Referens/OCR</span><span>${escapeHtml(inv.no)}</span></div>
        </div>
        <div class="box">
          <div style="font-weight:800; margin-bottom:6px;">Villkor</div>
          <div class="kv"><span>Förfallodatum</span><span>${escapeHtml(inv.due)}</span></div>
          <div class="kv"><span>Belopp</span><span>${fmtSEK(tot.gross)} ${escapeHtml(state.company.currency||"SEK")}</span></div>
          ${state.company.payDays?`<div class="muted" style="margin-top:6px;">Betalvillkor: ${escapeHtml(String(state.company.payDays))} dagar</div>`:""}
        </div>
      </div>

      ${state.company.invoiceFooter?`<div class="footer">${escapeHtml(state.company.invoiceFooter)}</div>`:""}

      <script>window.onload=()=>window.print();<\/script>

      </body></html>`;

    const w = window.open("", "_blank");
    if (!w) return showToast("Popup blockerad. Tillåt popup för att skriva ut.", 6000);
    w.document.open();
    w.document.write(html);
    w.document.close();
  }

  function createVoucherFromInvoice(){
    // super-enkel bokning: 1510 Debet, 3001 Kredit (netto), 2611 Kredit (moms)
    if (!invCustomerId) return;
    const yearId = invoiceYearId();
    const date = invDate.value || todayISO();
    const no = nextVerno(yearId, "F");

    const tmp = {
      lines: invLines.map(l=>({kind:l.kind, qty:parseMoney(l.qty), price:parseMoney(l.price), vat:parseMoney(l.vat)}))
    };
    let net=0, vat=0;
    for (const l of tmp.lines){
      if (l.kind!=="item") continue;
      const n = Math.round((l.qty||0)*(l.price||0)*100)/100;
      const v = Math.round(n*((l.vat||0)/100)*100)/100;
      net += n; vat += v;
    }
    net = Math.round(net*100)/100;
    vat = Math.round(vat*100)/100;
    const gross = Math.round((net+vat)*100)/100;
    if (!(gross>0)) return;

    // ensure accounts exist
    if (!state.accounts["1510"]) state.accounts["1510"] = { name:"Kundfordringar", type:"asset" };
    if (!state.accounts["3001"]) state.accounts["3001"] = { name:"Försäljning", type:"income" };
    if (!state.accounts["2611"]) state.accounts["2611"] = { name:"Utgående moms", type:"liability" };

    const vv = {
      id: crypto.randomUUID(),
      yearId,
      series: "F",
      no,
      date,
      text: clampText(`Faktura ${invNo.value||""}`.trim() || "Faktura"),
      regDate: todayISO(),
      sign: state.company.defaultSign || "",
      lines: [
        { account:"1510", text:"Faktura", amount: +gross },
        { account:"3001", text:"Försäljning", amount: -net },
        { account:"2611", text:"Moms", amount: -vat }
      ].filter(l=>Math.abs(l.amount)>0.00001),
      correctionOf: null,
      status: "active"
    };
    state.vouchers.push(vv);
    appendAudit({ action:"voucher.create", actor: vv.sign || undefined, entityType:"voucher", entityId: vv.id, yearId, details:{ after: summarizeVoucher(vv), source:"invoice" } });

    state.vouchers.sort((a,b)=> (a.yearId+b.series+a.no+a.date).localeCompare(b.yearId+b.series+b.no+b.date, "sv"));
    save();
    showToast("Skapade verifikation (serie F). Kontrollera konton och moms innan du använder skarpt.", 6500);
  }

  function openCustomerDialog(){
    if (!customerDialog) return;
    custName.value = ""; custAddr.value = ""; custEmail.value = ""; custOrgnr.value = "";
    renderCustomerList();
    customerDialog.showModal();
  }

  function closeCustomerDialog(){
    if (!customerDialog) return;
    customerDialog.close();
  }

  function renderCustomerList(){
    if (!customerList) return;
    customerList.innerHTML = "";
    const keys = Object.keys(state.customers||{}).sort((a,b)=> (state.customers[a]?.name||"").localeCompare(state.customers[b]?.name||"", "sv"));
    if (!keys.length){
      customerList.innerHTML = `<div class="muted small">Inga kunder sparade än.</div>`;
      return;
    }
    keys.forEach(id=>{
      const c = state.customers[id];
      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `
        <div class="top">
          <div>
            <div class="title">${escapeHtml(c.name||"(namn)")}</div>
            <div class="meta">${escapeHtml(c.addr||"")}</div>
          </div>
          <div class="row">
            <button class="btn" data-pick="${id}">Välj</button>
            <button class="btn danger" data-del="${id}">Ta bort</button>
          </div>
        </div>`;
      div.addEventListener("click", async (e)=>{
        const b = e.target.closest("button");
        if (!b) return;
        if (b.dataset.pick){
          invCustomerId = b.dataset.pick;
          renderInvoiceCustomer();
          updateInvoiceTotals();
          closeCustomerDialog();
        }
        if (b.dataset.del){
          if (!(await confirmAsync("Ta bort kunden?"))) return;
          delete state.customers[b.dataset.del];
          if (invCustomerId === b.dataset.del) invCustomerId = null;
          save();
          renderCustomerList();
          renderInvoiceCustomer();
          updateInvoiceTotals();
        }
      });
      customerList.appendChild(div);
    });
  }

  function saveCustomerAndPick(){
    const name = (custName.value||"").trim();
    if (!name) return showToast("Ange kundnamn.", 3500);
    const c = {
      name,
      addr: (custAddr.value||"").trim(),
      email: (custEmail.value||"").trim(),
      orgnr: (custOrgnr.value||"").trim()
    };
    const id = crypto.randomUUID();
    if (!state.customers) state.customers = {};
    state.customers[id] = c;
    invCustomerId = id;
    save();
    renderInvoiceCustomer();
    updateInvoiceTotals();
    closeCustomerDialog();
  }
  // --- Customer registry (tab) ---
  function resetCustomerEditor(){
    if (custEditId) custEditId.value = "";
    if (custRegName) custRegName.value = "";
    if (custRegAddr) custRegAddr.value = "";
    if (custRegEmail) custRegEmail.value = "";
    if (custRegOrgnr) custRegOrgnr.value = "";
  }

  function loadCustomerToEditor(id){
    const c = state.customers?.[id];
    if (!c) return;
    if (custEditId) custEditId.value = id;
    if (custRegName) custRegName.value = c.name || "";
    if (custRegAddr) custRegAddr.value = c.addr || "";
    if (custRegEmail) custRegEmail.value = c.email || "";
    if (custRegOrgnr) custRegOrgnr.value = c.orgnr || "";
  }

  function saveCustomerFromRegistry(){
    const name = (custRegName?.value || "").trim();
    if (!name) return showToast("Ange kundnamn.", 3500);
    const c = {
      name,
      addr: (custRegAddr?.value || "").trim(),
      email: (custRegEmail?.value || "").trim(),
      orgnr: (custRegOrgnr?.value || "").trim()
    };
    const id = (custEditId?.value || "").trim() || crypto.randomUUID();
    state.customers = state.customers || {};
    state.customers[id] = c;
    save();
    // keep invoice editor in sync if it was the same customer
    if (invCustomerId === id) renderInvoiceCustomer();
    updateInvoiceTotals();
    renderCustomers();
    loadCustomerToEditor(id);
  }

  async function deleteCustomer(id){
    const used = (state.invoices||[]).some(inv => inv.customerId === id);
    const msg = used
      ? "Kunden används i minst en kundfaktura. Ta bort ändå? (Kundfakturor kommer visa '(kund)')"
      : "Ta bort kunden?";
    if (!(await confirmAsync(msg))) return;

    delete state.customers[id];
    if (invCustomerId === id) invCustomerId = null;
    save();
    renderCustomers();
    renderInvoiceCustomer();
    updateInvoiceTotals();
    resetCustomerEditor();
  }

  function renderCustomers(){
    if (!customersList) return;
    const q = (custSearch?.value || "").trim().toLowerCase();
    const keys = Object.keys(state.customers||{})
      .sort((a,b)=> (state.customers[a]?.name||"").localeCompare(state.customers[b]?.name||"", "sv"));

    customersList.innerHTML = "";
    if (!keys.length){
      customersList.innerHTML = `<div class="muted small">Inga kunder sparade än.</div>`;
      return;
    }

    keys.forEach(id=>{
      const c = state.customers[id];
      const hay = `${c.name||""} ${c.addr||""} ${c.email||""} ${c.orgnr||""}`.toLowerCase();
      if (q && !hay.includes(q)) return;

      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `
        <div class="top">
          <div>
            <div class="title">${escapeHtml(c.name||"(namn)")}</div>
            <div class="meta">${escapeHtml(c.addr||"")}</div>
            <div class="meta">${escapeHtml(c.email||"")}${c.orgnr?(" · "+escapeHtml(c.orgnr)):""}</div>
          </div>
          <div class="row">
            <button class="btn secondary" data-act="edit" data-id="${id}">Redigera</button>
            <button class="btn danger" data-act="del" data-id="${id}">Ta bort</button>
          </div>
        </div>
      `;
      div.addEventListener("click", async (e)=>{
        const b = e.target.closest("button");
        if (!b) return;
        const act = b.dataset.act;
        const cid = b.dataset.id;
        if (act==="edit"){ loadCustomerToEditor(cid); }
        if (act==="del"){ await deleteCustomer(cid); }
      });
      customersList.appendChild(div);
    });
  }

  // --- Supplier registry (tab) ---
  function resetSupplierEditor(){
    if (supEditId) supEditId.value = "";
    if (supRegName) supRegName.value = "";
    if (supRegAddr) supRegAddr.value = "";
    if (supRegEmail) supRegEmail.value = "";
    if (supRegOrgnr) supRegOrgnr.value = "";
    if (supRegPayout) supRegPayout.value = "";
  }

  function loadSupplierToEditor(id){
    const s = state.suppliers?.[id];
    if (!s) return;
    if (supEditId) supEditId.value = id;
    if (supRegName) supRegName.value = s.name || "";
    if (supRegAddr) supRegAddr.value = s.addr || "";
    if (supRegEmail) supRegEmail.value = s.email || "";
    if (supRegOrgnr) supRegOrgnr.value = s.orgnr || "";
    if (supRegPayout) supRegPayout.value = s.payout || "";
  }

  function saveSupplierFromRegistry(){
    const name = (supRegName?.value || "").trim();
    if (!name) return showToast("Ange leverantörsnamn.", 3500);
    const s = {
      name,
      addr: (supRegAddr?.value || "").trim(),
      email: (supRegEmail?.value || "").trim(),
      orgnr: (supRegOrgnr?.value || "").trim(),
      payout: (supRegPayout?.value || "").trim()
    };
    const id = (supEditId?.value || "").trim() || (crypto && crypto.randomUUID ? crypto.randomUUID() : (String(Date.now()) + "-" + Math.random().toString(16).slice(2)));
    state.suppliers = state.suppliers || {};
    state.suppliers[id] = s;
    save({ renderAll:false });
    renderSuppliers();
    try { renderSiSupplierSelect(); } catch (e){}
    loadSupplierToEditor(id);
  }

  async function deleteSupplier(id){
    if (!(await confirmAsync("Ta bort leverantören?"))) return;
    delete state.suppliers[id];
    save({ renderAll:false });
    renderSuppliers();
    try { renderSiSupplierSelect(); } catch (e){}
    resetSupplierEditor();
  }

  function wireSupplierRegistryEvents(){
    if (btnSupNew) btnSupNew.addEventListener("click", (e)=>{ e.preventDefault(); resetSupplierEditor(); });
    if (btnSupSave) btnSupSave.addEventListener("click", (e)=>{ e.preventDefault(); saveSupplierFromRegistry(); });
    if (btnSupRefresh) btnSupRefresh.addEventListener("click", (e)=>{ e.preventDefault(); renderSuppliers(); try { renderSiSupplierSelect(); } catch (e){} });
    if (supSearch) supSearch.addEventListener("input", ()=>{ try { renderSuppliers(); } catch (e){} });
  }

  function renderSuppliers(){
    if (!suppliersList) return;
    const q = (supSearch?.value || "").trim().toLowerCase();
    const keys = Object.keys(state.suppliers||{})
      .sort((a,b)=> (state.suppliers[a]?.name||"").localeCompare(state.suppliers[b]?.name||"", "sv"));

    suppliersList.innerHTML = "";
    if (!keys.length){
      suppliersList.innerHTML = `<div class="muted small">Inga leverantörer sparade än.</div>`;
      return;
    }

    keys.forEach(id=>{
      const s = state.suppliers[id];
      const hay = `${s.name||""} ${s.addr||""} ${s.email||""} ${s.orgnr||""} ${s.payout||""}`.toLowerCase();
      if (q && !hay.includes(q)) return;

      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `
        <div class="top">
          <div>
            <div class="title">${escapeHtml(s.name||"(namn)")}</div>
            <div class="meta">${escapeHtml(s.addr||"")}</div>
            <div class="meta">${escapeHtml(s.email||"")}${s.orgnr?(" · "+escapeHtml(s.orgnr)):""}${s.payout?(" · "+escapeHtml(s.payout)):""}</div>
          </div>
          <div class="row">
            <button class="btn secondary" data-act="edit" data-id="${id}">Redigera</button>
            <button class="btn danger" data-act="del" data-id="${id}">Ta bort</button>
          </div>
        </div>
      `;
      div.addEventListener("click", async (e)=>{
        const b = e.target.closest("button");
        if (!b) return;
        const act = b.dataset.act;
        const sid = b.dataset.id;
        if (act==="edit"){ loadSupplierToEditor(sid); }
        if (act==="del"){ await deleteSupplier(sid); }
      });
      suppliersList.appendChild(div);
    });
  }



  // --- Supplier invoices (leverantörsfakturor) ---
  let currentSiAttachTargetId = "SI_DRAFT:" + crypto.randomUUID();

  function ensureSupplierInvoiceDefaultAccounts(){
    state.accounts = state.accounts || {};
    if (!state.accounts["2440"]) state.accounts["2440"] = { name:"Leverantörsskulder", type:"liability" };
    if (!state.accounts["2641"]) state.accounts["2641"] = { name:"Ingående moms", type:"asset" };
    if (!state.accounts["4010"]) state.accounts["4010"] = { name:"Inköp", type:"expense" };
  }

  function fillAccountSelectOptions(sel, prefer){
    if (!sel) return;
    const accList = Object.keys(state.accounts||{}).sort((a,b)=>a.localeCompare(b,"sv"));
    const prev = String(prefer ?? sel.value ?? "").trim();
    sel.innerHTML = "";
    accList.forEach(no=>{
      const opt = document.createElement("option");
      opt.value = no;
      opt.textContent = accountLabel(no);
      sel.appendChild(opt);
    });
    if (prev && !state.accounts[prev]){
      const opt = document.createElement("option");
      opt.value = prev;
      opt.textContent = accountLabel(prev);
      sel.insertBefore(opt, sel.firstChild);
    }
    if (prev && accList.includes(prev)) sel.value = prev;
    else sel.value = accList[0] || "";
  }

  function renderSiAccountSelects(si){
    ensureSupplierInvoiceDefaultAccounts();
    fillAccountSelectOptions(siExpenseAcc, (si && si.expenseAccount) || (siExpenseAcc && siExpenseAcc.value) || "4010");
    fillAccountSelectOptions(siVatAcc, (si && si.vatAccount) || (siVatAcc && siVatAcc.value) || "2641");
    fillAccountSelectOptions(siLiabAcc, (si && si.liabAccount) || (siLiabAcc && siLiabAcc.value) || "2440");
    // set defaults if present
    try { if (siExpenseAcc && !siExpenseAcc.value && state.accounts["4010"]) siExpenseAcc.value = "4010"; } catch {}
    try { if (siVatAcc && !siVatAcc.value && state.accounts["2641"]) siVatAcc.value = "2641"; } catch {}
    try { if (siLiabAcc && !siLiabAcc.value && state.accounts["2440"]) siLiabAcc.value = "2440"; } catch {}
  }

  function renderSiSupplierSelect(prefer){
    if (!siSupplierSelect) return;
    const prev = String(prefer ?? siSupplierSelect.value ?? "").trim();
    const keys = Object.keys(state.suppliers||{}).sort((a,b)=> (state.suppliers[a]?.name||"").localeCompare(state.suppliers[b]?.name||"", "sv"));
    siSupplierSelect.innerHTML = `<option value="">(ingen vald)</option>`;
    keys.forEach(id=>{
      const s = state.suppliers[id] || {};
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = `${s.name||"(namn)"}${s.orgnr?(" · "+s.orgnr):""}`;
      siSupplierSelect.appendChild(opt);
    });
    siSupplierSelect.value = keys.includes(prev) ? prev : "";
  }

  function siRecalcNet(){
    const gross = parseMoney(siGross && siGross.value);
    const vat = parseMoney(siVat && siVat.value);
    const net = Math.round((gross - vat) * 100) / 100;
    if (siNet) siNet.value = (Math.abs(net) > 0.00001) ? String(net).replace(".", ",") : "";
  }

  function siFormMinimalOk(){
    const date = (siDate && siDate.value) || "";
    const supplierName = (siSupplierName && siSupplierName.value ? String(siSupplierName.value) : "").trim();
    const gross = parseMoney(siGross && siGross.value);
    return !!date && !!supplierName && gross > 0;
  }

  function siSetSaveEnabled(){
    if (!btnSiSave) return;
    btnSiSave.disabled = !siFormMinimalOk();
  }

  function setSiAttachTarget(id){
    currentSiAttachTargetId = id || ("SI_DRAFT:" + crypto.randomUUID());
    try { renderUnderlagInto(siUnderlagList, currentSiAttachTargetId); } catch (e){}
  }

  function siUnderlagKeyFor(si){
    if (!si) return currentSiAttachTargetId;
    return si.bookedVoucherId ? si.bookedVoucherId : (si.docId || ("SI:" + si.id));
  }

  function newSupplierInvoice(){
    editingSupplierInvoiceId = null;
    if (siEditId) siEditId.value = "";
    if (siDate) siDate.value = todayISO();
    if (siDue) siDue.value = addDays(todayISO(), 30);
    if (siInvoiceNo) siInvoiceNo.value = "";
    if (siOcr) siOcr.value = "";
    if (siSeries) siSeries.value = (siSeries.value || "L").trim() || "L";

    renderSiSupplierSelect("");
    if (siSupplierName) siSupplierName.value = "";
    if (siSupplierOrgnr) siSupplierOrgnr.value = "";
    if (siSupplierEmail) siSupplierEmail.value = "";
    if (siSupplierPayout) siSupplierPayout.value = "";

    renderSiAccountSelects(null);
    if (siGross) siGross.value = "";
    if (siVat) siVat.value = "";
    siRecalcNet();

    setSiAttachTarget(null);
    hideSiOcrPanel(true);
    currentSiOcrMeta = null;
    siSetSaveEnabled();
  }

  function loadSupplierInvoiceToEditor(id){
    const si = (state.supplierInvoices||[]).find(x=>x && x.id===id);
    if (!si) return;
    editingSupplierInvoiceId = si.id;
    if (siEditId) siEditId.value = si.id;

    if (siDate) siDate.value = si.date || todayISO();
    if (siDue) siDue.value = si.due || addDays(si.date||todayISO(), 30);
    if (siInvoiceNo) siInvoiceNo.value = si.invoiceNo || "";
    if (siOcr) siOcr.value = si.ocr || "";
    if (siSeries) siSeries.value = (si.series || "L");

    renderSiSupplierSelect(si.supplierId || "");
    // prefer explicit supplier data on invoice (so it doesn't break if supplier registry changes)
    if (siSupplierName) siSupplierName.value = si.supplierName || (si.supplierId ? (state.suppliers?.[si.supplierId]?.name || "") : "");
    if (siSupplierOrgnr) siSupplierOrgnr.value = si.supplierOrgnr || (si.supplierId ? (state.suppliers?.[si.supplierId]?.orgnr || "") : "");
    if (siSupplierEmail) siSupplierEmail.value = si.supplierEmail || (si.supplierId ? (state.suppliers?.[si.supplierId]?.email || "") : "");
    if (siSupplierPayout) siSupplierPayout.value = si.supplierPayout || (si.supplierId ? (state.suppliers?.[si.supplierId]?.payout || "") : "");

    renderSiAccountSelects(si);

    if (siGross) siGross.value = String(si.gross ?? "").replace(".", ",");
    if (siVat) siVat.value = String(si.vat ?? "").replace(".", ",");
    siRecalcNet();

    // attach target = voucher if booked else docId
    setSiAttachTarget(siUnderlagKeyFor(si));

    // disable save until changes
    hideSiOcrPanel(true);
    currentSiOcrMeta = null;
    siSetSaveEnabled();
  }

  function updateUnderlagMetaForDoc(docId, meta){
    const list = state.underlag || [];
    let touched = 0;
    for (const u of list){
      if (!u || u.voucherId !== docId) continue;
      if (meta.yearId) u.yearId = meta.yearId;
      if (meta.series != null) u.series = meta.series;
      if (meta.no != null) u.no = meta.no;
      if (meta.date != null) u.date = meta.date;
      if (meta.ref != null) u.ref = meta.ref;
      if (meta.note != null) u.note = meta.note;
      touched++;
    }
    return touched;
  }

  function relinkUnderlagDoc(fromId, toId, meta){
    const list = state.underlag || [];
    let moved = 0;
    for (const u of list){
      if (!u || u.voucherId !== fromId) continue;
      u.voucherId = toId;
      if (meta){
        if (meta.yearId) u.yearId = meta.yearId;
        if (meta.series != null) u.series = meta.series;
        if (meta.no != null) u.no = meta.no;
        if (meta.date != null) u.date = meta.date;
        if (meta.ref != null) u.ref = meta.ref;
        if (meta.note != null) u.note = meta.note;
      }
      moved++;
    }
    if (moved){
      appendAudit({ action:"underlag.relink", entityType:"underlag", entityId: toId, yearId: meta?.yearId, details:{ fromId, toId, moved, meta } });
    }
    return moved;
  }

  function upsertSupplierInvoiceFromForm(opts){
    const silent = !!(opts && opts.silent);
    state.supplierInvoices = Array.isArray(state.supplierInvoices) ? state.supplierInvoices : [];

    const date = (siDate && siDate.value) || todayISO();
    const yearId = String(date).slice(0,4) || state.activeYearId;
    const due = (siDue && siDue.value) || addDays(date, 30);
    const invoiceNo = clampText((siInvoiceNo && siInvoiceNo.value ? siInvoiceNo.value : "").trim(), 80);
    const ocr = clampText((siOcr && siOcr.value ? siOcr.value : "").trim(), 80);
    const series = clampText((siSeries && siSeries.value ? siSeries.value : "L").trim() || "L", 10);

    const supplierId = (siSupplierSelect && siSupplierSelect.value ? String(siSupplierSelect.value).trim() : "") || null;
    const supplierName = clampText((siSupplierName && siSupplierName.value ? siSupplierName.value : "").trim(), 120);
    const supplierOrgnr = clampText((siSupplierOrgnr && siSupplierOrgnr.value ? siSupplierOrgnr.value : "").trim(), 40);
    const supplierEmail = clampText((siSupplierEmail && siSupplierEmail.value ? siSupplierEmail.value : "").trim(), 120);
    const supplierPayout = clampText((siSupplierPayout && siSupplierPayout.value ? siSupplierPayout.value : "").trim(), 80);

    const gross = Math.round(parseMoney(siGross && siGross.value) * 100) / 100;
    const vat = Math.round(parseMoney(siVat && siVat.value) * 100) / 100;
    const net = Math.round((gross - vat) * 100) / 100;

    const expenseAccount = (siExpenseAcc && siExpenseAcc.value ? siExpenseAcc.value : "4010");
    const vatAccount = (siVatAcc && siVatAcc.value ? siVatAcc.value : "2641");
    const liabAccount = (siLiabAcc && siLiabAcc.value ? siLiabAcc.value : "2440");

    if (!silent){
      if (!date) { showToast("Ange fakturadatum.", 4500); return null; }
      if (!supplierName) { showToast("Ange leverantörens namn.", 4500); return null; }
      if (!(gross > 0)) { showToast("Ange belopp inkl moms.", 4500); return null; }
    }

    const actor = clampText((state.company?.defaultSign || "").trim(), 60);
    const nowIso = new Date().toISOString();

    if (!editingSupplierInvoiceId){
      const id = crypto.randomUUID();
      const docId = "SI:" + id;

      const rec = {
        id,
        docId,
        yearId,
        date,
        due,
        invoiceNo,
        ocr,
        series,
        currency: state.company?.currency || "SEK",
        gross,
        vat,
        net,
        expenseAccount,
        vatAccount,
        liabAccount,
        supplierId,
        supplierName,
        supplierOrgnr,
        supplierEmail,
        supplierPayout,
        status: "received",
        bookedVoucherId: null,
        createdAt: nowIso,
        createdBy: actor,
        updatedAt: null,
        updatedBy: "",
        ocrMeta: currentSiOcrMeta || null
      };

      // If files were added before saving (draft doc id) -> relink to real docId
      const oldTarget = currentSiAttachTargetId;
      if (oldTarget && oldTarget !== docId){
        const meta = { yearId, series:"LF", no:(invoiceNo || ("SI-" + id.slice(0,8))), date, ref: invoiceNo || "", note: supplierName || "" };
        relinkUnderlagDoc(oldTarget, docId, meta);
      } else {
        // ensure underlag meta is in sync
        updateUnderlagMetaForDoc(docId, { yearId, series:"LF", no:(invoiceNo || ("SI-" + id.slice(0,8))), date, ref: invoiceNo || "", note: supplierName || "" });
      }

      state.supplierInvoices.push(rec);
      appendAudit({ action:"supplierInvoice.create", actor: actor || undefined, entityType:"supplierInvoice", entityId:id, yearId, details:{ after: rec } });
      editingSupplierInvoiceId = id;
      if (siEditId) siEditId.value = id;
      setSiAttachTarget(docId);
      save();
      if (!silent) showToast("Leverantörsfakturan sparades.", 3500);
      return id;
    }

    // update existing
    const idx = state.supplierInvoices.findIndex(x=>x && x.id===editingSupplierInvoiceId);
    if (idx < 0) return null;
    const before = state.supplierInvoices[idx];
    const docId = before.docId || ("SI:" + before.id);

    const after = {
      ...before,
      docId,
      yearId,
      date,
      due,
      invoiceNo,
      ocr,
      series,
      currency: before.currency || (state.company?.currency || "SEK"),
      gross,
      vat,
      net,
      expenseAccount,
      vatAccount,
      liabAccount,
      supplierId,
      supplierName,
      supplierOrgnr,
      supplierEmail,
      supplierPayout,
      updatedAt: nowIso,
      updatedBy: actor,
      ocrMeta: (currentSiOcrMeta || before.ocrMeta || null)
    };

    // if not booked, keep underlag meta in sync on docId target
    if (!after.bookedVoucherId){
      updateUnderlagMetaForDoc(docId, { yearId, series:"LF", no:(invoiceNo || ("SI-" + after.id.slice(0,8))), date, ref: invoiceNo || "", note: supplierName || "" });
      setSiAttachTarget(docId);
    } else {
      // attachments live on voucher; still show them
      setSiAttachTarget(after.bookedVoucherId);
    }

    state.supplierInvoices[idx] = after;
    appendAudit({ action:"supplierInvoice.update", actor: actor || undefined, entityType:"supplierInvoice", entityId: after.id, yearId, details:{ before, after } });
    save();
    if (!silent) showToast("Leverantörsfakturan uppdaterades.", 3500);
    return after.id;
  }

  async function voidSupplierInvoice(id){
    const si = (state.supplierInvoices||[]).find(x=>x && x.id===id);
    if (!si) return;
    if (String(si.status||"") === "voided") return showToast("Leverantörsfakturan är redan makulerad.", 4500);

    const reason = await promptAsync("Makulera leverantörsfakturan? Ange orsak (valfritt).\nTips: Ctrl+Enter = OK.", {
      placeholder: "t.ex. dubbelregistrerad",
      okText: "Makulera",
      cancelText: "Avbryt"
    });
    if (reason === null) return;

    const actor = clampText((state.company?.defaultSign || "").trim(), 60);
    const before = { ...si };

    si.status = "voided";
    si.voidedAt = new Date().toISOString();
    si.voidedBy = actor;
    si.voidReason = clampText(String(reason||"").trim(), 240);

    appendAudit({ action:"supplierInvoice.void", actor: actor || undefined, entityType:"supplierInvoice", entityId: si.id, yearId: si.yearId, details:{ before, after: si, reason: si.voidReason } });
    save();
    try { renderSupplierInvoices(); } catch (e){}
    showToast("Makulerade leverantörsfakturan (spårbarhet kvar).", 4500);
  }

  async function createVoucherFromSupplierInvoice(siId){
    const si = (state.supplierInvoices||[]).find(x=>x && x.id===siId);
    if (!si) return;
    if (si.bookedVoucherId) return showToast("Leverantörsfakturan är redan bokförd (har verifikation).", 6500);
    if (String(si.status||"") === "voided") return showToast("Leverantörsfakturan är makulerad. Bokför inte.", 6500);

    const ok = await confirmAsync(`Skapa en verifikation (serie ${si.series||"L"}) för leverantörsfakturan?`);
    if (!ok) return;

    ensureSupplierInvoiceDefaultAccounts();

    // ensure selected accounts exist
    if (!state.accounts[si.expenseAccount]) state.accounts[si.expenseAccount] = { name:"Kostnad", type: guessTypeFromAccountNo(si.expenseAccount) };
    if (!state.accounts[si.vatAccount]) state.accounts[si.vatAccount] = { name:"Ingående moms", type: guessTypeFromAccountNo(si.vatAccount) };
    if (!state.accounts[si.liabAccount]) state.accounts[si.liabAccount] = { name:"Leverantörsskuld", type: guessTypeFromAccountNo(si.liabAccount) };

    const yearId = si.yearId || String(si.date||"").slice(0,4) || state.activeYearId;
    const date = si.date || todayISO();
    const series = (si.series || "L").trim() || "L";
    const no = nextVerno(yearId, series);

    const supplierName = (si.supplierName || "").trim() || (si.supplierId ? (state.suppliers?.[si.supplierId]?.name || "") : "") || "Leverantör";
    const text = clampText(`Lev.faktura ${supplierName} ${si.invoiceNo || ""}`.trim(), 120);

    const gross = Math.round((Number(si.gross)||0) * 100) / 100;
    const vat = Math.round((Number(si.vat)||0) * 100) / 100;
    const net = Math.round((Number(si.net)|| (gross - vat)) * 100) / 100;

    const lines = [
      { account: si.expenseAccount, text: si.invoiceNo ? ("Lev.fakt " + si.invoiceNo) : "Leverantörsfaktura", amount: +net },
      (vat ? { account: si.vatAccount, text: "Ingående moms", amount: +vat } : null),
      { account: si.liabAccount, text: supplierName, amount: -(gross) }
    ].filter(Boolean);

    const vv = {
      id: crypto.randomUUID(),
      yearId,
      series,
      no,
      date,
      text,
      regDate: todayISO(),
      sign: state.company.defaultSign || "",
      lines,
      correctionOf: null,
      status: "active"
    };

    state.vouchers = state.vouchers || [];
    state.vouchers.push(vv);
    appendAudit({ action:"voucher.create", actor: vv.sign || undefined, entityType:"voucher", entityId: vv.id, yearId, details:{ after: summarizeVoucher(vv), source:"supplierInvoice", supplierInvoiceId: si.id } });

    // move underlag from docId -> voucher id
    const moved = relinkUnderlagDoc(si.docId || ("SI:" + si.id), vv.id, { yearId, series: vv.series, no: vv.no, date: vv.date, ref: si.invoiceNo || "", note: supplierName || "" });

    // mark supplier invoice as booked
    const before = { ...si };
    si.bookedVoucherId = vv.id;
    si.status = "booked";
    si.bookedAt = new Date().toISOString();
    si.bookedBy = clampText((state.company?.defaultSign || "").trim(), 60);
    appendAudit({ action:"supplierInvoice.book", actor: si.bookedBy || undefined, entityType:"supplierInvoice", entityId: si.id, yearId, details:{ before, after: si, voucherId: vv.id, movedUnderlag: moved } });

    // keep voucher list sorted
    state.vouchers.sort((a,b)=> (a.yearId+b.series+a.no+a.date).localeCompare(b.yearId+b.series+b.no+b.date, "sv"));
    save();

    try { renderVouchers(); } catch (e){}
    try { renderSupplierInvoices(); } catch (e){}
    try { loadSupplierInvoiceToEditor(si.id); } catch (e){}

    // jump to voucher for review
    try {
      activateTab("vouchers");
      viewVoucherToEditor(vv.id);
      showToast("Skapade verifikation från leverantörsfakturan. Kontrollera konton och moms innan du använder skarpt.", 8000);
    } catch (e){
      showToast("Skapade verifikation från leverantörsfakturan.", 4500);
    }
  }

  function supplierInvoiceUnderlagCount(si){
    const key = siUnderlagKeyFor(si);
    try {
      return (state.underlag||[]).filter(u=>u && u.voucherId===key && String(u.status||"")!=="detached").length;
    } catch (e){
      return 0;
    }
  }

  function renderSupplierInvoices(){
    fillYearSelectors();
    if (siYearSelect) siYearSelect.value = siYearSelect.value || state.activeYearId;

    state.supplierInvoices = Array.isArray(state.supplierInvoices) ? state.supplierInvoices : [];

    // keep selects up to date
    renderSiSupplierSelect(siSupplierSelect ? siSupplierSelect.value : "");
    renderSiAccountSelects(null);

    const yid = (siYearSelect && siYearSelect.value) || state.activeYearId;
    const list = state.supplierInvoices
      .filter(si=>si && si.yearId===yid)
      .slice()
      .sort((a,b)=> (String(a.date||"")+String(a.invoiceNo||"")).localeCompare(String(b.date||"")+String(b.invoiceNo||""), "sv"));

    if (!supplierInvoiceList) return;
    supplierInvoiceList.innerHTML = "";
    if (!list.length){
      supplierInvoiceList.innerHTML = `<div class="muted small">Inga leverantörsfakturor i detta år ännu.</div>`;
      return;
    }

    list.forEach(si=>{
      const isVoided = String(si.status||"") === "voided";
      const isBooked = !!si.bookedVoucherId;
      const badge = isVoided ? '<span class="status">Makulerad</span>' : (isBooked ? '<span class="status ok">Bokförd</span>' : '<span class="status">Mottagen</span>');
      const uCount = supplierInvoiceUnderlagCount(si);

      const title = `${escapeHtml(si.date||"")} · ${escapeHtml(si.supplierName||"Leverantör")} · ${escapeHtml(si.invoiceNo||"(utan nr)")}`;
      const meta = [
        si.due ? ("Förfaller " + si.due) : "",
        ("Belopp " + fmtSEK(Number(si.gross)||0) + " " + (si.currency||state.company.currency||"SEK")),
        (uCount ? ("Underlag: " + uCount) : "Underlag: 0"),
        (isBooked ? ("Verifikation: " + String((state.vouchers||[]).find(v=>v.id===si.bookedVoucherId)?.series||"") + String((state.vouchers||[]).find(v=>v.id===si.bookedVoucherId)?.no||"")) : "")
      ].filter(Boolean).join(" · ");

      const btnOpen = `<button class="btn secondary" data-act="open" data-id="${escapeAttr(si.id)}">Öppna</button>`;
      const btnVoucher = (!isBooked && !isVoided) ? `<button class="btn" data-act="voucher" data-id="${escapeAttr(si.id)}">Bokför</button>` : "";
      const btnShowVoucher = (isBooked) ? `<button class="btn secondary" data-act="show-voucher" data-id="${escapeAttr(si.id)}">Visa verifikation</button>` : "";
      const btnVoid = (!isVoided) ? `<button class="btn danger" data-act="void" data-id="${escapeAttr(si.id)}">Makulera</button>` : "";

      const div = document.createElement("div");
      div.className = "item" + (isVoided ? " voided" : "");
      div.innerHTML = `
        <div class="top">
          <div>
            <div class="title">${title} ${badge}</div>
            <div class="meta">${escapeHtml(meta)}</div>
          </div>
          <div class="row">
            ${btnOpen}
            ${btnShowVoucher}
            ${btnVoucher}
            ${btnVoid}
          </div>
        </div>
      `;
      supplierInvoiceList.appendChild(div);
    });
  }

  function wireSupplierInvoiceEvents(){
    if (btnSiNew) btnSiNew.addEventListener("click", (e)=>{ e.preventDefault(); newSupplierInvoice(); });
    if (btnSiSave) btnSiSave.addEventListener("click", (e)=>{ e.preventDefault(); upsertSupplierInvoiceFromForm(); renderSupplierInvoices(); siSetSaveEnabled(); });
    if (btnSiRefresh) btnSiRefresh.addEventListener("click", (e)=>{ e.preventDefault(); renderSupplierInvoices(); });
    if (siYearSelect) siYearSelect.addEventListener("change", renderSupplierInvoices);

    // OCR panel (leverantörsfaktura)
    if (btnSiOcrDiscard) btnSiOcrDiscard.addEventListener("click", (e)=>{ e.preventDefault(); hideSiOcrPanel(true); });
    if (btnSiOcrApply) btnSiOcrApply.addEventListener("click", (e)=>{ e.preventDefault(); applySiOcrToForm(); });
    if (btnSiOcrRun) btnSiOcrRun.addEventListener("click", async (e)=>{
      e.preventDefault();
      if (!siOcrCtx || !siOcrCtx.underlagId) return showToast("Välj ett underlag och klicka OCR först.", 4500);
      await ocrUnderlagToSupplierInvoice(siOcrCtx.underlagId, { rerun: true });
    });
    if (siOcrLang) siOcrLang.addEventListener("change", ()=>{ siOcrCtx.lang = siOcrLang.value; });
    if (siOcrPdfPages) siOcrPdfPages.addEventListener("change", ()=>{ siOcrCtx.pdfPages = siOcrPdfPages.value; });


    if (btnSiToVoucher) btnSiToVoucher.addEventListener("click", async (e)=>{
      e.preventDefault();
      // save (if needed) and then create voucher
      const id = upsertSupplierInvoiceFromForm({ silent:false });
      if (!id) return;
      await createVoucherFromSupplierInvoice(id);
    });

    if (siSupplierSelect){
      siSupplierSelect.addEventListener("change", ()=>{
        const id = (siSupplierSelect.value||"").trim();
        if (!id) return;
        const s = state.suppliers?.[id];
        if (!s) return;
        // fill fields from register
        if (siSupplierName && !String(siSupplierName.value||"").trim()) siSupplierName.value = s.name || "";
        if (siSupplierOrgnr && !String(siSupplierOrgnr.value||"").trim()) siSupplierOrgnr.value = s.orgnr || "";
        if (siSupplierEmail && !String(siSupplierEmail.value||"").trim()) siSupplierEmail.value = s.email || "";
        if (siSupplierPayout && !String(siSupplierPayout.value||"").trim()) siSupplierPayout.value = s.payout || "";
        siSetSaveEnabled();
      });
    }

    [siDate, siDue, siInvoiceNo, siOcr, siSeries, siSupplierName, siSupplierOrgnr, siSupplierEmail, siSupplierPayout, siGross, siVat].filter(Boolean).forEach(el=>{
      el.addEventListener("input", ()=>{
        siRecalcNet();
        siSetSaveEnabled();
      });
      el.addEventListener("change", ()=>{
        if (el === siDate && siDate && siDue && !siDue.value){
          try { siDue.value = addDays(siDate.value || todayISO(), 30); } catch {}
        }
        siRecalcNet();
        siSetSaveEnabled();
      });
    });

    if (siFiles) siFiles.addEventListener("change", async ()=>{
      try {
        const files = (siFiles.files || []);
        const targetId = currentSiAttachTargetId || ("SI_DRAFT:" + crypto.randomUUID());
        if (!files || !files.length) return;

        const date = (siDate && siDate.value) || todayISO();
        const yearId = String(date).slice(0,4) || state.activeYearId;
        const invoiceNo = clampText((siInvoiceNo && siInvoiceNo.value ? siInvoiceNo.value : "").trim(), 80);
        const supplierName = clampText((siSupplierName && siSupplierName.value ? siSupplierName.value : "").trim(), 120);

        // Use LF/<fakturanr> while unbooked; will be relinked to voucher later
        const series = "LF";
        const no = invoiceNo || ("SI-" + (editingSupplierInvoiceId || targetId).slice(-8));

        state.underlag = Array.isArray(state.underlag) ? state.underlag : [];
        for (const f of Array.from(files)){
          const id = crypto.randomUUID();
          const rec = {
            id,
            voucherId: targetId,
            yearId,
            series,
            no,
            date,
            type: "leverantorsfaktura",
            ref: invoiceNo || "",
            note: supplierName || "",
            fileName: safeFileName(f.name),
            mime: f.type || "",
            size: f.size || 0,
            status: "active",
            createdAt: new Date().toISOString(),
            createdBy: clampText((state.company?.defaultSign || "").trim(), 60)
          };
          state.underlag.push(rec);
          try { await idbSet("underlagBlob:" + id, f); } catch (e){ console.error(e); showToast("Kunde inte spara underlaget lokalt (IndexedDB).", 6500); }
          appendAudit({ action:"underlag.add", actor: rec.createdBy || undefined, entityType:"underlag", entityId:id, yearId, details:{ voucherId: targetId, series, no, date, type: rec.type, ref: rec.ref, fileName: rec.fileName, size: rec.size, doc:"supplierInvoice" } });
        }
        save();
        try { renderUnderlagInto(siUnderlagList, targetId); } catch (e){}
        try { renderSupplierInvoices(); } catch (e){}
        showToast(`Lade till ${files.length} underlag till leverantörsfakturan.`, 4500);
      } finally {
        try { siFiles.value = ""; } catch {}
      }
    });

    if (siUnderlagList){
      siUnderlagList.addEventListener("click", async (e)=>{
        const b = e.target && e.target.closest ? e.target.closest("button[data-act]") : null;
        if (!b) return;
        const act = b.dataset.act;
        const id = b.dataset.id;
        if (!id) return;
        if (act === "open-underlag") await openUnderlag(id);
        if (act === "ocr-underlag") await ocrUnderlagToSupplierInvoice(id);
        if (act === "detach-underlag") await detachUnderlag(id);
      });
    }

    if (supplierInvoiceList){
      supplierInvoiceList.addEventListener("click", async (e)=>{
        const b = e.target && e.target.closest ? e.target.closest("button[data-act]") : null;
        if (!b) return;
        const act = b.dataset.act;
        const id = b.dataset.id;
        if (!id) return;
        if (act === "open"){ loadSupplierInvoiceToEditor(id); }
        if (act === "voucher"){ await createVoucherFromSupplierInvoice(id); }
        if (act === "void"){ await voidSupplierInvoice(id); }
        if (act === "show-voucher"){
          const si = (state.supplierInvoices||[]).find(x=>x && x.id===id);
          if (si && si.bookedVoucherId){
            activateTab("vouchers");
            viewVoucherToEditor(si.bookedVoucherId);
          }
        }
      });
    }
  }


  function wireInvoiceEvents(){
    // Default: show list. User can collapse for more editor space.
    setInvoiceListCollapsed(invListCollapsed);
    if (btnInvToggleList) btnInvToggleList.addEventListener("click", ()=> setInvoiceListCollapsed(!invListCollapsed));
    if (btnInvNew) btnInvNew.addEventListener("click", newInvoice);
    if (btnInvClear) btnInvClear.addEventListener("click", async ()=>{ if (!(await confirmAsync("Rensa fakturan?"))) return; newInvoice(); });
    if (btnInvAddItem) btnInvAddItem.addEventListener("click", ()=>{ invLines.push({ kind: "item", desc: "", qty: "1", price: "", vat: "25" });
 renderInvoiceLines(); updateInvoiceTotals(); });
    if (btnInvAddComment) btnInvAddComment.addEventListener("click", ()=>{ invLines.push({kind:"comment", desc:""}); renderInvoiceLines(); updateInvoiceTotals(); });
    if (btnInvPickCustomer) btnInvPickCustomer.addEventListener("click", openCustomerDialog);
    if (btnInvSave) btnInvSave.addEventListener("click", saveInvoice);
    if (btnInvPrint) btnInvPrint.addEventListener("click", ()=>{
      // print current editor as a "draft" by saving temporarily in memory
      const tmpId = editingInvoiceId || "__draft__";
      const tmp = { id: tmpId, yearId: invoiceYearId(), no: (invNo.value||"").trim()||"Utkast", date: invDate.value||todayISO(), due: invDue.value||addDays(invDate.value||todayISO(), (state.company.payDays||30)), customerId: invCustomerId, ref: invRef.value||"", lines: invLines.map(l=>({kind:l.kind, desc:l.desc||"", qty:parseMoney(l.qty), price:parseMoney(l.price), vat:parseMoney(l.vat)})) };
      // temporarily render without storing
      const c = state.customers?.[tmp.customerId];
      if (!c) return showToast("Välj kund först.", 3500);
      // reuse printInvoice by pushing temp into state briefly
      const exists = (state.invoices||[]).find(x=>x.id===tmpId);
      if (!exists){
        state.invoices = state.invoices || [];
        state.invoices.push(tmp);
        printInvoice(tmpId);
        state.invoices = state.invoices.filter(x=>x.id!==tmpId);
      } else {
        printInvoice(tmpId);
      }
    });
    if (btnInvToVoucher) btnInvToVoucher.addEventListener("click", async ()=>{ if (!(await confirmAsync("Skapa en verifikation för fakturan (serie F)?"))) return; createVoucherFromInvoice(); });
    if (btnInvRefresh) btnInvRefresh.addEventListener("click", renderInvoices);
    if (invYearSelect) invYearSelect.addEventListener("change", renderInvoices);

    if (btnCustomerClose) btnCustomerClose.addEventListener("click", closeCustomerDialog);
    if (btnCustomerSave) btnCustomerSave.addEventListener("click", saveCustomerAndPick);

    [invDate, invDue, invNo, invRef].filter(Boolean).forEach(el=> el.addEventListener("input", updateInvoiceTotals));
  }

// --- Voucher editor ---
  let currentLines = [];
  let voucherEditorReadOnly = false;
  let viewingVoucherId = null; // when viewing an existing voucher (read-only)

  function renderVouchers(){
    if (!voucherList) return;
    const yearId = (yearSelect && yearSelect.value) || state.activeYearId;
    const list = (state.vouchers || []).filter(v => (v.yearId || "") === yearId);
    list.sort((a,b)=>{
      const ad = (a.date || "");
      const bd = (b.date || "");
      if (ad !== bd) return ad.localeCompare(bd, "sv");
      const as = (a.series || "");
      const bs = (b.series || "");
      if (as !== bs) return as.localeCompare(bs, "sv");
      const an = Number(a.no);
      const bn = Number(b.no);
      if (Number.isFinite(an) && Number.isFinite(bn) && an !== bn) return an - bn;
      return String(a.no||"").localeCompare(String(b.no||""), "sv");
    });

    voucherList.innerHTML = "";
    if (!list.length){
      const empty = document.createElement("div");
      empty.className = "muted small";
      empty.textContent = "Inga verifikationer i detta år.";
      voucherList.appendChild(empty);
      return;
    }

            list.forEach(v=>{
      const isVoid = isVoidedVoucher(v);
      const div = document.createElement("div");
      div.className = "item" + (isVoid ? " voided" : "");

      const title = `${(v.series||"")}${(v.no||"")} · ${v.date || ""} · ${(v.text||"").trim() || "(utan text)"}`;

      const metaParts = [];
      metaParts.push(`Reg: ${v.regDate || ""}`);
      if (v.sign) metaParts.push("Sign: " + v.sign);
      if (v.correctionOf) metaParts.push("Rättelse av: " + v.correctionOf);
      // Underlag count
      try {
        const nU = (state.underlag||[]).filter(u=>u && u.voucherId===v.id && String(u.status||"")!=="detached").length;
        if (nU) metaParts.push("Underlag: " + nU);
      } catch (e){}
      if (isVoid){
        const dt = (v.voidedAt || "").slice(0,10);
        const by = (v.voidedBy || "").trim();
        const rs = (v.voidReason || "").trim();
        metaParts.push(`Makulerad: ${dt || "?"}${by ? " · " + by : ""}${rs ? " · " + rs : ""}`);
      }
      const meta = metaParts.join(" · ");

      const badge = isVoid ? '<span class="status">Makulerad</span>' : "";
      const openLabel = isVoid ? "Visa" : "Öppna";
      const voidBtn = "";

      div.innerHTML = `
        <div class="top">
          <div>
            <div class="title">${escapeHtml(title)} ${badge}</div>
            <div class="meta">${escapeHtml(meta)}</div>
          </div>
          <div class="row">
            <button type="button" class="btn secondary" data-act="open" data-id="${escapeAttr(v.id)}">${openLabel}</button>
            ${voidBtn}
          </div>
        </div>
      `;
      voucherList.appendChild(div);
    });
  }

  let voucherListWired = false;
  function wireVoucherEvents(){
    if (btnNewVoucher) btnNewVoucher.addEventListener("click", (e)=>{ e.preventDefault(); newVoucher(); });
    if (btnAddLine) btnAddLine.addEventListener("click", (e)=>{ e.preventDefault(); if (voucherEditorReadOnly) return; currentLines.push(makeLine()); renderLines(); updateBalanceBadge(); });
    if (btnClearVoucher) btnClearVoucher.addEventListener("click", async (e)=>{ e.preventDefault(); if (!(await confirmAsync("Rensa verifikationen?"))) return; newVoucher(); });
    if (btnSaveVoucher) btnSaveVoucher.addEventListener("click", (e)=>{ e.preventDefault(); saveVoucher(); });
    if (btnRefresh) btnRefresh.addEventListener("click", (e)=>{ e.preventDefault(); renderVouchers(); });

    // Underlag handlers
    if (uFiles) uFiles.addEventListener("change", async (e)=>{
      try {
        const files = (uFiles.files || []);
        await addUnderlagFiles(files);
      } finally {
        try { uFiles.value = ""; } catch {}
      }
    });
    if (uList){
      uList.addEventListener("click", async (e)=>{
        const b = e.target && e.target.closest ? e.target.closest("button[data-act]") : null;
        if (!b) return;
        const act = b.dataset.act;
        const id = b.dataset.id;
        if (!id) return;
        if (act === "open-underlag") await openUnderlag(id);
        if (act === "detach-underlag") await detachUnderlag(id);
      });
    }


    if (btnFillExample) btnFillExample.addEventListener("click", async (e)=>{
      e.preventDefault();
      if (!(await confirmAsync("Skapa exempelverifikationer A76–A79 i valt år?"))) return;
      const yearId = (yearSelect && yearSelect.value) || state.activeYearId;
      const date = todayISO();
      const cash = state.accounts["1930"] ? "1930" : (Object.keys(state.accounts)[0] || "");
      const other = state.accounts["4010"] ? "4010" : (Object.keys(state.accounts)[1] || cash || "");
      const defs = [
        { no:"76", text:"Exempel: köp", amount: 1000 },
        { no:"77", text:"Exempel: försäljning", amount: 1250 },
        { no:"78", text:"Exempel: avgift", amount: 99 },
        { no:"79", text:"Exempel: justering", amount: 250 },
      ];
      let added = 0;
      defs.forEach(d=>{
        const exists = (state.vouchers||[]).some(v=>v.yearId===yearId && (v.series||"")==="A" && String(v.no||"")===d.no);
        if (exists) return;
        const lines = [
          { account: other, text: d.text, amount: Math.round(d.amount*100)/100 },
          { account: cash, text: d.text, amount: -Math.round(d.amount*100)/100 },
        ];
        const vv = {
          id: crypto.randomUUID(),
          yearId,
          series: "A",
          no: d.no,
          date,
          text: d.text,
          regDate: date,
          sign: state.company.defaultSign || "",
          lines,
          correctionOf: null,
          status: "active"
        };
        state.vouchers.push(vv);
        appendAudit({ action:"voucher.create", actor: vv.sign || undefined, entityType:"voucher", entityId: vv.id, yearId, details:{ after: summarizeVoucher(vv), source:"example" } });
        added++;
      });
      save();
      renderVouchers();
      try { if (lastReportHtml) generateReport(); } catch (e){ console.error(e); }
      showToast(added ? `Skapade ${added} exempelverifikationer.` : "Exempelverifikationerna fanns redan.", 4500);
    });

    if (voucherList && !voucherListWired){
      voucherListWired = true;
      voucherList.addEventListener("click", async (e)=>{
        const b = e.target && e.target.closest ? e.target.closest("button[data-act]") : null;
        if (!b) return;
        const act = b.dataset.act;
        const id = b.dataset.id;
        if (!id) return;
        if (act === "open") viewVoucherToEditor(id);
        if (act === "void"){
          showToast("Makulering av verifikationer är avstängd. Skapa en rättelseverifikation i stället.", 6500);
        }
        renderVouchers();
      });
    }
  }


  function newVoucher(){
    editingVoucherId = null;
    viewingVoucherId = null;
    voucherEditorReadOnly = false;
    correctionOfId = null;
    draftVoucherId = crypto.randomUUID();
    vDate.value = todayISO();
    vSeries.value = "A";
    vNo.value = "";
    vText.value = "";
    vSign.value = state.company.defaultSign || "";
    currentLines = [ makeLine(), makeLine() ];
    renderLines();
    updateBalanceBadge();
    try { if (uType) uType.value = "kvitto"; } catch (e){}
    try { if (uRef) uRef.value = ""; } catch (e){}
    try { if (uNote) uNote.value = ""; } catch (e){}
    try { renderUnderlag(); } catch (e){}

    if (btnSaveVoucher) btnSaveVoucher.disabled = true;
    updateFsUI();
  }


  // --- Carry opening balances (IB) between fiscal years ---
  function wireYearCarryEvents(){
    const btnCarry = document.getElementById("btnCarry");
    const carryFrom = document.getElementById("carryFrom");
    const carryTo = document.getElementById("carryTo");
    if (!btnCarry || !carryFrom || !carryTo) return;

    function isBalanceAccount(accNo){
      const a = String(accNo||"").trim();
      const t = state.accounts && state.accounts[a] ? state.accounts[a].type : null;
      if (t === "asset" || t === "liability" || t === "equity") return true;
      // BAS heuristic: 1xxx and 2xxx are balance accounts
      return a.length >= 1 && (a[0] === "1" || a[0] === "2");
    }

    function findYear(id){
      return (state.fiscalYears||[]).find(y => String(y.id) === String(id));
    }

    function existingIB(toYearId, toStart){
      return (state.vouchers||[]).find(v =>
        v && v.yearId === toYearId &&
        v.date === toStart &&
        !isVoidedVoucher(v) &&
        (
          (v.meta && v.meta.kind === "opening_balance") ||
          String(v.text||"").toLowerCase().includes("ingående balans")
        )
      ) || null;
    }

    btnCarry.addEventListener("click", async (e)=>{
      e.preventDefault();

      const fromYearId = String(carryFrom.value||"").trim();
      const toYearId = String(carryTo.value||"").trim();

      if (!fromYearId || !toYearId){
        showToast("Välj både IB från- och till-år.", 4500);
        return;
      }
      if (fromYearId === toYearId){
        showToast("IB från-året och till-året kan inte vara samma.", 4500);
        return;
      }

      const fyFrom = findYear(fromYearId);
      const fyTo = findYear(toYearId);
      if (!fyFrom || !fyTo){
        showToast("Kunde inte hitta valda räkenskapsår.", 5000);
        return;
      }

      const toStart = fyTo.start;
      if (!toStart){
        showToast("Till-året saknar startdatum.", 5000);
        return;
      }

      const already = existingIB(toYearId, toStart);
      if (already){
        showToast("IB är redan överförd för detta år (skydd mot dubbla IB). Ta bort den befintliga IB-verifikationen om du vill göra om.", 7000);
        return;
      }

      // Compute balances in from-year and carry only balance accounts.
      const bal = accountBalances(fromYearId); // signed: +debit, -credit
      const lines = Object.keys(bal)
        .filter(acc => isBalanceAccount(acc))
        .map(acc => ({ account: acc, text: `IB från ${fromYearId}`, amount: bal[acc] }))
        .filter(l => Math.abs(l.amount) > 0.00001)
        .sort((a,b)=> String(a.account).localeCompare(String(b.account)));

      if (!lines.length){
        showToast("Inga balanskonto-saldon att föra över (alla 0).", 5000);
        return;
      }

      const sum = lines.reduce((s,l)=> s + l.amount, 0);
      if (Math.abs(sum) > 0.005){
        console.error("IB carry not balanced", { fromYearId, toYearId, sum, lines });
        showToast("Kan inte skapa IB: summering är inte 0. Kontrollera att föregående år är bokslutet (alla resultatkonton är nollade).", 8000);
        return;
      }

      const series = "A";
      const no = nextVoucherNo(toYearId, series);
      const v = {
        id: crypto.randomUUID(),
        yearId: toYearId,
        series,
        no,
        date: toStart,
        text: "Ingående balans",
        regDate: todayISO(),
        sign: clampText((state.company && state.company.defaultSign) ? state.company.defaultSign : ""),
        lines,
        correctionOf: null,
        status: "active",
        meta: { kind: "opening_balance", fromYearId }
      };

      state.vouchers = state.vouchers || [];
      state.vouchers.push(v);
      save();

      try { renderVouchers(); } catch (err){ console.error(err); }
      showToast(`Skapade IB-verifikation (${toYearId} ${series}${no}) från ${fromYearId}.`, 6500);
    });
  }


  function makeLine(){
    // default first account to 1930 if exists
    const defaultAcc = state.accounts["1930"] ? "1930" : Object.keys(state.accounts)[0] || "";
    return { account: defaultAcc, text: "", debit: "", credit: "" };
  }

  function renderLines(){
    linesTbody.innerHTML = "";
    const accList = Object.keys(state.accounts).sort((a,b)=>a.localeCompare(b,"sv"));

    currentLines.forEach((ln, idx) => {
      const tr = document.createElement("tr");

      // account select
      const tdAcc = document.createElement("td");
      const sel = document.createElement("select");
      sel.style.width = "100%";
      accList.forEach(no => {
        const opt = document.createElement("option");
        opt.value = no;
        opt.textContent = accountLabel(no);
        sel.appendChild(opt);
      });
      if (!state.accounts[ln.account] && ln.account) {
        // allow unknown
        const opt = document.createElement("option");
        opt.value = ln.account;
        opt.textContent = accountLabel(ln.account);
        sel.insertBefore(opt, sel.firstChild);
      }
      sel.value = ln.account;
      sel.disabled = voucherEditorReadOnly;
      sel.addEventListener("change", () => { ln.account = sel.value; updateBalanceBadge(); });
      tdAcc.appendChild(sel);

      // text
      const tdText = document.createElement("td");
      const inpText = document.createElement("input");
      inpText.value = ln.text;
      inpText.placeholder = "valfritt";
      inpText.disabled = voucherEditorReadOnly;
      inpText.addEventListener("input", () => ln.text = inpText.value);
      tdText.appendChild(inpText);

      // debit
      const tdD = document.createElement("td"); tdD.className = "right";
      const inpD = document.createElement("input");
      inpD.inputMode = "decimal";
      inpD.placeholder = "0";
      inpD.value = ln.debit;
      inpD.disabled = voucherEditorReadOnly;
      inpD.addEventListener("input", () => {
        ln.debit = inpD.value;
        if (parseMoney(ln.debit) !== 0) {
          ln.credit = "";
          try { inpC.value = ""; } catch (_) {}
        }
        updateBalanceBadge();
      });
      tdD.appendChild(inpD);

      // credit
      const tdC = document.createElement("td"); tdC.className = "right";
      const inpC = document.createElement("input");
      inpC.inputMode = "decimal";
      inpC.placeholder = "0";
      inpC.value = ln.credit;
      inpC.disabled = voucherEditorReadOnly;
      inpC.addEventListener("input", () => {
        ln.credit = inpC.value;
        if (parseMoney(ln.credit) !== 0) {
          ln.debit = "";
          try { inpD.value = ""; } catch (_) {}
        }
        updateBalanceBadge();
      });
      tdC.appendChild(inpC);

      // delete
      const tdX = document.createElement("td");
      const bx = document.createElement("button");
      bx.className = "btn secondary";
      bx.textContent = "✕";
      bx.title = "Ta bort rad";
      bx.disabled = voucherEditorReadOnly;
      bx.addEventListener("click", () => {
        currentLines.splice(idx, 1);
        if (currentLines.length === 0) currentLines.push(makeLine());
        renderLines();
        updateBalanceBadge();
      });
      tdX.appendChild(bx);

      tr.appendChild(tdAcc);
      tr.appendChild(tdText);
      tr.appendChild(tdD);
      tr.appendChild(tdC);
      tr.appendChild(tdX);
      linesTbody.appendChild(tr);
    });
  }

  function voucherTotals(){
    const deb = currentLines.reduce((s,ln)=> s + Math.max(0, parseMoney(ln.debit)), 0);
    const cre = currentLines.reduce((s,ln)=> s + Math.max(0, parseMoney(ln.credit)), 0);
    return { deb, cre, diff: deb - cre };
  }

  function updateBalanceBadge(){
    const { deb, cre, diff } = voucherTotals();
    const ok = Math.abs(diff) < 0.00001 && deb > 0;
    balanceBadge.className = "status " + (ok ? "ok" : "bad");
    balanceBadge.textContent = ok ? `I balans (${fmtSEK(deb)})` : `Diff: ${fmtSEK(diff)}`;
    btnSaveVoucher.disabled = voucherEditorReadOnly ? true : !ok;
  }

  function sanitizeVoucherLines(){
    // returns signed amounts: +debit, -credit
    return currentLines
      .map(ln => {
        const d = parseMoney(ln.debit);
        const c = parseMoney(ln.credit);
        const amount = d > 0 ? d : (c > 0 ? -c : 0);
        return {
          account: String(ln.account || "").trim(),
          text: clampText(ln.text || ""),
          amount: Math.round(amount * 100) / 100
        };
      })
      .filter(ln => ln.account && Math.abs(ln.amount) > 0.00001);
  }

  function getYear(id){ return state.fiscalYears.find(y => y.id === id); }


  function lockUntilForYear(yearId){
    const v = state.locks && state.locks[yearId];
    return (typeof v === "string" && v.length >= 10) ? v.slice(0,10) : "";
  }
  function isLockedVoucher(v){
    if (!v) return false;
    const until = lockUntilForYear(v.yearId || state.activeYearId);
    if (!until) return false;
    return (v.date || "") <= until;
  }

  function isVoidedVoucher(v){
    if (!v) return false;
    const st = String(v.status || "").toLowerCase();
    return st === "voided" || !!v.voidedAt || (v.voided === true);
  }

  function round2(n){ return Math.round((Number(n)||0)*100)/100; }

  function summarizeVoucher(v){
    if (!v) return null;
    const lines = Array.isArray(v.lines) ? v.lines : [];
    let deb = 0, cre = 0, sum = 0;
    for (const l of lines){
      const a = Number(l.amount)||0;
      sum += a;
      if (a > 0) deb += a;
      else if (a < 0) cre += -a;
    }
    return {
      id: v.id,
      yearId: v.yearId,
      series: v.series,
      no: v.no,
      date: v.date,
      text: clampText(v.text||"", 80),
      sign: v.sign || "",
      status: isVoidedVoucher(v) ? "voided" : "active",
      correctionOf: v.correctionOf || null,
      lineCount: lines.length,
      deb: round2(deb),
      cre: round2(cre),
      sum: round2(sum)
    };
  }

  function appendAudit(evt){
    try {
      state.auditLog = Array.isArray(state.auditLog) ? state.auditLog : [];
      state.auditSeq = (typeof state.auditSeq === "number" && Number.isFinite(state.auditSeq)) ? state.auditSeq : 0;
      state.auditSeq += 1;

      const entry = {
        id: crypto.randomUUID(),
        seq: state.auditSeq,
        ts: new Date().toISOString(),
        actor: clampText((state.company?.defaultSign || "").trim(), 60),
        ...evt
      };
      state.auditLog.push(entry);
    } catch (e){
      console.error("Audit append failed", e);
    }
  }

  // --- Underlag (bilagor) ---
  // Metadata stored in state.underlag; file blobs stored in IndexedDB under keys: "underlagBlob:<id>"
  function currentVoucherId(){
    // In editor: use viewingVoucherId if present, else draft for new voucher
    return (viewingVoucherId || editingVoucherId || draftVoucherId || "");
  }

  function padVerno(no){
    const s = String(no || "").trim();
    if (!s) return "";
    if (/^\d+$/.test(s)) return s.padStart(6, "0");
    return s;
  }

  function safeFileName(name){
    const s = String(name || "underlag").trim() || "underlag";
    // keep extension, remove path separators and problematic chars
    return s
      .replaceAll("\\", "_").replaceAll("/", "_")
      .replace(/[<>:"|?*\u0000-\u001F]/g, "_")
      .replace(/\s+/g, " ")
      .trim();
  }

  function underlagForVoucher(voucherId){
    const id = voucherId || currentVoucherId();
    return (state.underlag || []).filter(u => u && u.voucherId === id);
  }

  function renderUnderlagInto(targetEl, voucherId){
    if (!targetEl) return;
    const id = voucherId || "";
    const items = (state.underlag || []).filter(u => u && u.voucherId === id);
    targetEl.innerHTML = "";
    if (!items.length){
      const empty = document.createElement("div");
      empty.className = "muted small";
      empty.textContent = "Inga underlag kopplade ännu.";
      targetEl.appendChild(empty);
      return;
    }

    // newest first
    items.slice().sort((a,b)=> (b.createdAt||"").localeCompare(a.createdAt||"", "sv")).forEach(u=>{
      const div = document.createElement("div");
      const st = String(u.status || "active");
      div.className = "item" + (st === "detached" ? " voided" : "");
      const tag = (st === "detached") ? '<span class="status">Bortkopplat</span>' : '<span class="status ok">Kopplat</span>';
      const meta = [
        u.type ? ("Typ: " + u.type) : "",
        u.ref ? ("ID: " + u.ref) : "",
        u.note ? ("Not: " + u.note) : "",
        u.createdAt ? ("Tillagd: " + String(u.createdAt).slice(0,10)) : "",
        u.ocrTs ? ("OCR: " + String(u.ocrTs).slice(0,10)) : "",
        (u.size ? ("Storlek: " + Math.round((Number(u.size)||0)/1024) + " KB") : "")
      ].filter(Boolean).join(" · ");

      const canDetach = (st !== "detached"); // we keep blob for traceability; detaching just changes status + audit
      const detachBtn = canDetach ? `<button type="button" class="btn danger" data-act="detach-underlag" data-id="${escapeAttr(u.id)}">Koppla bort</button>` : "";
      const openBtn = `<button type="button" class="btn secondary" data-act="open-underlag" data-id="${escapeAttr(u.id)}">Öppna</button>`;
      const ocrBtn = (targetEl && targetEl.dataset && targetEl.dataset.ocr === "supplierinvoice" && st !== "detached")
        ? `<button type="button" class="btn secondary" data-act="ocr-underlag" data-id="${escapeAttr(u.id)}">OCR</button>`
        : "";

      div.innerHTML = `
        <div class="top">
          <div>
            <div class="title">${escapeHtml(u.fileName || "underlag")} ${tag}</div>
            <div class="meta">${escapeHtml(meta)}</div>
          </div>
          <div class="row">
            ${openBtn}
            ${ocrBtn}
            ${detachBtn}
          </div>
        </div>
      `;
      targetEl.appendChild(div);
    });
  }

  function renderUnderlag(voucherId){
    const id = voucherId || currentVoucherId();
    renderUnderlagInto(uList, id);
  }

  async function addUnderlagFiles(fileList){
    const files = Array.from(fileList || []);
    if (!files.length) return;

    const voucherId = currentVoucherId();
    const yearId = (yearSelect && yearSelect.value) || state.activeYearId;
    const series = (vSeries && vSeries.value ? vSeries.value : "").trim();
    const no = (vNo && vNo.value ? vNo.value : "").trim();
    const date = (vDate && vDate.value ? vDate.value : "");

    const type = uType ? String(uType.value || "annat") : "annat";
    const ref = uRef ? clampText(String(uRef.value || "").trim(), 120) : "";
    const note = uNote ? clampText(String(uNote.value || "").trim(), 240) : "";

    state.underlag = Array.isArray(state.underlag) ? state.underlag : [];

    for (const f of files){
      const id = crypto.randomUUID();
      const rec = {
        id,
        voucherId,
        yearId,
        series,
        no,
        date,
        type,
        ref,
        note,
        fileName: safeFileName(f.name),
        mime: f.type || "",
        size: f.size || 0,
        status: "active",
        createdAt: new Date().toISOString(),
        createdBy: clampText((state.company?.defaultSign || "").trim(), 60)
      };
      state.underlag.push(rec);
      try { await idbSet("underlagBlob:" + id, f); } catch (e){ console.error(e); showToast("Kunde inte spara underlaget lokalt (IndexedDB).", 6500); }
      appendAudit({ action:"underlag.add", actor: rec.createdBy || undefined, entityType:"underlag", entityId:id, yearId, details:{ voucherId, series, no, date, type, ref, fileName: rec.fileName, size: rec.size } });
    }
    save();
    renderUnderlag();
    try { renderVouchers(); } catch (e){}
    showToast(`Lade till ${files.length} underlag.`, 3500);
  }

  async function openUnderlag(id){
    const rec = (state.underlag||[]).find(u=>u && u.id===id);
    if (!rec) return showToast("Underlaget hittades inte.", 3500);
    const blob = await idbGet("underlagBlob:" + id);
    if (!blob) return showToast("Filen finns inte kvar lokalt (IndexedDB).", 6500);
    const url = URL.createObjectURL(blob);
    window.open(url, "_blank");
    setTimeout(()=>{ try { URL.revokeObjectURL(url); } catch {} }, 60_000);
  }

  async function detachUnderlag(id){
    const rec = (state.underlag||[]).find(u=>u && u.id===id);
    if (!rec) return;
    if (String(rec.status||"") === "detached") return;

    const ok = await confirmAsync("Koppla bort underlaget? (Filen ligger kvar lokalt för spårbarhet, men markeras som bortkopplad.)");
    if (!ok) return;

    rec.status = "detached";
    rec.detachedAt = new Date().toISOString();
    rec.detachedBy = clampText((state.company?.defaultSign || "").trim(), 60);

    appendAudit({ action:"underlag.detach", actor: rec.detachedBy || undefined, entityType:"underlag", entityId:id, yearId: rec.yearId, details:{ voucherId: rec.voucherId, fileName: rec.fileName, detachedAt: rec.detachedAt } });
    save();
    renderUnderlag();
    try { renderVouchers(); } catch (e){}
  }


  // --- OCR (offline) for Leverantörsfakturor ---
  // OCR depends on external libs (Tesseract.js + PDF.js). They are loaded via <script> tags above.
  // If OCR "havererar" p.g.a. blockerad CDN / offline kan du lägga lokala kopior i ./vendor/ bredvid HTML-filen:
  //   vendor/tesseract.min.js
  //   vendor/worker.min.js
  //   vendor/tesseract-core.wasm.js
  //   vendor/pdf.min.js
  //   vendor/pdf.worker.min.js
  // Valfritt (för helt offline språkfiler): vendor/tessdata/{swe,eng}.traineddata.gz
  const OCR_LIBS = {
    tesseract: [
      "./vendor/tesseract.min.js",
      "https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js",
      "https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"
    ],
    pdfjs: [
      "./vendor/pdf.min.js",
      "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/legacy/build/pdf.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js",
      "https://unpkg.com/pdfjs-dist@4.0.379/legacy/build/pdf.min.js"
    ],
    pdfWorker: [
      "./vendor/pdf.worker.min.js",
      "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/legacy/build/pdf.worker.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js",
      "https://unpkg.com/pdfjs-dist@4.0.379/legacy/build/pdf.worker.min.js"
    ],
    tesseractWorker: [
      "./vendor/worker.min.js",
      "https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/worker.min.js",
      "https://unpkg.com/tesseract.js@5/dist/worker.min.js"
    ],
    tesseractCore: [
      "./vendor/tesseract-core.wasm.js",
      "https://cdn.jsdelivr.net/npm/tesseract.js-core@5/tesseract-core.wasm.js",
      "https://unpkg.com/tesseract.js-core@5/tesseract-core.wasm.js"
    ],
    tessdataBases: [
      "./vendor/tessdata", // folder with traineddata.gz
      "https://tessdata.projectnaptha.com/4.0.0"
    ]
  };

  const _scriptOnce = new Set();
  async function loadScriptOnce(url){
    if (!url) return false;
    if (_scriptOnce.has(url)) return true;
    return await new Promise((resolve)=>{
      const s = document.createElement("script");
      s.src = url;
      s.async = true;
      s.onload = ()=>{ _scriptOnce.add(url); resolve(true); };
      s.onerror = ()=> resolve(false);
      document.head.appendChild(s);
    });
  }
  async function urlSeemsReachable(url, timeoutMs){
    const toMs = (typeof timeoutMs === 'number' && timeoutMs > 0) ? timeoutMs : 2500;
    const tryFetch = async (method)=>{
      const ctl = new AbortController();
      const t = setTimeout(()=>{ try{ctl.abort();}catch{} }, toMs);
      try{
        const r = await fetch(url, { method, cache: 'no-store', signal: ctl.signal });
        return !!(r && r.ok);
      } catch {
        return false;
      } finally {
        try{ clearTimeout(t); } catch {}
      }
    };
    // HEAD first, then GET
    if (await tryFetch('HEAD')) return true;
    return await tryFetch('GET');
  }

  async function pickFirstReachable(urls){
    const list = (urls||[]).filter(Boolean);
    for (const u of list){
      const s = String(u);
      const isLocal = s.startsWith('./');
      const ok = await urlSeemsReachable(s, isLocal ? 800 : 1500);
      if (ok) return s;
    }
    return list.length ? String(list[list.length-1]) : '';
  }

  async function ensureOcrDeps(){
    // Try load missing libs if they didn't load via <script defer ...>
    if (typeof Tesseract === "undefined"){
      for (const url of OCR_LIBS.tesseract){
        const ok = await loadScriptOnce(url);
        if (ok && typeof Tesseract !== "undefined") break;
      }
    }
    if (typeof pdfjsLib === "undefined"){
      for (const url of OCR_LIBS.pdfjs){
        const ok = await loadScriptOnce(url);
        if (ok && typeof pdfjsLib !== "undefined") break;
      }
    }
    if (typeof Tesseract === "undefined"){
      showToast("OCR-motorn (Tesseract.js) kunde inte laddas. Om du kör offline eller har blockerade CDN: anslut till internet första gången, eller lägg biblioteket lokalt i ./vendor/.", 9500);
      return false;
    }
    // pdfjsLib is only required for PDF. Images can OCR without it.
    return true;
  }

  let _pdfjsConfigured = false;
  async function ensurePdfjs(){
    try{
      if (_pdfjsConfigured) return true;
      if (typeof pdfjsLib === "undefined") return false;
      const worker = await pickFirstReachable(OCR_LIBS.pdfWorker);
      try { pdfjsLib.GlobalWorkerOptions.workerSrc = worker; } catch {}
      try { pdfjsLib.disableWorker = true; } catch {}
      _pdfjsConfigured = true;
      return true;
    } catch (e){
      return false;
    }
  }

  async function resolveTesseractPaths(lang){
    const workerPath = await pickFirstReachable(OCR_LIBS.tesseractWorker);
    const corePath = await pickFirstReachable(OCR_LIBS.tesseractCore);

    // Prefer local tessdata folder only if required traineddata exists.
    let langPath = OCR_LIBS.tessdataBases[1];
    const parts = String(lang||"eng").split("+").map(x=>x.trim()).filter(Boolean);
    for (const base of OCR_LIBS.tessdataBases){
      if (!base) continue;
      if (String(base).startsWith("./")){
        const b = String(base).replace(/\/+$/g, "");
        let ok = true;
        for (const p of (parts.length ? parts : ["eng"])){
          const probe = `${b}/${p}.traineddata.gz`;
          if (!(await urlSeemsReachable(probe))){ ok = false; break; }
        }
        if (ok){ langPath = b; break; }
      } else {
        langPath = base;
        break;
      }
    }

    return { workerPath, corePath, langPath };
  }

  function setSiOcrStatus(kind, msg){
    if (!siOcrStatus) return;
    siOcrStatus.className = "status" + (kind ? (" " + kind) : "");
    siOcrStatus.textContent = msg || "–";
  }

  function hideSiOcrPanel(clear){
    if (siOcrPanel) siOcrPanel.hidden = true;
    if (clear){
      siOcrCtx = { underlagId: null, lang: (siOcrLang ? (siOcrLang.value||"swe+eng") : "swe+eng"), pdfPages: (siOcrPdfPages ? (siOcrPdfPages.value||"1") : "1"), fields: {}, text: "", textSha256: "" };
      if (siOcrText) siOcrText.value = "";
      if (siOcrFileInfo) siOcrFileInfo.textContent = "";
      if (siOcrFieldsTbody) siOcrFieldsTbody.innerHTML = "";
      setSiOcrStatus("", "–");
      if (btnSiOcrRun) btnSiOcrRun.disabled = true;
    }
  }

  function round2(n){ return Math.round((Number(n)||0) * 100) / 100; }

  function isoFromAnyDate(s){
    const str = String(s||"").trim();
    if (!str) return "";
    // yyyy-mm-dd
    let m = str.match(/\b(20\d{2})[-\/.](\d{2})[-\/.](\d{2})\b/);
    if (m) return `${m[1]}-${m[2]}-${m[3]}`;
    // dd-mm-yyyy or dd/mm/yyyy
    m = str.match(/\b(\d{2})[-\/.](\d{2})[-\/.](\d{2,4})\b/);
    if (m){
      let yy = String(m[3]);
      if (yy.length === 2) yy = "20" + yy;
      const dd = m[1], mm = m[2];
      // basic sanity
      if (Number(mm) >= 1 && Number(mm) <= 12 && Number(dd) >= 1 && Number(dd) <= 31){
        return `${yy}-${mm}-${dd}`;
      }
    }
    return "";
  }

  function normalizeOcrText(t){
    return String(t||"")
      .replace(/\u00a0/g, " ")
      .replace(/\r/g, "")
      .replace(/[ \t]+/g, " ")
      .trim();
  }

  function findLines(t){
    return normalizeOcrText(t).split("\n").map(x=>String(x||"").trim()).filter(Boolean);
  }

  function findByLabel(lines, labelRe, valueRe){
    for (let i=0;i<lines.length;i++){
      const line = lines[i];
      if (!labelRe.test(line)) continue;

      // try same line
      let m = valueRe ? line.match(valueRe) : null;
      if (m && (m[1] || m[0])) return { value: (m[1] || m[0]).trim(), score: 0.92, src: "sameLine" };

      // after colon
      const idx = line.indexOf(":");
      if (idx >= 0){
        const after = line.slice(idx+1).trim();
        if (after){
          if (valueRe){
            m = after.match(valueRe);
            if (m && (m[1] || m[0])) return { value: (m[1] || m[0]).trim(), score: 0.9, src: "afterColon" };
          }
          return { value: after, score: 0.85, src: "afterColon" };
        }
      }

      // try next line
      const nxt = lines[i+1] || "";
      if (nxt){
        m = valueRe ? nxt.match(valueRe) : null;
        if (m && (m[1] || m[0])) return { value: (m[1] || m[0]).trim(), score: 0.8, src: "nextLine" };
        return { value: nxt.trim(), score: 0.7, src: "nextLine" };
      }
    }
    return { value:"", score:0, src:"" };
  }

  function extractAmountsFromLine(line){
    const s = String(line||"");
    const re = /(\d{1,3}(?:[ \u00a0]\d{3})*(?:[.,]\d{2})|\d+(?:[.,]\d{2}))/g;
    const out = [];
    let m;
    while ((m = re.exec(s))){
      const raw = m[1];
      const val = round2(parseMoney(raw));
      if (Number.isFinite(val) && val > 0 && val < 1e9) out.push({ raw, val });
    }
    return out;
  }

  function findAmountByKeywords(lines, keywords, preferLargest){
    let best = { value:"", score:0, num:0 };
    for (const line of lines){
      const low = line.toLowerCase();
      const hits = keywords.filter(k => low.includes(k)).length;
      if (!hits) continue;
      const amts = extractAmountsFromLine(line);
      if (!amts.length) continue;
      for (const a of amts){
        // score: keyword hits + reasonableness
        let sc = 0.6 + Math.min(0.35, hits*0.12);
        // prefer "larger" for total
        const val = a.val;
        if (preferLargest) sc += Math.min(0.2, Math.log10(1+val)/10);
        if (sc > best.score || (Math.abs(sc-best.score) < 0.02 && val > best.num)){
          best = { value: String(val).replace(".", ","), score: Math.min(0.95, sc), num: val };
        }
      }
    }
    return best;
  }

  function normalizeOrgnr(s){
    const t = String(s||"").replace(/\s+/g,"").trim();
    const m = t.match(/^(\d{6})-?(\d{4})$/);
    if (!m) return "";
    return m[1] + "-" + m[2];
  }

  function guessSupplierName(lines){
    const bad = ["faktura","invoice","kvitto","kvitt","org.nr","organisations","moms","vat","summa","totalt","att betala","bankgiro","plusgiro","bg","pg","ocr","förfall","due","datum","fakturadatum","kund","kundnr"];
    for (const line of lines.slice(0,12)){
      const t = line.trim();
      if (!t) continue;
      const low = t.toLowerCase();
      if (bad.some(b=> low.includes(b))) continue;
      if (/\d/.test(t)) continue;
      if (t.length < 3 || t.length > 60) continue;
      return { value: t, score: 0.55, src:"topGuess" };
    }
    return { value:"", score:0, src:"" };
  }

  function parseInvoiceFieldsFromOcr(text){
    const lines = findLines(text);

    const supplierName = (() => {
      const v = findByLabel(lines, /(leverantör|supplier|från|from)\b/i, /:\s*(.+)$/i);
      if (v.value) return { value: clampText(v.value, 120), score: v.score, src:"label" };
      return guessSupplierName(lines);
    })();

    const orgnr = (() => {
      const lbl = findByLabel(lines, /(org\.?nr|organisations?nummer|vat\s*nr|momsreg\.?nr)\b/i, /(\d{6}[- ]?\d{4})/);
      if (lbl.value) return { value: normalizeOrgnr(lbl.value), score: lbl.score, src:"label" };
      // fallback scan
      for (const line of lines){
        const m = line.match(/\b(\d{6})[- ]?(\d{4})\b/);
        if (m) return { value: `${m[1]}-${m[2]}`, score: 0.6, src:"scan" };
      }
      return { value:"", score:0, src:"" };
    })();

    const payout = (() => {
      const lbl = findByLabel(lines, /(bankgiro|plusgiro|bg|pg)\b/i, /(\d{3,4}-\d{3,4})/);
      if (lbl.value) return { value: clampText(lbl.value, 80), score: lbl.score, src:"label" };
      for (const line of lines){
        const m = line.match(/\b(\d{3,4}-\d{3,4})\b/);
        if (m) return { value: m[1], score: 0.55, src:"scan" };
      }
      return { value:"", score:0, src:"" };
    })();

    const invoiceNo = (() => {
      const v = findByLabel(lines, /(faktura\s*(nr|nummer)|fakturanr|invoice\s*(no|nr)|faktura#)\b/i, /([A-Za-z0-9\-\/]{3,30})/);
      if (v.value) return { value: clampText(v.value, 80), score: v.score, src:"label" };
      return { value:"", score:0, src:"" };
    })();

    const ocrRef = (() => {
      const v = findByLabel(lines, /\bocr\b|referens|reference/i, /(\d{6,25})/);
      if (v.value) return { value: clampText(v.value, 80), score: v.score, src:"label" };
      return { value:"", score:0, src:"" };
    })();

    const date = (() => {
      const v = findByLabel(lines, /(fakturadatum|invoice\s*date|datum)\b/i, /(\d{2,4}[-\/.]\d{2}[-\/.]\d{2,4})/);
      const iso = isoFromAnyDate(v.value);
      if (iso) return { value: iso, score: v.score || 0.8, src:"label" };
      // fallback: first date on doc
      for (const line of lines){
        const m = line.match(/\b(20\d{2}[-\/.]\d{2}[-\/.]\d{2})\b/);
        if (m) return { value: isoFromAnyDate(m[1]), score:0.55, src:"scan" };
        const m2 = line.match(/\b(\d{2}[-\/.]\d{2}[-\/.]\d{2,4})\b/);
        if (m2){
          const d = isoFromAnyDate(m2[1]);
          if (d) return { value: d, score:0.5, src:"scan" };
        }
      }
      return { value:"", score:0, src:"" };
    })();

    const due = (() => {
      const v = findByLabel(lines, /(förfallodatum|due\s*date|betalas\s*senast|förfaller)\b/i, /(\d{2,4}[-\/.]\d{2}[-\/.]\d{2,4})/);
      const iso = isoFromAnyDate(v.value);
      if (iso) return { value: iso, score: v.score || 0.75, src:"label" };
      return { value:"", score:0, src:"" };
    })();

    const vat = findAmountByKeywords(lines, ["moms","vat"], false);
    const gross = findAmountByKeywords(lines, ["summa att betala","att betala","totalt","total","belopp","summa"], true);

    // sanity: if vat > gross, un-use vat
    let vatOut = vat;
    if (vatOut.num && gross.num && vatOut.num > gross.num){
      vatOut = { value:"", score:0, num:0 };
    }

    return {
      supplierName,
      supplierOrgnr: orgnr,
      supplierPayout: payout,
      invoiceNo,
      ocr: ocrRef,
      date,
      due,
      gross,
      vat: vatOut
    };
  }

  function siOcrFieldConfig(){
    return [
      { key:"supplierName", label:"Leverantör (namn)", target: siSupplierName },
      { key:"supplierOrgnr", label:"Org.nr", target: siSupplierOrgnr },
      { key:"supplierPayout", label:"BG/PG", target: siSupplierPayout },
      { key:"invoiceNo", label:"Fakturanr", target: siInvoiceNo },
      { key:"ocr", label:"OCR/Referens", target: siOcr },
      { key:"date", label:"Fakturadatum", target: siDate },
      { key:"due", label:"Förfallodatum", target: siDue },
      { key:"gross", label:"Belopp inkl moms", target: siGross },
      { key:"vat", label:"Momsbelopp", target: siVat },
    ];
  }

  function renderSiOcrFields(){
    if (!siOcrFieldsTbody) return;
    const cfg = siOcrFieldConfig();
    siOcrFieldsTbody.innerHTML = "";
    cfg.forEach(c=>{
      const f = siOcrCtx.fields?.[c.key] || { value:"", score:0, use:false };
      const tr = document.createElement("tr");

      const tdUse = document.createElement("td");
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = !!f.use;
      cb.addEventListener("change", ()=>{ siOcrCtx.fields[c.key].use = cb.checked; });
      tdUse.appendChild(cb);

      const tdLabel = document.createElement("td");
      tdLabel.textContent = c.label;

      const tdVal = document.createElement("td");
      const inp = document.createElement("input");
      inp.value = f.value || "";
      inp.placeholder = "–";
      inp.addEventListener("input", ()=>{ siOcrCtx.fields[c.key].value = inp.value; });
      tdVal.appendChild(inp);

      const tdScore = document.createElement("td");
      tdScore.className = "right muted";
      const pct = Math.round((Number(f.score)||0) * 100);
      tdScore.textContent = (pct ? (pct + "%") : "–");

      tr.appendChild(tdUse);
      tr.appendChild(tdLabel);
      tr.appendChild(tdVal);
      tr.appendChild(tdScore);
      siOcrFieldsTbody.appendChild(tr);
    });
  }

  function showSiOcrPanelFor(underlagRec){
    if (!siOcrPanel) return;
    siOcrPanel.hidden = false;
    if (siOcrLang) siOcrLang.value = siOcrCtx.lang || (siOcrLang.value || "swe+eng");
    if (siOcrPdfPages) siOcrPdfPages.value = siOcrCtx.pdfPages || (siOcrPdfPages.value || "1");
    if (siOcrFileInfo) siOcrFileInfo.textContent = underlagRec ? (`Fil: ${underlagRec.fileName||""}`) : "";
    if (btnSiOcrRun) btnSiOcrRun.disabled = !siOcrCtx.underlagId;
  }

  function matchSupplierId(name, orgnr){
    const org = normalizeOrgnr(orgnr);
    const n = String(name||"").trim().toLowerCase();
    const sups = state.suppliers || {};
    // exact orgnr match wins
    if (org){
      for (const [id, s] of Object.entries(sups)){
        if (!s) continue;
        if (normalizeOrgnr(s.orgnr) === org) return id;
      }
    }
    if (n){
      for (const [id, s] of Object.entries(sups)){
        const sn = String(s?.name||"").trim().toLowerCase();
        if (!sn) continue;
        if (sn === n) return id;
      }
      for (const [id, s] of Object.entries(sups)){
        const sn = String(s?.name||"").trim().toLowerCase();
        if (!sn) continue;
        if (sn.includes(n) || n.includes(sn)) return id;
      }
    }
    return "";
  }

  function applySiOcrToForm(){
    if (!siOcrCtx || !siOcrCtx.fields) return;
    const cfg = siOcrFieldConfig();
    const applied = {};
    for (const c of cfg){
      const f = siOcrCtx.fields[c.key];
      if (!f || !f.use) continue;
      const val = String(f.value||"").trim();
      if (!val) continue;
      if (c.target){
        c.target.value = val;
        // trigger dependent calc
        try { c.target.dispatchEvent(new Event("input", { bubbles:true })); } catch {}
        applied[c.key] = val;
      }
    }

    // try auto-match supplier from registry
    try {
      const sid = matchSupplierId(siSupplierName?.value, siSupplierOrgnr?.value);
      if (sid && siSupplierSelect){
        siSupplierSelect.value = sid;
        try { siSupplierSelect.dispatchEvent(new Event("change", { bubbles:true })); } catch {}
      }
    } catch {}

    // keep net in sync
    try { siRecalcNet(); } catch {}
    try { siSetSaveEnabled(); } catch {}

    const actor = clampText((state.company?.defaultSign || "").trim(), 60);
    currentSiOcrMeta = {
      ts: new Date().toISOString(),
      engine: "tesseract.js",
      underlagId: siOcrCtx.underlagId,
      lang: siOcrCtx.lang,
      pdfPages: siOcrCtx.pdfPages,
      ocrTextSha256: siOcrCtx.textSha256 || "",
      confirmedFields: applied
    };
    appendAudit({ action:"supplierInvoice.ocr.apply", actor: actor || undefined, entityType:"supplierInvoice", entityId: editingSupplierInvoiceId || "draft", yearId: (state.activeYearId||""), details:{ underlagId: siOcrCtx.underlagId, confirmedFields: applied } });
    save();

    showToast(Object.keys(applied).length ? "OCR-fält infyllda. Granska och spara leverantörsfakturan." : "Inga OCR-fält valda att använda.", 5500);
  }

  async function blobToCanvasImage(blob){
    // Convert an image blob to canvas (scaled to a reasonable size)
    const maxDim = 2400;
    let bmp = null;
    try { bmp = await createImageBitmap(blob); } catch {}
    if (bmp){
      const w0 = bmp.width || 1, h0 = bmp.height || 1;
      const scale = Math.min(1, maxDim / Math.max(w0, h0));
      const w = Math.max(1, Math.round(w0 * scale));
      const h = Math.max(1, Math.round(h0 * scale));
      const canvas = document.createElement("canvas");
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(bmp, 0, 0, w, h);
      try { bmp.close(); } catch {}
      return canvas;
    }

    // fallback via <img>
    const url = URL.createObjectURL(blob);
    try {
      const img = await new Promise((resolve, reject)=>{
        const im = new Image();
        im.onload = ()=> resolve(im);
        im.onerror = reject;
        im.src = url;
      });
      const w0 = img.naturalWidth || 1, h0 = img.naturalHeight || 1;
      const scale = Math.min(1, maxDim / Math.max(w0, h0));
      const w = Math.max(1, Math.round(w0 * scale));
      const h = Math.max(1, Math.round(h0 * scale));
      const canvas = document.createElement("canvas");
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, w, h);
      return canvas;
    } finally {
      try { URL.revokeObjectURL(url); } catch {}
    }
  }

  async function pdfBlobToCanvases(blob, pageChoice){
    if (!(await ensurePdfjs())) throw new Error("pdfjs-missing");
    const ab = await blob.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: ab, disableWorker: true }).promise;
    const maxPages = pdf.numPages || 1;
    let want = 1;
    if (pageChoice === "all") want = maxPages;
    else want = Math.max(1, Number(pageChoice)||1);
    want = Math.min(want, maxPages);

    const canvases = [];
    for (let p=1; p<=want; p++){
      setSiOcrStatus("", `Renderar PDF sida ${p}/${want}…`);
      const page = await pdf.getPage(p);
      // scale up a bit for OCR, but cap size
      const v1 = page.getViewport({ scale: 2.0 });
      let w = Math.round(v1.width), h = Math.round(v1.height);
      const maxDim = 2600;
      const scale2 = Math.min(1, maxDim / Math.max(w, h));
      const viewport = page.getViewport({ scale: 2.0 * scale2 });
      w = Math.round(viewport.width); h = Math.round(viewport.height);

      const canvas = document.createElement("canvas");
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext("2d");
      await page.render({ canvasContext: ctx, viewport }).promise;
      canvases.push(canvas);
    }
    return canvases;
  }

  async function ocrUnderlagToSupplierInvoice(underlagId, opts){
    const u = (state.underlag||[]).find(x=>x && x.id===underlagId);
    if (!u) return showToast("Underlaget hittades inte.", 4500);

    if (!(await ensureOcrDeps())){
      setSiOcrStatus("bad", "OCR: bibliotek saknas");
      return;
    }

    const blob = await idbGet("underlagBlob:" + underlagId);
    if (!blob) return showToast("Filen finns inte kvar lokalt (IndexedDB).", 6500);

    // HEIC/HEIF (vanligt från iPhone) stöds inte säkert i webbläsar-OCR.
    try {
      const fn = String(u.fileName||"").toLowerCase();
      const mt = String(u.mime||"").toLowerCase();
      if (mt.includes("heic") || mt.includes("heif") || fn.endsWith(".heic") || fn.endsWith(".heif")){
        showToast("HEIC/HEIF stöds inte för OCR här. Konvertera till JPG/PNG eller PDF och ladda upp igen.", 9500);
        setSiOcrStatus("bad", "OCR: filformat stöds ej");
        return;
      }
    } catch {}


    // show panel + bind context
    siOcrCtx.underlagId = underlagId;
    siOcrCtx.lang = (siOcrLang ? (siOcrLang.value || siOcrCtx.lang || "swe+eng") : (siOcrCtx.lang || "swe+eng"));
    siOcrCtx.pdfPages = (siOcrPdfPages ? (siOcrPdfPages.value || siOcrCtx.pdfPages || "1") : (siOcrCtx.pdfPages || "1"));
    showSiOcrPanelFor(u);

    setSiOcrStatus("", "Förbereder OCR…");
    if (btnSiOcrRun) btnSiOcrRun.disabled = false;

    // Try reuse cached OCR unless rerun requested
    const rerun = !!(opts && opts.rerun);
    if (!rerun){
      try {
        const cached = await idbGet("underlagOcr:" + underlagId);
        if (cached && cached.text && cached.sha256){
          siOcrCtx.text = String(cached.text||"");
          siOcrCtx.textSha256 = String(cached.sha256||"");
          const parsed = parseInvoiceFieldsFromOcr(siOcrCtx.text);
          siOcrCtx.fields = {};
          Object.entries(parsed).forEach(([k,v])=>{
            const value = String(v.value||"").trim();
            const score = Number(v.score||0);
            siOcrCtx.fields[k] = { value, score, use: !!value && score >= 0.6 };
          });
          if (siOcrText) siOcrText.value = siOcrCtx.text;
          renderSiOcrFields();
          setSiOcrStatus("ok", "OCR (cache) klar");
          return;
        }
      } catch {}
    }

    // Build canvases
    let canvases = [];
    const isPdf = (String(u.mime||"").includes("pdf") || String(u.fileName||"").toLowerCase().endsWith(".pdf"));
    try {
      if (isPdf){
        canvases = await pdfBlobToCanvases(blob, siOcrCtx.pdfPages || "1");
      } else {
        canvases = [ await blobToCanvasImage(blob) ];
      }
    } catch (e){
      console.error(e);
      const em = String((e && e.message) ? e.message : e);
      if (em.includes("pdfjs-missing")) showToast("PDF-läsaren (pdf.js) kunde inte laddas. Om du kör via file:// eller har blockerat CDN: öppna via http://localhost eller lägg pdf.min.js + pdf.worker.min.js lokalt i ./vendor/.", 9500);
      else showToast("Kunde inte förbereda filen för OCR. Prova en bild (JPG/PNG) eller en enklare PDF.", 9000);
      setSiOcrStatus("bad", "OCR misslyckades");
      return;
    }

    // Run OCR
    let combined = "";
    const lang = siOcrCtx.lang || "swe+eng";
    const tPaths = await resolveTesseractPaths(lang);
    for (let i=0;i<canvases.length;i++){
      const pageNo = i+1;
      const totalPages = canvases.length;
      let lastPct = 0;
      setSiOcrStatus("", `OCR sida ${pageNo}/${totalPages}…`);      let res = null;
      try {
        res = await Tesseract.recognize(canvases[i], lang, {
          ...tPaths,
          logger: (m)=>{
            try {
              if (!m || !m.status) return;
              if (m.status === "recognizing text" && typeof m.progress === "number"){
                const pct = Math.round(m.progress * 100);
                if (pct !== lastPct){
                  lastPct = pct;
                  setSiOcrStatus("", `OCR sida ${pageNo}/${totalPages}… ${pct}%`);
                }
              }
            } catch {}
          }
        });
      } catch (e){
        console.error(e);
        const em = String((e && e.message) ? e.message : e);
        if (/(importscripts|importsc)/i.test(em)) {
          showToast("OCR-blockering: web worker kunde inte ladda filer (importScripts). Öppna appen via http://localhost (inte file://), eller lägg worker/core lokalt i ./vendor/.", 11000);
        } else if (/failed to fetch|load|network/i.test(em)) {
          showToast("OCR kunde inte ladda språkfiler/worker. Anslut till internet första gången (för swe/eng), eller lägg språkfiler i ./vendor/tessdata/.", 10000);
        } else {
          showToast("OCR misslyckades. Prova en skarpare bild/PDF och kör igen.", 9000);
        }
        setSiOcrStatus("bad", "OCR misslyckades");
        return;
      }
      const t = (res && res.data && res.data.text) ? String(res.data.text) : "";
      combined += (combined ? "\n\n" : "") + (totalPages > 1 ? (`--- SIDA ${pageNo}/${totalPages} ---\n`) : "") + t;
    }

    siOcrCtx.text = combined;
    siOcrCtx.textSha256 = await sha256Hex(combined);

    // Parse fields
    const parsed = parseInvoiceFieldsFromOcr(combined);
    siOcrCtx.fields = {};
    Object.entries(parsed).forEach(([k,v])=>{
      const value = String(v.value||"").trim();
      const score = Number(v.score||0);
      // default-use: decent confidence AND non-empty
      siOcrCtx.fields[k] = { value, score, use: !!value && score >= 0.6 };
    });

    // Update UI
    if (siOcrText) siOcrText.value = combined;
    renderSiOcrFields();
    setSiOcrStatus("ok", "OCR klar (granska fälten)");

    // Persist OCR (for traceability + faster re-open)
    try {
      const nowIso = new Date().toISOString();
      await idbSet("underlagOcr:" + underlagId, { ts: nowIso, lang, pdfPages: siOcrCtx.pdfPages, sha256: siOcrCtx.textSha256, text: combined, fields: parsed });
      u.ocrTs = nowIso;
      u.ocrLang = lang;
      u.ocrTextSha256 = siOcrCtx.textSha256;
      u.ocrFields = Object.fromEntries(Object.entries(parsed).map(([k,v])=> [k, String(v.value||"").trim()] ));
      appendAudit({ action:"underlag.ocr", entityType:"underlag", entityId: underlagId, yearId: u.yearId, details:{ fileName: u.fileName, lang, pdfPages: siOcrCtx.pdfPages, ocrTextSha256: siOcrCtx.textSha256 } });
      save();
      try { renderUnderlagInto(siUnderlagList, currentSiAttachTargetId); } catch {}
    } catch (e){
      console.error(e);
      // non-fatal
    }
  }

  function syncUnderlagVoucherMeta(voucher){
    if (!voucher) return;
    const id = voucher.id;
    const list = state.underlag || [];
    for (const u of list){
      if (!u || u.voucherId !== id) continue;
      u.yearId = voucher.yearId;
      u.series = voucher.series || u.series || "";
      u.no = voucher.no || u.no || "";
      u.date = voucher.date || u.date || "";
    }
  }



  function nextVerno(yearId, series){
    const seriesNorm = (series || "A").trim() || "A";
    const nums = state.vouchers
      .filter(v => v.yearId === yearId && (v.series || "") === seriesNorm)
      .map(v => Number(v.no))
      .filter(n => Number.isFinite(n));
    const max = nums.length ? Math.max(...nums) : 0;
    return String(max + 1);
  }

  function saveVoucher(){
    if (voucherEditorReadOnly) return showToast("Detta är en sparad verifikation i visningsläge. Använd Korrigera för att skapa en rättelseverifikation.", 6500);
    const yearId = yearSelect.value || state.activeYearId;
    const date = vDate.value || todayISO();
    if (editingVoucherId){
      const orig = state.vouchers.find(x=>x.id===editingVoucherId);
      if (orig && isLockedVoucher(orig)){
        showToast("Den här verifikationen ligger i låst period och kan inte ändras. Skapa en rättningsverifikation i stället.", 6500);
        return;
      }
    }
    const series = (vSeries.value || "A").trim() || "A";
    const no = (vNo.value || "").trim() || nextVerno(yearId, series);
    const text = clampText(vText.value || "");
    const sign = clampText((vSign.value || state.company.defaultSign || "").trim());
    const regDate = todayISO();
    const lines = sanitizeVoucherLines();

    // Validate balancing
    const sum = lines.reduce((s,l)=> s + l.amount, 0);
    if (Math.abs(sum) > 0.00001){
      showToast("Verifikationen är inte i balans. Kontrollera debet/kredit.", 5000);
      return;
    }

    const v = {
      id: editingVoucherId ?? draftVoucherId ?? crypto.randomUUID(),
      yearId,
      series,
      no,
      date,
      text,
      regDate,
      sign,
      lines,
      correctionOf: correctionOfId || null,
      status: "active"
    };

    const existing = state.vouchers.find(x => x.id === v.id) || null;
    appendAudit({
      action: existing ? "voucher.update" : "voucher.create",
      actor: sign || undefined,
      entityType: "voucher",
      entityId: v.id,
      yearId,
      details: { before: summarizeVoucher(existing), after: summarizeVoucher(v) }
    });

    const idx = state.vouchers.findIndex(x => x.id === v.id);
    if (idx >= 0) state.vouchers[idx] = v;
    else state.vouchers.push(v);

    // Sync underlag metadata for this voucher (series/no/date/year may have been auto-assigned)
    try { syncUnderlagVoucherMeta(v); } catch (e){ console.error(e); }

    // Keep list sorted for nicer export
    state.vouchers.sort((a,b)=> (a.yearId+b.series+a.no+a.date).localeCompare(b.yearId+a.series+b.no+b.date, "sv"));
    save();
    newVoucher();
    renderVouchers();
    // If user already generated a report, keep it in sync
    try { if (lastReportHtml) generateReport(); } catch (e){ console.error(e); }
  }

  function viewVoucherToEditor(id){
    const v = state.vouchers.find(x => x.id === id);
    if (!v) return;
    editingVoucherId = null;
    viewingVoucherId = v.id;
    voucherEditorReadOnly = true;
    const voided = isVoidedVoucher(v);
    if (voided){
      showToast("Verifikationen är makulerad. Den ligger kvar för spårbarhet, men räknas inte i rapporter/SIE.", 6500);
    }
    if (!voided && isLockedVoucher(v)){
      showToast("Verifikationen ligger i låst period. Du kan inte ändra originalet – jag skapar en rättningsverifikation som hänvisar till den.", 6500);
      createCorrectionVoucher(v.id);
      return;
    }
    yearSelect.value = v.yearId;
    vDate.value = v.date;
    vSeries.value = v.series;
    vNo.value = v.no;
    vText.value = v.text;
    vSign.value = v.sign;

    currentLines = v.lines.map(l => ({
      account: l.account,
      text: l.text || "",
      debit: l.amount > 0 ? String(Math.abs(l.amount)).replace(".", ",") : "",
      credit: l.amount < 0 ? String(Math.abs(l.amount)).replace(".", ",") : ""
    }));
    if (currentLines.length === 0) currentLines = [makeLine(), makeLine()];
    try { renderUnderlag(v.id); } catch (e){}
    renderLines();
    updateBalanceBadge();
  }

  function createCorrectionVoucher(originalId){
    const orig = state.vouchers.find(x=>x.id===originalId);
    if (!orig) return;

    // Decide year for correction: default same year if today within it, else active year
    let targetYearId = orig.yearId || state.activeYearId;
    const fy = getYear(targetYearId);
    const t = todayISO();
    if (!fy || !(fy.start <= t && t <= fy.end)){
      targetYearId = state.activeYearId;
    }

    // Switch editor to target year
    if (yearSelect) yearSelect.value = targetYearId;
    state.activeYearId = targetYearId;

    editingVoucherId = null;
    correctionOfId = orig.id;

    vDate.value = (getYear(targetYearId) && getYear(targetYearId).start <= todayISO() && todayISO() <= getYear(targetYearId).end)
      ? todayISO()
      : (getYear(targetYearId)?.end || todayISO());

    vSeries.value = "R";
    vNo.value = "";
    vText.value = `Rättelse av ${orig.series || ""}${orig.no || ""} (${orig.date})`;
    vSign.value = state.company.defaultSign || "";

    // Reverse lines (storno)
    currentLines = (orig.lines || []).map(l => {
      const amt = Number(l.amount)||0;
      return {
        account: l.account,
        text: `Rättelse: ${(l.text||orig.text||"").slice(0,80)}`,
        debit: amt < 0 ? String(Math.abs(amt)).replace(".", ",") : "",
        credit: amt > 0 ? String(Math.abs(amt)).replace(".", ",") : ""
      };
    });

    if (!currentLines.length) currentLines = [ makeLine(), makeLine() ];

    // Go to vouchers tab + render
    activateTab("vouchers");

    renderLines();
    updateBalanceBadge();
    showToast("Rättningsverifikation skapad som utkast. Justera vid behov och spara.", 5500);
  }

  // --- Calculations / Reports ---
  function yearVouchers(yearId){
    return state.vouchers.filter(v => v.yearId === yearId && !isVoidedVoucher(v));
  }

  function accountBalances(yearId){
    const bal = {}; // account -> signed balance (debit positive)
    yearVouchers(yearId).forEach(v => {
      v.lines.forEach(l => {
        bal[l.account] = (bal[l.account] || 0) + l.amount;
      });
    });
    // round
    Object.keys(bal).forEach(k => bal[k] = Math.round(bal[k]*100)/100);
    return bal;
  }

  function splitBSIS(bal){
    let assets = 0;
    let eqLiab = 0;
    let income = 0;
    let expense = 0;

    for (const [acc, amt] of Object.entries(bal)){
      const t = (state.accounts[acc]?.type && state.accounts[acc].type !== "other") ? state.accounts[acc].type : guessTypeFromAccountNo(acc);
      if (t === "asset") assets += amt;
      else if (t === "liability") eqLiab += amt;
      else if (t === "income") income += amt; // typically negative
      else if (t === "expense") expense += amt; // typically positive
      else {
        // if unknown, try by BAS class
        const gt = guessTypeFromAccountNo(acc);
        if (gt === "asset") assets += amt;
        else if (gt === "liability") eqLiab += amt;
        else if (gt === "income") income += amt;
        else if (gt === "expense") expense += amt;
      }
    }

    // result: income + expense (income negative) => negative profit; we present profit positive
    const resultSigned = income + expense;
    const profit = -resultSigned;

    return { assets, eqLiab, income, expense, profit };
  }


  // --- Reports (generator) ---
  function pad2(n){ return String(n).padStart(2,"0"); }

  function isoIsValid(d){
    return typeof d === "string" && /^\d{4}-\d{2}-\d{2}$/.test(d);
  }

  function fiscalYearStart(yearId){
    const fy = getYear(yearId);
    if (fy && isoIsValid(fy.start)) return fy.start;
    return yearId + "-01-01";
  }
  function fiscalYearEnd(yearId){
    const fy = getYear(yearId);
    if (fy && isoIsValid(fy.end)) return fy.end;
    return yearId + "-12-31";
  }

  function clampRangeToFY(yearId, from, to){
    const a = fiscalYearStart(yearId);
    const b = fiscalYearEnd(yearId);
    let f = isoIsValid(from) ? from : a;
    let t = isoIsValid(to) ? to : b;
    if (f < a) f = a;
    if (t > b) t = b;
    if (t < f) t = f;
    return { from:f, to:t };
  }

  function vouchersInRange(yearId, from, to){
    return (state.vouchers||[])
      .filter(v => v.yearId === yearId && !isVoidedVoucher(v) && (!from || v.date >= from) && (!to || v.date <= to))
      .slice()
      .sort((a,b)=> (a.date+a.series+a.no).localeCompare(b.date+b.series+b.no, "sv"));
  }

  function balancesForVouchers(vs){
    const bal = {};
    for (const v of vs){
      for (const l of (v.lines||[])){
        bal[l.account] = (bal[l.account] || 0) + (Number(l.amount)||0);
      }
    }
    for (const k of Object.keys(bal)) bal[k] = Math.round(bal[k]*100)/100;
    return bal;
  }

  function balancesInRange(yearId, from, to){
    return balancesForVouchers(vouchersInRange(yearId, from, to));
  }

  function balancesAsOf(yearId, to){
    const start = fiscalYearStart(yearId);
    return balancesInRange(yearId, start, to);
  }

  function openingBalances(yearId, from){
    const start = fiscalYearStart(yearId);
    if (!from || from <= start) return {};
    const prev = addDays(from, -1);
    return balancesInRange(yearId, start, prev);
  }

  function reportMetaHtml(title, yearId, from, to){
    const fy = getYear(yearId);
    const rangeLabel = (from && to) ? `${from} – ${to}` : (fy ? `${fy.start} – ${fy.end}` : yearId);
    const gen = new Date().toLocaleString("sv-SE", { hour12:false });
    return `
      <div style="display:flex; justify-content:space-between; gap:16px; flex-wrap:wrap; align-items:flex-end;">
        <div>
          <div style="font-size:18px; font-weight:900;">${escapeHtml(state.company.name || "FU-BOOKKEEPING")}</div>
          ${state.company.orgnr?`<div style="color:#555;">Org.nr: ${escapeHtml(state.company.orgnr)}</div>`:""}
        </div>
        <div style="text-align:right;">
          <div style="font-size:18px; font-weight:900;">${escapeHtml(title)}</div>
          <div style="color:#555;">Period: ${escapeHtml(rangeLabel)}</div>
          <div style="color:#555;">Genererad: ${escapeHtml(gen)}</div>
        </div>
      </div>
      <div style="height:1px; background:#ddd; margin:12px 0;"></div>
    `;
  }

  function buildTable(headers, rows){
    const th = headers.map(h=>`<th style="${h.style||""}">${escapeHtml(h.label||"")}</th>`).join("");
    const trs = rows.map(r=>{
      return "<tr>" + r.map((cell,i)=>{
        const style = headers[i]?.tdStyle || "";
        return `<td style="${style}">${cell}</td>`;
      }).join("") + "</tr>";
    }).join("");
    return `<table style="width:100%; border-collapse:collapse;">
      <thead><tr>${th}</tr></thead>
      <tbody>${trs}</tbody>
    </table>`;
  }

  function moneyCell(n){
    return `<span style="white-space:nowrap;">${fmtSEK(n)}</span>`;
  }

  function reportResultatrakning(yearId, from, to){
    const bal = balancesInRange(yearId, from, to);
    const rows = [];
    const rawRows = [];
    let rev = 0, cost = 0;

    const keys = Object.keys(bal).sort((a,b)=>a.localeCompare(b,"sv"));
    for (const acc of keys){
      const amt = bal[acc] || 0;
      const t = (state.accounts[acc]?.type && state.accounts[acc].type !== "other") ? state.accounts[acc].type : guessTypeFromAccountNo(acc);
      if (t !== "income" && t !== "expense") continue;

      // Display as positive for income (credit) and as positive for expense (debit)
      const shown = (t === "income") ? -amt : amt;
      if (t === "income") rev += shown; else cost += shown;

      rows.push([
        escapeHtml(acc),
        escapeHtml(state.accounts[acc]?.name || ""),
        escapeHtml(t === "income" ? "Intäkt" : "Kostnad"),
        `<div style="text-align:right;">${moneyCell(shown)}</div>`
      ]);
    }

    rev = Math.round(rev*100)/100;
    cost = Math.round(cost*100)/100;
    const profit = Math.round((rev - cost)*100)/100;

    const html = `
      ${reportMetaHtml("Resultaträkning", yearId, from, to)}
      <div style="display:flex; justify-content:flex-end; gap:24px; flex-wrap:wrap;">
        <div><div style="color:#555; font-size:12px;">Intäkter</div><div style="font-weight:900; font-size:18px; text-align:right;">${fmtSEK(rev)}</div></div>
        <div><div style="color:#555; font-size:12px;">Kostnader</div><div style="font-weight:900; font-size:18px; text-align:right;">${fmtSEK(cost)}</div></div>
        <div><div style="color:#555; font-size:12px;">Resultat</div><div style="font-weight:900; font-size:18px; text-align:right;">${fmtSEK(profit)}</div></div>
      </div>
      <div style="margin-top:12px;"></div>
      ${buildTable(
        [
          {label:"Konto", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:90px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Namn", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Typ", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:90px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Belopp", style:"text-align:right; border-bottom:1px solid #ddd; padding:8px 6px; width:140px;", tdStyle:"border-bottom:1px solid #eee; padding:6px; text-align:right;"}
        ],
        rows.length?rows:[[`<span style="color:#666;">–</span>`, "", "", `<div style="text-align:right;">${moneyCell(0)}</div>`]]
      )}
      <div style="margin-top:10px; color:#555; font-size:12px;">Not: Belopp visar periodens summering. Intäkter visas som positiva tal.</div>
    `;
    return { title:"Resultaträkning", html, columns:["Konto","Namn","Typ","Belopp"], rows: rawRows };
  }

  function reportBalansrakning(yearId, to){
    const bal = balancesAsOf(yearId, to);
    const assets = [];
    const liab = [];
    const rawRows = [];
    let sumA = 0, sumL = 0;

    const keys = Object.keys(bal).sort((a,b)=>a.localeCompare(b,"sv"));
    for (const acc of keys){
      const amt = bal[acc] || 0;
      const t = (state.accounts[acc]?.type && state.accounts[acc].type !== "other") ? state.accounts[acc].type : guessTypeFromAccountNo(acc);
      if (t !== "asset" && t !== "liability") continue;

      if (t === "asset"){
        sumA += amt;
        assets.push([escapeHtml(acc), escapeHtml(state.accounts[acc]?.name||""), `<div style="text-align:right;">${moneyCell(amt)}</div>`]);
      } else {
        // liabilities/equity are typically negative in this app (credits). Show positive.
        const shown = -amt;
        sumL += shown;
        liab.push([escapeHtml(acc), escapeHtml(state.accounts[acc]?.name||""), `<div style="text-align:right;">${moneyCell(shown)}</div>`]);
      }
    }

    sumA = Math.round(sumA*100)/100;
    sumL = Math.round(sumL*100)/100;

    const html = `
      ${reportMetaHtml("Balansräkning", yearId, fiscalYearStart(yearId), to)}
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:18px;">
        <div>
          <div style="font-weight:900; margin-bottom:6px;">Tillgångar</div>
          ${buildTable(
            [
              {label:"Konto", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:90px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
              {label:"Namn", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
              {label:"Belopp", style:"text-align:right; border-bottom:1px solid #ddd; padding:8px 6px; width:140px;", tdStyle:"border-bottom:1px solid #eee; padding:6px; text-align:right;"}
            ],
            assets.length?assets:[[`<span style="color:#666;">–</span>`, "", `<div style="text-align:right;">${moneyCell(0)}</div>`]]
          )}
          <div style="display:flex; justify-content:space-between; margin-top:10px; font-weight:900;">
            <div>Summa tillgångar</div><div>${fmtSEK(sumA)}</div>
          </div>
        </div>
        <div>
          <div style="font-weight:900; margin-bottom:6px;">Eget kapital & skulder</div>
          ${buildTable(
            [
              {label:"Konto", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:90px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
              {label:"Namn", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
              {label:"Belopp", style:"text-align:right; border-bottom:1px solid #ddd; padding:8px 6px; width:140px;", tdStyle:"border-bottom:1px solid #eee; padding:6px; text-align:right;"}
            ],
            liab.length?liab:[[`<span style="color:#666;">–</span>`, "", `<div style="text-align:right;">${moneyCell(0)}</div>`]]
          )}
          <div style="display:flex; justify-content:space-between; margin-top:10px; font-weight:900;">
            <div>Summa EK/skulder</div><div>${fmtSEK(sumL)}</div>
          </div>
        </div>
      </div>
      <div style="margin-top:10px; color:#555; font-size:12px;">Not: EK/skulder visas som positiva tal (kredit-saldo).</div>
    `;
    return { title:"Balansräkning", html, columns:["Sektion","Konto","Namn","Belopp"], rows: rawRows };
  }

  function reportBalansrapport(yearId, from, to){
  // Balansrapport = Ingående saldo (per dagen före från) + Förändring (från..till) + Utgående saldo (till)
  const fy = getYear(yearId);
  const start = fiscalYearStart(yearId);
  const end = fiscalYearEnd(yearId);

  // Clamp is already done in generateReport, but be defensive
  const range = clampRangeToFY(yearId, from, to);
  from = range.from; to = range.to;

  const opening = openingBalances(yearId, from);            // saldo före perioden
  const change = balancesInRange(yearId, from, to);         // periodens förändring
  const closing = balancesAsOf(yearId, to);                 // saldo t.o.m. till

  const keys = new Set([
    ...Object.keys(opening||{}),
    ...Object.keys(change||{}),
    ...Object.keys(closing||{})
  ]);

  function accType(acc){
    // For reports, don’t let a stored "other" override BAS inference (1=asset, 2=liability, 3=income, 4–8=expense).
    const inferred = guessTypeFromAccountNo(acc);
    const stored = state.accounts[acc]?.type;
    if (inferred === "asset" || inferred === "liability") return inferred; // always trust BAS for balance sheet classes
    return stored || inferred;
  }

  // Helpers: grouping by BAS-ish ranges
  function accNo(acc){ return String(acc||"").replace(/\D/g,""); }
  function first2(acc){ const n=accNo(acc); return n.length>=2 ? Number(n.slice(0,2)) : NaN; }
  function first1(acc){ const n=accNo(acc); return n.length>=1 ? Number(n.slice(0,1)) : NaN; }

  const assetsAcc = [];
  const eqLiabAcc = [];
  for (const acc of Array.from(keys).sort((a,b)=>a.localeCompare(b,"sv"))){
    const t = accType(acc);
    if (t !== "asset" && t !== "liability") continue;
    const o = opening[acc]||0, c = change[acc]||0, cl = closing[acc]||0;
    // keep accounts that have any activity / saldo
    if (Math.abs(o) < 0.005 && Math.abs(c) < 0.005 && Math.abs(cl) < 0.005) continue;
    if (t === "asset") assetsAcc.push(acc);
    else eqLiabAcc.push(acc);
  }

  // Group definitions (good-enough BAS headings)
  const ASSET_GROUPS = [
    { key:"10-13", title:"Anläggningstillgångar", sub:null, ranges:[[10,13]] },
    { key:"14", title:"Omsättningstillgångar", sub:[
        { key:"14", title:"Varulager m. m.", ranges:[[14,14]] },
        { key:"15-18", title:"Fordringar m. m.", ranges:[[15,18]] },
        { key:"19", title:"Kassa och bank", ranges:[[19,19]] },
      ], ranges:[[14,19]] }
  ];

  const EQLIAB_GROUPS = [
    { key:"20", title:"Eget kapital", ranges:[[20,20]] },
    { key:"21", title:"Obeskattade reserver", ranges:[[21,21]] },
    { key:"22", title:"Avsättningar", ranges:[[22,22]] },
    { key:"23", title:"Långfristiga skulder", ranges:[[23,23]] },
    { key:"24-29", title:"Kortfristiga skulder", ranges:[[24,29]] }
  ];

  function inRanges(acc, ranges){
    const x = first2(acc);
    if (Number.isNaN(x)) return false;
    return ranges.some(([a,b])=> x>=a && x<=b);
  }

  function sumAcc(accList){
    let so=0, sc=0, scl=0;
    for (const acc of accList){
      so += (opening[acc]||0);
      sc += (change[acc]||0);
      scl += (closing[acc]||0);
    }
    return {
      o: Math.round(so*100)/100,
      c: Math.round(sc*100)/100,
      cl: Math.round(scl*100)/100
    };
  }

  // Build HTML rows
  const rows = [];
  function addRow(kind, label, o, c, cl, acc=null){
    rows.push({ kind, label, o, c, cl, acc });
  }

  // ASSETS section
  addRow("h1", "TILLGÅNGAR", null,null,null);
  let sumAssets = {o:0,c:0,cl:0};

  // Include accounts not covered by groups in a fallback bucket
  const usedAssets = new Set();
  for (const g of ASSET_GROUPS){
    const gAcc = assetsAcc.filter(a=>inRanges(a, g.ranges));
    if (!gAcc.length) continue;
    // group title line (if has sub) else just section header
    if (g.sub) addRow("h2", g.title, null,null,null);
    // subgroups or direct accounts
    if (g.sub){
      for (const sg of g.sub){
        const sgAcc = gAcc.filter(a=>inRanges(a, sg.ranges));
        if (!sgAcc.length) continue;
        addRow("h3", sg.title, null,null,null);
        for (const acc of sgAcc){
          usedAssets.add(acc);
          addRow("acc", `${acc} ${state.accounts[acc]?.name||""}`.trim(), opening[acc]||0, change[acc]||0, closing[acc]||0, acc);
        }
        const s = sumAcc(sgAcc);
        addRow("sum", `Summa ${sg.title.toLowerCase()}`, s.o, s.c, s.cl);
      }
      const sG = sumAcc(gAcc);
      addRow("sum", `Summa ${g.title.toLowerCase()}`, sG.o, sG.c, sG.cl);
    } else {
      addRow("h2", g.title, null,null,null);
      for (const acc of gAcc){
        usedAssets.add(acc);
        addRow("acc", `${acc} ${state.accounts[acc]?.name||""}`.trim(), opening[acc]||0, change[acc]||0, closing[acc]||0, acc);
      }
      const sG = sumAcc(gAcc);
      addRow("sum", `Summa ${g.title.toLowerCase()}`, sG.o, sG.c, sG.cl);
    }
  }

  const leftoverAssets = assetsAcc.filter(a=>!usedAssets.has(a));
  if (leftoverAssets.length){
    addRow("h2", "Övriga tillgångar", null,null,null);
    for (const acc of leftoverAssets){
      addRow("acc", `${acc} ${state.accounts[acc]?.name||""}`.trim(), opening[acc]||0, change[acc]||0, closing[acc]||0, acc);
    }
    const s = sumAcc(leftoverAssets);
    addRow("sum", "Summa övriga tillgångar", s.o, s.c, s.cl);
  }

  sumAssets = sumAcc(assetsAcc);
  addRow("sumStrong", "SUMMA TILLGÅNGAR", sumAssets.o, sumAssets.c, sumAssets.cl);

  // EQUITY + LIAB
  addRow("spacer","",null,null,null);
  addRow("h1", "EGET KAPITAL OCH SKULDER", null,null,null);

  let sumEqLiab = {o:0,c:0,cl:0};
  const usedEL = new Set();
  for (const g of EQLIAB_GROUPS){
    const gAcc = eqLiabAcc.filter(a=>inRanges(a, g.ranges));
    if (!gAcc.length) continue;
    addRow("h2", g.title, null,null,null);
    for (const acc of gAcc){
      usedEL.add(acc);
      addRow("acc", `${acc} ${state.accounts[acc]?.name||""}`.trim(), opening[acc]||0, change[acc]||0, closing[acc]||0, acc);
    }
    const sG = sumAcc(gAcc);
    addRow("sum", `Summa ${g.title.toLowerCase()}`, sG.o, sG.c, sG.cl);
  }
  const leftoverEL = eqLiabAcc.filter(a=>!usedEL.has(a));
  if (leftoverEL.length){
    addRow("h2", "Övriga skulder", null,null,null);
    for (const acc of leftoverEL){
      addRow("acc", `${acc} ${state.accounts[acc]?.name||""}`.trim(), opening[acc]||0, change[acc]||0, closing[acc]||0, acc);
    }
    const s = sumAcc(leftoverEL);
    addRow("sum", "Summa övriga skulder", s.o, s.c, s.cl);
  }

  sumEqLiab = sumAcc(eqLiabAcc);
  addRow("sumStrong", "SUMMA EGET KAPITAL OCH SKULDER", sumEqLiab.o, sumEqLiab.c, sumEqLiab.cl);

  // Render HTML table
  const head = reportMetaHtml("Balansrapport", yearId, from, to);
  const colFrom = escapeHtml(from);
  const colTo = escapeHtml(to);

  const tableRows = rows.map(r=>{
    if (r.kind==="spacer") return `<tr><td colspan="4" style="height:14px;border:0;"></td></tr>`;
    if (r.kind==="h1") return `<tr><td colspan="4" style="padding-top:12px; font-weight:900; font-size:15px; border:0;">${escapeHtml(r.label)}</td></tr>`;
    if (r.kind==="h2") return `<tr><td colspan="4" style="padding-top:8px; font-weight:800; border:0;">${escapeHtml(r.label)}</td></tr>`;
    if (r.kind==="h3") return `<tr><td colspan="4" style="padding-top:4px; font-weight:700; color:#222; border:0;">${escapeHtml(r.label)}</td></tr>`;

    const cls = (r.kind==="sumStrong") ? "font-weight:900; text-transform:uppercase;" :
                (r.kind==="sum") ? "font-weight:800;" : "";
    const labelPad = (r.kind==="acc") ? "padding-left:14px;" : "";
    const o = (r.o==null)?"":fmtSEK(r.o);
    const c = (r.c==null)?"":fmtSEK(r.c);
    const cl = (r.cl==null)?"":fmtSEK(r.cl);

    return `<tr>
      <td style="${labelPad}${cls}">${escapeHtml(r.label)}</td>
      <td class="right" style="${cls}">${o}</td>
      <td class="right" style="${cls}">${c}</td>
      <td class="right" style="${cls}">${cl}</td>
    </tr>`;
  }).join("");

  const htmlOut = `
    ${head}
    <table>
      <thead>
        <tr>
          <th style="text-align:left; width:55%;">Balansrapport</th>
          <th style="text-align:right; width:15%;">${colFrom}</th>
          <th style="text-align:right; width:15%;">Förändring</th>
          <th style="text-align:right; width:15%;">${colTo}</th>
        </tr>
      </thead>
      <tbody>
        ${tableRows}
      </tbody>
    </table>
    <div class="muted small" style="margin-top:10px;">
      Not: Ingående kolumn visar saldo per dagen före <b>${colFrom}</b>. Förändring är perioden <b>${colFrom}–${colTo}</b>. Utgående visar saldo per <b>${colTo}</b>.
    </div>
  `;

  // Exportable flat rows (account-level only + totals)
  const exportRows = rows
    .filter(r=>["acc","sum","sumStrong"].includes(r.kind))
    .map(r=>({
      label: r.label,
      opening: (r.o==null?0:r.o),
      change: (r.c==null?0:r.c),
      closing: (r.cl==null?0:r.cl)
    }));

  return { title:`Balansrapport ${yearId}`, html: htmlOut, rows: exportRows };
}

function reportSaldolista(yearId, from, to){
    const period = balancesInRange(yearId, from, to);
    const asof = balancesAsOf(yearId, to);
    const keys = Array.from(new Set([...Object.keys(period), ...Object.keys(asof), ...Object.keys(state.accounts||{})]))
      .sort((a,b)=>a.localeCompare(b,"sv"));

    const rows = [];
    const rawRows = [];
    keys.forEach(acc=>{
      const p = Math.round((period[acc]||0)*100)/100;
      const a = Math.round((asof[acc]||0)*100)/100;
      if (Math.abs(p) < 0.00001 && Math.abs(a) < 0.00001) return;
      rows.push([
        escapeHtml(acc),
        escapeHtml(state.accounts[acc]?.name || ""),
        `<div style="text-align:right;">${moneyCell(p)}</div>`,
        `<div style="text-align:right;">${moneyCell(a)}</div>`
      ]);
    });

    const html = `
      ${reportMetaHtml("Saldolista", yearId, from, to)}
      ${buildTable(
        [
          {label:"Konto", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:90px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Namn", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Period", style:"text-align:right; border-bottom:1px solid #ddd; padding:8px 6px; width:140px;", tdStyle:"border-bottom:1px solid #eee; padding:6px; text-align:right;"},
          {label:"Saldo per datum", style:"text-align:right; border-bottom:1px solid #ddd; padding:8px 6px; width:160px;", tdStyle:"border-bottom:1px solid #eee; padding:6px; text-align:right;"}
        ],
        rows.length?rows:[[`<span style="color:#666;">–</span>`, "", `<div style="text-align:right;">${moneyCell(0)}</div>`, `<div style="text-align:right;">${moneyCell(0)}</div>`]]
      )}
      <div style="margin-top:10px; color:#555; font-size:12px;">Belopp i appen visas med debet som + och kredit som −.</div>
    `;
    return { title:"Saldolista", html, columns:["Konto","Namn","Saldo"], rows: rawRows };
  }

  function reportVerJournal(yearId, from, to){
    const vs = vouchersInRange(yearId, from, to);
    const rows = [];
    const rawRows = [];
    vs.forEach(v=>{
      const deb = (v.lines||[]).reduce((s,l)=> s + (l.amount>0?l.amount:0), 0);
      const cre = (v.lines||[]).reduce((s,l)=> s + (l.amount<0?-l.amount:0), 0);
      rawRows.push([
        v.date,
        (v.series || "") + String(v.no || ""),
        v.text||"",
        v.sign||"",
        Math.round(deb*100)/100,
        Math.round(cre*100)/100
      ]);
      rows.push([
        escapeHtml(v.date),
        escapeHtml(v.series + v.no),
        escapeHtml(v.text||""),
        escapeHtml(v.sign||""),
        `<div style="text-align:right;">${moneyCell(deb)}</div>`,
        `<div style="text-align:right;">${moneyCell(cre)}</div>`
      ]);
    });

    const html = `
      ${reportMetaHtml("Verifikationsjournal", yearId, from, to)}
      ${buildTable(
        [
          {label:"Datum", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:110px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Vernr", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:90px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Text", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Sign", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:70px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Debet", style:"text-align:right; border-bottom:1px solid #ddd; padding:8px 6px; width:140px;", tdStyle:"border-bottom:1px solid #eee; padding:6px; text-align:right;"},
          {label:"Kredit", style:"text-align:right; border-bottom:1px solid #ddd; padding:8px 6px; width:140px;", tdStyle:"border-bottom:1px solid #eee; padding:6px; text-align:right;"}
        ],
        rows.length?rows:[[`<span style="color:#666;">–</span>`, "", "", "", `<div style="text-align:right;">${moneyCell(0)}</div>`, `<div style="text-align:right;">${moneyCell(0)}</div>`]]
      )}
    `;
    return { title:"Verifikationsjournal", html, columns:["Datum","Vernr","Text","Sign","Debet","Kredit"], rows: rawRows };
  }

  function reportHuvudbok(yearId, from, to){
    const vs = vouchersInRange(yearId, from, to);
    const ob = openingBalances(yearId, from);
    const txByAcc = {};

    vs.forEach(v=>{
      (v.lines||[]).forEach(l=>{
        const acc = String(l.account||"");
        if (!txByAcc[acc]) txByAcc[acc] = [];
        txByAcc[acc].push({
          date: v.date, ver: (v.series||"")+String(v.no||""), text: l.text||v.text||"", amount: Number(l.amount)||0
        });
      });
    });

    const accs = Object.keys(txByAcc).sort((a,b)=>a.localeCompare(b,"sv"));

    let out = reportMetaHtml("Huvudbok", yearId, from, to);
    const rawRows = [];

    if (!accs.length){
      out += `<div style="color:#555;">Inga transaktioner i perioden.</div>`;
      return { title:"Huvudbok", html: out, columns:["Konto","Namn","Datum","Ver","Text","Belopp","Saldo"], rows: rawRows };
    }

    for (const acc of accs){
      const list = txByAcc[acc].slice().sort((a,b)=> (a.date+a.ver).localeCompare(b.date+b.ver,"sv"));
      let run = Math.round((ob[acc]||0)*100)/100;

      out += `<div style="margin-top:16px; font-weight:900;">${escapeHtml(acc)} – ${escapeHtml(state.accounts[acc]?.name||"")}</div>`;
      out += `<div style="color:#555; font-size:12px; margin-bottom:6px;">Ingående saldo (före ${escapeHtml(from)}): ${fmtSEK(run)}</div>`;

      const rows = [];
      list.forEach(t=>{
        run = Math.round((run + t.amount)*100)/100;
        rawRows.push([
          acc,
          (state.accounts[acc]?.name||""),
          t.date,
          t.ver,
          t.text,
          Math.round((t.amount||0)*100)/100,
          Math.round(run*100)/100
        ]);
        rows.push([
          escapeHtml(t.date),
          escapeHtml(t.ver),
          escapeHtml(t.text),
          `<div style="text-align:right;">${moneyCell(t.amount)}</div>`,
          `<div style="text-align:right;">${moneyCell(run)}</div>`
        ]);
      });

      out += buildTable(
        [
          {label:"Datum", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:110px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Vernr", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:90px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Text", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
          {label:"Belopp", style:"text-align:right; border-bottom:1px solid #ddd; padding:8px 6px; width:140px;", tdStyle:"border-bottom:1px solid #eee; padding:6px; text-align:right;"},
          {label:"Saldo", style:"text-align:right; border-bottom:1px solid #ddd; padding:8px 6px; width:140px;", tdStyle:"border-bottom:1px solid #eee; padding:6px; text-align:right;"}
        ],
        rows
      );
    }

    return { title:"Huvudbok", html: out };
  }



      // --- Lagerrapport + inventeringslista ---
      function getInventorySnapshots(){
        state.inventorySnapshots = state.inventorySnapshots || {};
        return state.inventorySnapshots;
      }
      function getInventorySnapshot(yearId, asOf){
        const snaps = getInventorySnapshots();
        snaps[yearId] = snaps[yearId] || {};
        if (!snaps[yearId][asOf]){
          snaps[yearId][asOf] = {
            items: [],
            adjustmentAccount: state.accounts["4990"] ? "4990" : (state.accounts["4010"] ? "4010" : (state.accounts["4990"] ? "4990" : "")),
            note: ""
          };
        }
        // ensure structure
        snaps[yearId][asOf].items = Array.isArray(snaps[yearId][asOf].items) ? snaps[yearId][asOf].items : [];
        return snaps[yearId][asOf];
      }

      function setInventorySnapshot(yearId, asOf, snap){
        const snaps = getInventorySnapshots();
        snaps[yearId] = snaps[yearId] || {};
        snaps[yearId][asOf] = snap;
      }

      function nextVoucherNo(yearId, series){
        const vs = (state.vouchers||[]).filter(v=>v.yearId===yearId && (v.series||"")===String(series||"A"));
        let mx = 0;
        for (const v of vs){
          const n = parseInt(String(v.no||"").replace(/\D/g,""), 10);
          if (Number.isFinite(n)) mx = Math.max(mx, n);
        }
        return String(mx + 1);
      }

      function reportLagerrapport(yearId, from, to){
        // Lager konto 1400 per valt datum + inventeringslista (steg 2)
        const balTo = balancesAsOf(yearId, to);
        const booked = Math.round((balTo["1400"]||0)*100)/100;

        // list verifications affecting 1400 in period (from..to)
        const vs = vouchersInRange(yearId, from, to);
        const affects = [];
        for (const v of vs){
          for (const l of (v.lines||[])){
            if (String(l.account) !== "1400") continue;
            affects.push([
              escapeHtml(v.date),
              escapeHtml((v.series||"") + (v.no||"")),
              escapeHtml(v.text || ""),
              escapeHtml(l.text || ""),
              `<div style="text-align:right;">${moneyCell(Number(l.amount)||0)}</div>`
            ]);
          }
        }

        const snap = getInventorySnapshot(yearId, to);
        const items = snap.items || [];
        const html = `
          ${reportMetaHtml("Lagerrapport & inventeringslista", yearId, from, to)}

          <div class="grid two" style="gap:14px;">
            <div class="card" style="padding:12px;">
              <div style="font-weight:900; margin-bottom:6px;">Bokfört lager (konto 1400) per ${escapeHtml(to)}</div>
              <div style="display:flex; justify-content:space-between; align-items:flex-end; gap:12px; flex-wrap:wrap;">
                <div class="muted small">Saldo beräknat från verifikationer t.o.m. datumet.</div>
                <div style="font-size:22px; font-weight:900;">${fmtSEK(booked)}</div>
              </div>

              <div style="height:10px;"></div>
              <div style="font-weight:900; margin-bottom:6px;">Verifikationer som påverkar 1400 i perioden</div>
              ${buildTable(
                [
                  {label:"Datum", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:110px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
                  {label:"Ver", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px; width:90px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
                  {label:"Text", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
                  {label:"Radtext", style:"text-align:left; border-bottom:1px solid #ddd; padding:8px 6px;", tdStyle:"border-bottom:1px solid #eee; padding:6px;"},
                  {label:"Belopp", style:"text-align:right; border-bottom:1px solid #ddd; padding:8px 6px; width:140px;", tdStyle:"border-bottom:1px solid #eee; padding:6px; text-align:right;"}
                ],
                affects.length ? affects : [[`<span class="muted small">–</span>`, "", "", "", `<div style="text-align:right;">${moneyCell(0)}</div>`]]
              )}
              <div class="muted small" style="margin-top:8px;">Tips: Om bokfört lager inte matchar inventerat lager kan du skapa en lagerjusteringsverifikation via inventeringslistan till höger.</div>
            </div>

            <div class="card" style="padding:12px;">
              <div style="font-weight:900; margin-bottom:6px;">Inventeringslista (steg 2)</div>
              <div class="muted small" style="margin-bottom:10px;">
                Lägg in artiklar/antal/á-pris. Appen räknar inventerat lagervärde och visar diff mot bokfört 1400.
              </div>

              <div class="row" style="gap:10px; align-items:flex-end; flex-wrap:wrap; margin-bottom:10px;">
                <div class="field" style="min-width:210px; flex:1;">
                  <label>Motkonto för lagerförändring</label>
                  <select id="invAdjAccount"></select>
                </div>
                <div class="field" style="min-width:220px; flex:1;">
                  <label>Notering (valfritt)</label>
                  <input id="invNote" placeholder="t.ex. inventering 2024-12-31" />
                </div>
                <button class="btn secondary" id="invAddRow" type="button">+ Rad</button>
                <button class="btn secondary" id="invClear" type="button">Rensa</button>
              </div>

              <div style="overflow:auto; border:1px solid rgba(255,255,255,.10); border-radius:12px;">
                <table style="width:100%; border-collapse:collapse;">
                  <thead>
                    <tr>
                      <th style="text-align:left; padding:8px 6px; border-bottom:1px solid rgba(255,255,255,.10);">Artikel</th>
                      <th style="text-align:right; padding:8px 6px; border-bottom:1px solid rgba(255,255,255,.10); width:110px;">Antal</th>
                      <th style="text-align:right; padding:8px 6px; border-bottom:1px solid rgba(255,255,255,.10); width:140px;">Á-pris</th>
                      <th style="text-align:right; padding:8px 6px; border-bottom:1px solid rgba(255,255,255,.10); width:160px;">Radbelopp</th>
                      <th style="padding:8px 6px; border-bottom:1px solid rgba(255,255,255,.10); width:40px;"></th>
                    </tr>
                  </thead>
                  <tbody id="invTbody"></tbody>
                </table>
              </div>

              <div class="row" style="justify-content:space-between; margin-top:10px; gap:10px; flex-wrap:wrap;">
                <div>
                  <div class="muted small">Inventerat lagervärde</div>
                  <div style="font-weight:900; font-size:18px;" id="invTotal">0,00</div>
                </div>
                <div>
                  <div class="muted small">Diff mot bokfört 1400</div>
                  <div style="font-weight:900; font-size:18px;" id="invDiff">0,00</div>
                </div>
                <div>
                  <div class="muted small">Förslag: lagerjustering</div>
                  <div class="muted small" id="invSuggestion">–</div>
                </div>
              </div>

              <div class="row" style="justify-content:flex-end; gap:10px; margin-top:10px; flex-wrap:wrap;">
                <button class="btn" id="invCreateVoucher" type="button">Skapa lagerjusteringsverifikation</button>
              </div>

              <div class="muted small" style="margin-top:8px;">
                Skapar en verifikation på datum <b>${escapeHtml(to)}</b> med rader:
                <b>1400 Lager</b> och valt motkonto (vanligt: 4990 Förändring av lager).
              </div>
            </div>
          </div>
        `;
        // Provide exportable rows as the inventory items (if any)
        const columns = ["Artikel","Antal","Á-pris","Belopp"];
        const rows = items.map(it => [String(it.name||""), Number(it.qty)||0, Number(it.unit)||0, Math.round((Number(it.qty)||0)*(Number(it.unit)||0)*100)/100]);
        return { title:"Lagerrapport & inventeringslista", html, columns, rows };
      }

      function initInventoryReportUI(yearId, from, to){
        // Called after report HTML has been inserted
        const balTo = balancesAsOf(yearId, to);
        const booked = Math.round((balTo["1400"]||0)*100)/100;

        const tbody = document.getElementById("invTbody");
        const elTotal = document.getElementById("invTotal");
        const elDiff = document.getElementById("invDiff");
        const elSug = document.getElementById("invSuggestion");
        const selAdj = document.getElementById("invAdjAccount");
        const inpNote = document.getElementById("invNote");
        const btnAdd = document.getElementById("invAddRow");
        const btnClear = document.getElementById("invClear");
        const btnCreate = document.getElementById("invCreateVoucher");
        if (!tbody || !elTotal || !elDiff || !elSug || !selAdj || !btnAdd || !btnClear || !btnCreate) return;

        const snap = getInventorySnapshot(yearId, to);
        const items = snap.items || [];

        // Fill accounts (prefer expense accounts around 49xx, but show all)
        const accs = Object.keys(state.accounts||{}).sort((a,b)=>a.localeCompare(b,"sv"));
        selAdj.innerHTML = "";
        accs.forEach(a=>{
          const opt = document.createElement("option");
          opt.value = a;
          opt.textContent = accountLabel(a);
          selAdj.appendChild(opt);
        });
        if (snap.adjustmentAccount && state.accounts[snap.adjustmentAccount]) selAdj.value = snap.adjustmentAccount;
        else if (state.accounts["4990"]) selAdj.value = "4990";
        else if (state.accounts["4010"]) selAdj.value = "4010";

        if (inpNote) inpNote.value = snap.note || "";

        let saveTimer = null;
        function scheduleSave(){
          if (saveTimer) clearTimeout(saveTimer);
          saveTimer = setTimeout(()=>{
            try{
              snap.adjustmentAccount = selAdj.value || "";
              snap.note = (inpNote?.value || "").trim();
              snap.items = items;
              setInventorySnapshot(yearId, to, snap);
              save();
            }catch(e){ console.error(e); }
          }, 250);
        }

        function fmtNum(n){
          const v = Number(n);
          if (!Number.isFinite(v)) return "";
          return String(v).replace(".", ",");
        }

        function parseNum(s){
          const t = String(s||"").trim().replace(/\s/g,"").replace(",", ".");
          const v = Number(t);
          return Number.isFinite(v) ? v : 0;
        }

        function calc(){
          let total = 0;
          for (const it of items){
            const qty = Number(it.qty)||0;
            const unit = Number(it.unit)||0;
            total += qty*unit;
          }
          total = Math.round(total*100)/100;
          const diff = Math.round((total - booked)*100)/100;

          elTotal.textContent = fmtSEK(total);
          elDiff.textContent = fmtSEK(diff);

          const adj = selAdj.value || "";
          if (!diff){
            elSug.textContent = "Ingen justering behövs.";
            btnCreate.disabled = true;
          } else {
            btnCreate.disabled = false;
            const d = diff;
            const line1400 = d; // positive => debit 1400; negative => credit 1400
            const lineAdj = -d;
            const dir = d>0 ? "Öka" : "Minska";
            elSug.textContent = `${dir} lager: 1400 ${fmtSEK(line1400)} / ${adj||"motkonto"} ${fmtSEK(lineAdj)}`;
          }
          return { total, diff };
        }

        function render(){
          tbody.innerHTML = "";
          items.forEach((it, idx)=>{
            const tr = document.createElement("tr");
            tr.innerHTML = `
              <td style="padding:6px; border-bottom:1px solid rgba(255,255,255,.08);">
                <input data-f="name" data-i="${idx}" value="${escapeAttr(it.name||"")}" placeholder="t.ex. Bågar modell X" style="width:100%;" />
              </td>
              <td style="padding:6px; border-bottom:1px solid rgba(255,255,255,.08); text-align:right;">
                <input data-f="qty" data-i="${idx}" value="${escapeAttr(it.qty==null?"":String(it.qty).replace(".",","))}" inputmode="decimal" style="width:100%; text-align:right;" />
              </td>
              <td style="padding:6px; border-bottom:1px solid rgba(255,255,255,.08); text-align:right;">
                <input data-f="unit" data-i="${idx}" value="${escapeAttr(it.unit==null?"":String(it.unit).replace(".",","))}" inputmode="decimal" style="width:100%; text-align:right;" />
              </td>
              <td style="padding:6px; border-bottom:1px solid rgba(255,255,255,.08); text-align:right;">
                <span>${fmtSEK(Math.round((Number(it.qty)||0)*(Number(it.unit)||0)*100)/100)}</span>
              </td>
              <td style="padding:6px; border-bottom:1px solid rgba(255,255,255,.08); text-align:center;">
                <button class="btn secondary" type="button" data-act="del" data-i="${idx}" style="padding:6px 10px;">×</button>
              </td>
            `;
            tbody.appendChild(tr);
          });
          if (!items.length){
            const tr = document.createElement("tr");
            tr.innerHTML = `<td colspan="5" class="muted small" style="padding:10px;">Inga inventeringsrader ännu. Klicka <b>+ Rad</b> för att lägga till.</td>`;
            tbody.appendChild(tr);
          }
          calc();
        }

        function addRow(){
          items.push({ name:"", qty:"", unit:"" });
          render();
          scheduleSave();
        }

        btnAdd.addEventListener("click", (e)=>{ e.preventDefault(); addRow(); });
        btnClear.addEventListener("click", async (e)=>{
          e.preventDefault();
          if (!(await confirmAsync("Rensa hela inventeringslistan för detta datum?"))) return;
          items.splice(0, items.length);
          render();
          scheduleSave();
        });

        selAdj.addEventListener("change", ()=>{ calc(); scheduleSave(); });
        if (inpNote) inpNote.addEventListener("input", ()=>{ scheduleSave(); });

        tbody.addEventListener("input", (e)=>{
          const t = e.target;
          if (!t || !t.dataset) return;
          const i = parseInt(t.dataset.i||"-1", 10);
          const f = t.dataset.f;
          if (!(i>=0 && i<items.length)) return;
          if (f === "name") items[i].name = t.value;
          if (f === "qty") items[i].qty = t.value;
          if (f === "unit") items[i].unit = t.value;
          // update numeric render quickly
          render();
          scheduleSave();
        });

        tbody.addEventListener("click", (e)=>{
          const b = e.target && e.target.closest ? e.target.closest("button[data-act='del']") : null;
          if (!b) return;
          const i = parseInt(b.dataset.i||"-1", 10);
          if (!(i>=0 && i<items.length)) return;
          items.splice(i,1);
          render();
          scheduleSave();
        });

        btnCreate.addEventListener("click", async (e)=>{
          e.preventDefault();
          const { total, diff } = calc();
          if (!diff) return showToast("Ingen diff att bokföra.", 3500);
          const adjAcc = selAdj.value || "";
          if (!adjAcc) return showToast("Välj motkonto för lagerförändring först.", 4500);

          const note = (inpNote?.value || "").trim();
          const text = note ? `Lagerjustering (${note})` : "Lagerjustering (inventering)";

          const vv = {
            id: crypto.randomUUID(),
            yearId,
            series: "A",
            no: nextVoucherNo(yearId, "A"),
            date: to,
            text,
            regDate: todayISO(),
            sign: state.company.defaultSign || "",
            lines: [
              { account: "1400", text, amount: Math.round(diff*100)/100 },
              { account: adjAcc, text, amount: Math.round((-diff)*100)/100 },
            ],
            correctionOf: null,
            status: "active"
          };

          if (!(await confirmAsync(`Skapa verifikation A${vv.no} på ${to}?

1400: ${fmtSEK(vv.lines[0].amount)}
${adjAcc}: ${fmtSEK(vv.lines[1].amount)}`))) return;

          state.vouchers = state.vouchers || [];
          state.vouchers.push(vv);
          appendAudit({ action:"voucher.create", actor: vv.sign || undefined, entityType:"voucher", entityId: vv.id, yearId, details:{ after: summarizeVoucher(vv), source:"inventory" } });
          save();
          try { renderVouchers(); } catch {}
          showToast("Lagerjusteringsverifikation skapad.", 4500);

          // Refresh report numbers (booked changes if within same year/to)
          try { generateReport(); } catch {}
        });

        // Ensure at least 1 row is visible if previously saved but empty
        render();
      }

  function generateReport(){
    if (!reportOutput) return;
    const yearId = (rptYearSelect && rptYearSelect.value) ? rptYearSelect.value : state.activeYearId;
    const rawFrom = rptFrom ? rptFrom.value : "";
    const rawTo = rptTo ? rptTo.value : "";

    const { from, to } = clampRangeToFY(yearId, rawFrom, rawTo);
    if (rptFrom) rptFrom.value = from;
    if (rptTo) rptTo.value = to;

    const type = (rptType && rptType.value) ? rptType.value : "is";

    let rep;
    if (type === "is") rep = reportResultatrakning(yearId, from, to);
    else if (type === "bs") rep = reportBalansrakning(yearId, to);
    else if (type === "br") rep = reportBalansrapport(yearId, from, to);
    else if (type === "trial") rep = reportSaldolista(yearId, from, to);
    else if (type === "gl") rep = reportHuvudbok(yearId, from, to);
    else if (type === "vj") rep = reportVerJournal(yearId, from, to);
    else if (type === "inventory") rep = reportLagerrapport(yearId, from, to);
    else rep = reportResultatrakning(yearId, from, to);

    lastReportHtml = rep.html;
    lastReportTitle = rep.title;
    lastReportData = rep;

    reportOutput.innerHTML = rep.html;
    try { if (type === "inventory") initInventoryReportUI(yearId, from, to); } catch (e){ console.error(e); }
    if (btnRptPrint) btnRptPrint.disabled = !rep.html;
    if (btnRptCsv) btnRptCsv.disabled = !(rep && Array.isArray(rep.rows) && rep.rows.length);
    if (btnRptXls) btnRptXls.disabled = !(rep && Array.isArray(rep.rows) && rep.rows.length);
  }

  function printLastReport(){
    if (!lastReportHtml) return;
    const title = lastReportTitle || "Rapport";
    const html = `<!doctype html><html><head><meta charset="utf-8">
      <title>${escapeHtml(title)}</title>
      <style>
        body{ font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; padding:24px; color:#111; }
        table{ width:100%; border-collapse:collapse; }
        th,td{ border-bottom:1px solid #ddd; padding:8px 6px; vertical-align:top; }
        th{ background:#f7f7f7; }
        @media print{
          body{ padding:0; }
          th{ background:#f0f0f0 !important; -webkit-print-color-adjust:exact; print-color-adjust:exact; }
        }
      </style>
      </head><body>
      ${lastReportHtml}
      <script>window.onload=()=>window.print();<\/script>
      </body></html>`;
    const w = window.open("", "_blank");
    if (!w) return showToast("Popup blockerad. Tillåt popup för att skriva ut.", 6000);
    w.document.open();
    w.document.write(html);
    w.document.close();
  }


  // --- Export last generated report (CSV / Excel) ---
  function csvEscape(val){
    const s = (val == null) ? "" : String(val);
    // Quote if contains separator, quote or newline
    if (/[;"\n\r]/.test(s)) return '"' + s.replaceAll('"','""') + '"';
    return s;
  }

  function toCsvNumber(n){
    const v = Number(n);
    if (!Number.isFinite(v)) return "";
    // Swedish Excel often expects comma decimal with semicolon separator
    return v.toFixed(2).replace(".", ",");
  }

  function reportToCsv(columns, rows){
    const sep = ";";
    const out = [];
    out.push(columns.map(csvEscape).join(sep));
    for (const r of rows){
      const line = r.map(v => (typeof v === "number" ? toCsvNumber(v) : csvEscape(v))).join(sep);
      out.push(line);
    }
    return out.join("\n") + "\n";
  }

  function reportToXlsHtml(title, columns, rows){
    // Old-school HTML table served as .xls (works in Excel/LibreOffice)
    const th = columns.map(c => `<th>${escapeHtml(c)}</th>`).join("");
    const trs = rows.map(r => {
      const tds = r.map(v => {
        if (typeof v === "number") return `<td style="mso-number-format:'0.00'; text-align:right;">${escapeHtml(toCsvNumber(v).replace(",", "."))}</td>`;
        return `<td>${escapeHtml(v==null?"":String(v))}</td>`;
      }).join("");
      return `<tr>${tds}</tr>`;
    }).join("");
    return `<!doctype html><html><head><meta charset="utf-8">
      <title>${escapeHtml(title)}</title>
      <style>
        table{ border-collapse:collapse; }
        th,td{ border:1px solid #ccc; padding:6px 8px; vertical-align:top; }
        th{ background:#f7f7f7; font-weight:700; }
      </style>
      </head><body>
      <table>
        <thead><tr>${th}</tr></thead>
        <tbody>${trs}</tbody>
      </table>
      </body></html>`;
  }

  function safeFilename(s){
    return String(s||"rapport").replace(/[^a-z0-9\-_]+/gi,"_").replace(/_+/g,"_").replace(/^_+|_+$/g,"").slice(0,60) || "rapport";
  }

  function exportLastReport(kind){
    if (!lastReportData || !Array.isArray(lastReportData.columns) || !Array.isArray(lastReportData.rows)){
      return showToast("Ingen rapport att exportera ännu. Generera en rapport först.", 4500);
    }
    const title = lastReportData.title || lastReportTitle || "Rapport";
    const base = safeFilename(title);
    if (kind === "csv"){
      const csv = reportToCsv(lastReportData.columns, lastReportData.rows);
      downloadText(base + ".csv", csv, "text/csv");
      return;
    }
    if (kind === "xls"){
      const xls = reportToXlsHtml(title, lastReportData.columns, lastReportData.rows);
      downloadText(base + ".xls", xls, "application/vnd.ms-excel");
      return;
    }
  }

  function setRangeFullYear(){
    const yearId = (rptYearSelect && rptYearSelect.value) ? rptYearSelect.value : state.activeYearId;
    if (rptFrom) rptFrom.value = fiscalYearStart(yearId);
    if (rptTo) rptTo.value = fiscalYearEnd(yearId);
  }

  function setRangeThisMonth(){
    const yearId = (rptYearSelect && rptYearSelect.value) ? rptYearSelect.value : state.activeYearId;
    const today = todayISO();
    const y = Number(today.slice(0,4));
    const m = Number(today.slice(5,7));
    const first = y + "-" + pad2(m) + "-01";
    const { from, to } = clampRangeToFY(yearId, first, today);
    if (rptFrom) rptFrom.value = from;
    if (rptTo) rptTo.value = to;
  }

  function setRangeThisQuarter(){
    const yearId = (rptYearSelect && rptYearSelect.value) ? rptYearSelect.value : state.activeYearId;
    const today = todayISO();
    const y = Number(today.slice(0,4));
    const m = Number(today.slice(5,7));
    const q = Math.floor((m-1)/3) + 1;
    const qm = (q-1)*3 + 1;
    const first = y + "-" + pad2(qm) + "-01";
    const { from, to } = clampRangeToFY(yearId, first, today);
    if (rptFrom) rptFrom.value = from;
    if (rptTo) rptTo.value = to;
  }

  function renderReports(){
    // Fill year selector and set sensible defaults
    fillYearSelectors();

    if (rptYearSelect){
      // Build options (reuse fiscal years)
      const ys = state.fiscalYears.slice().sort((a,b)=>a.id.localeCompare(b.id,"sv"));
      const prev = rptYearSelect.value;
      rptYearSelect.innerHTML = "";
      ys.forEach(y=>{
        const opt = document.createElement("option");
        opt.value = y.id;
        opt.textContent = `${y.id} (${y.start} – ${y.end})`;
        rptYearSelect.appendChild(opt);
      });
      rptYearSelect.value = ys.find(y=>y.id===prev)?.id || state.activeYearId || ys[0]?.id || "";
    }

    // Default range: full FY
    if (rptFrom && rptTo){
      const yearId = (rptYearSelect && rptYearSelect.value) ? rptYearSelect.value : state.activeYearId;
      if (!rptFrom.value || !rptTo.value){
        rptFrom.value = fiscalYearStart(yearId);
        rptTo.value = fiscalYearEnd(yearId);
      }
    }

    // Keep print button in sync
    if (btnRptPrint) btnRptPrint.disabled = !lastReportHtml;
  }


  function renderLedger(yearId){
    if (!ledgerTbody || !ledgerAccount) return;
    const acc = ledgerAccount.value;
    if (!acc){ ledgerTbody.innerHTML = ""; return; }

    const vs = yearVouchers(yearId)
      .slice()
      .sort((a,b)=> (a.date+a.series+a.no).localeCompare(b.date+b.series+b.no, "sv"));

    const rows = [];
    vs.forEach(v=>{
      v.lines.forEach(l=>{
        if (String(l.account) !== String(acc)) return;
        rows.push({
          date: v.date,
          ver: (v.series||"") + (v.no||""),
          text: l.text || v.text || "",
          amt: Number(l.amount)||0
        });
      });
    });

    let run = 0;
    ledgerTbody.innerHTML = "";
    rows.forEach(r=>{
      run = Math.round((run + r.amt)*100)/100;
      const tr=document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(r.date)}</td>
        <td>${escapeHtml(r.ver)}</td>
        <td>${escapeHtml(r.text)}</td>
        <td class="right">${fmtSEK(r.amt)}</td>
        <td class="right">${fmtSEK(run)}</td>
      `;
      ledgerTbody.appendChild(tr);
    });

    if (rows.length===0){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td colspan="5" class="muted small">Inga transaktioner för valt konto i detta år.</td>`;
      ledgerTbody.appendChild(tr);
    }
  }


// --- Report generator wiring ---
let reportAutoTimer = null;
function scheduleReportAutoGenerate(){
  if (!reportOutput) return;
  if (reportAutoTimer) clearTimeout(reportAutoTimer);
  reportAutoTimer = setTimeout(()=>{
    reportAutoTimer = null;
    try { generateReport(); } catch (e){ console.error(e); }
  }, 150);
}

if (btnRptGenerate) btnRptGenerate.addEventListener("click", generateReport);
if (btnRptPrint) btnRptPrint.addEventListener("click", printLastReport);
if (btnRptCsv) btnRptCsv.addEventListener("click", ()=> exportLastReport("csv"));
if (btnRptXls) btnRptXls.addEventListener("click", ()=> exportLastReport("xls"));
if (btnRptFullYear) btnRptFullYear.addEventListener("click", () => { setRangeFullYear(); scheduleReportAutoGenerate(); });
if (btnRptThisMonth) btnRptThisMonth.addEventListener("click", () => { setRangeThisMonth(); scheduleReportAutoGenerate(); });
if (btnRptThisQuarter) btnRptThisQuarter.addEventListener("click", () => { setRangeThisQuarter(); scheduleReportAutoGenerate(); });

if (rptType) rptType.addEventListener("change", ()=> scheduleReportAutoGenerate());

[rptFrom, rptTo].filter(Boolean).forEach(el=>{
  el.addEventListener("change", ()=> scheduleReportAutoGenerate());
  el.addEventListener("blur", ()=> scheduleReportAutoGenerate(), true);
  el.addEventListener("keydown", (e)=>{
    if (e.key === "Enter"){
      e.preventDefault();
      scheduleReportAutoGenerate();
    }
  });
});

if (rptYearSelect){
  rptYearSelect.addEventListener("change", () => {
    setRangeFullYear();
    lastReportHtml = "";
    lastReportTitle = "";
    if (reportOutput) reportOutput.innerHTML = '<div class="muted small">Välj rapport + datumintervall och klicka <b>Generera</b>.</div>';
    if (btnRptPrint) btnRptPrint.disabled = true;
    if (btnRptCsv) btnRptCsv.disabled = true;
    if (btnRptXls) btnRptXls.disabled = true;
    scheduleReportAutoGenerate();
  });
}



  // --- Period lock wiring ---
  if (lockYear && lockUntil){
    lockYear.addEventListener("change", ()=>{ lockUntil.value = lockUntilForYear(lockYear.value); });
  }

  // --- Settings wiring ---
  if (btnSaveSettings){
    btnSaveSettings.addEventListener("click", (e)=>{
      e.preventDefault();
      try { saveSettings(); }
      catch(err){
        console.error(err);
        const msg = (err && (err.message || err.name)) ? String(err.message || err.name) : "(okänt fel)";
        showToast(`Kunde inte spara inställningar: ${msg}. Se konsolen.`, 8000);
      }
    });
  }

  if (btnRemoveLogo){
    btnRemoveLogo.addEventListener("click", (e)=>{
      e.preventDefault();
      state.company = state.company || defaultData().company;
      state.company.logoDataUrl = "";
      if (sLogo) sLogo.value = "";
      save();
      renderLogoPreview();
    });
  }

  if (sLogo){
    sLogo.addEventListener("change", ()=>{
      const f = sLogo.files && sLogo.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        state.company = state.company || defaultData().company;
        state.company.logoDataUrl = String(reader.result || "");
        save();
        renderLogoPreview();
      };
      reader.onerror = (err) => {
        console.error(err);
        showToast("Kunde inte läsa logotypfilen.", 6500);
      };
      reader.readAsDataURL(f);
    });
  }
  if (btnSetLock){
    btnSetLock.addEventListener("click", (e)=>{
      e.preventDefault();
      const yid = lockYear ? lockYear.value : state.activeYearId;
      if (!yid) return showToast("Välj år.", 3500);
      const until = (lockUntil?.value || "").trim();
      if (!until) return showToast("Ange ett datum att låsa t.o.m.", 4500);
      state.locks = state.locks || {};
      state.locks[yid] = until;
      appendAudit({ action:"lock.set", entityType:"lock", entityId: yid, yearId: yid, details:{ until } });
      save();
      showToast(`Låst t.o.m ${until} för år ${yid}.`, 4500);
    });
  }
  if (btnClearLock){
    btnClearLock.addEventListener("click", (e)=>{
      e.preventDefault();
      const yid = lockYear ? lockYear.value : state.activeYearId;
      if (!yid) return;
      state.locks = state.locks || {};
      const prevUntil = state.locks[yid] || "";
      delete state.locks[yid];
      appendAudit({ action:"lock.clear", entityType:"lock", entityId: yid, yearId: yid, details:{ prevUntil } });
      save();
      if (lockUntil) lockUntil.value = "";
      showToast(`Tog bort lås för år ${yid}.`, 4500);
    });
  }

// --- Init ---
try { fillYearSelectors(); } catch (e){ console.error(e); }

try { if (yearSelect) yearSelect.value = state.activeYearId; } catch (e){ console.error(e); }
try { if (vDate) vDate.value = todayISO(); } catch (e){ console.error(e); }

try { if (typeof newVoucher === "function") newVoucher(); } catch (e){ console.error(e); }

// Voucher wiring
try { if (typeof wireVoucherEvents === "function") wireVoucherEvents(); } catch (e){ console.error(e); }
try { if (typeof wireYearCarryEvents === "function") wireYearCarryEvents(); } catch (e){ console.error(e); }
try { if (typeof renderVouchers === "function") renderVouchers(); } catch (e){ console.error(e); }

// Accounts wiring
try { if (typeof wireAccountEvents === "function") wireAccountEvents(); } catch (e){ console.error(e); }

// Auto-repair already-saved corrupted kontonamn from standardlista (utan SIE)
try {
  if (typeof applyStdAccountsMapRepair === "function"){
    const r = applyStdAccountsMapRepair({ onlyReplacement: true });
    if (r && r.updated){
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (e){ console.error(e); }
    }
  }
} catch (e){ console.error(e); }

try { if (typeof renderAccounts === "function") renderAccounts(); } catch (e){ console.error(e); }

// Invoices init
state.customers = state.customers || {};
state.suppliers = state.suppliers || {};
state.supplierInvoices = state.supplierInvoices || [];
state.invoices = state.invoices || [];
state.features = state.features || { sruEnabled: false };

try { if (invYearSelect) invYearSelect.value = state.activeYearId; } catch (e){ console.error(e); }
try { if (invDate) invDate.value = todayISO(); } catch (e){ console.error(e); }
try { if (invDue) invDue.value = addDays(todayISO(), (state.company.payDays||30)); } catch (e){ console.error(e); }

try { if (siYearSelect) siYearSelect.value = state.activeYearId; } catch (e){ console.error(e); }
try { if (typeof wireSupplierRegistryEvents === "function") wireSupplierRegistryEvents(); } catch (e){ console.error(e); }
try { if (typeof renderSuppliers === "function") renderSuppliers(); } catch (e){ console.error(e); }
try { if (typeof wireSupplierInvoiceEvents === "function") wireSupplierInvoiceEvents(); } catch (e){ console.error(e); }
try { if (typeof newSupplierInvoice === "function") newSupplierInvoice(); } catch (e){ console.error(e); }
try { if (typeof renderSupplierInvoices === "function") renderSupplierInvoices(); } catch (e){ console.error(e); }

try { if (typeof wireInvoiceEvents === "function") wireInvoiceEvents(); } catch (e){ console.error(e); }
try { if (typeof newInvoice === "function") newInvoice(); } catch (e){ console.error(e); }
try { if (typeof renderAll === "function") renderAll(); } catch (e){ console.error(e); }

// --- Import/Export wiring ---
if (btnExportJson) btnExportJson.addEventListener("click", (e)=>{ e.preventDefault(); exportBackupJson(); });
if (jsonImport) jsonImport.addEventListener("change", async (e)=>{
  const f = jsonImport.files && jsonImport.files[0];
  if (!f) return;
  try { await importBackupJsonFile(f); }
  catch(err){ console.error(err); showToast("Kunde inte importera JSON. Se konsolen.", 8000); }
  finally { jsonImport.value = ""; }
});
if (btnWipe) btnWipe.addEventListener("click", async (e)=>{ e.preventDefault(); await wipeAllData(); });

// Auto-backup UI wiring
try {
  const btnChooseBackupDir = document.getElementById("btnChooseBackupDir");
  const chkAutoBackup = document.getElementById("chkAutoBackup");
  if (btnChooseBackupDir) btnChooseBackupDir.addEventListener("click", async (e)=>{ e.preventDefault(); await chooseBackupFolder(); });
  if (chkAutoBackup) chkAutoBackup.addEventListener("change", async ()=>{
    setAutoBackupEnabled(!!chkAutoBackup.checked);
    updateBackupUI();
    // If user just enabled it and a folder exists, we can create today's backup (user interaction already happened)
    try { await maybeDailyAutoBackup("toggle-enabled"); } catch {}
  });
} catch (e){ console.error(e); }

if (btnExportSie4) btnExportSie4.addEventListener("click", (e)=>{
  e.preventDefault();
  exportSie4((sieYearSelect && sieYearSelect.value) || state.activeYearId);
});

if (sieImportFile) sieImportFile.addEventListener("change", ()=>{
  try{
    const fs = sieImportFile.files ? Array.from(sieImportFile.files) : [];
    const names = fs.map(f=>f && f.name ? f.name : "").filter(Boolean);
    const txt = names.length ? (names.length === 1 ? names[0] : (names.length + " filer: " + names.join(", "))) : "Ingen fil vald";
    if (sieImportFileName) sieImportFileName.textContent = txt;
  } catch(e){ console.error(e); }
});
if (btnImportSie) btnImportSie.addEventListener("click", async (e)=>{
  e.preventDefault();
  const fs = (sieImportFile && sieImportFile.files) ? Array.from(sieImportFile.files) : [];
  if (!fs.length) return showToast("Välj en SIE-fil först.", 3500);
  const enc = (sieImportEncoding && sieImportEncoding.value) || "utf-8";
  const wipe = !!(sieImportWipe && sieImportWipe.checked);

  try{
    const parallel = !!(sieImportParallel && sieImportParallel.checked);

    if (parallel){
      // Read/decode files in parallel for speed, then apply merges sequentially (safe for state mutation).
      const decoded = await Promise.all(fs.map(async (f)=>{
        const buf = await f.arrayBuffer();
        const preferred = String(enc || "utf-8");
        const dec = decodeWithBestEncoding(buf, preferred);
        if (dec.enc && String(dec.enc) !== String(preferred)){
          showToast(`Teckenkodning (${f.name}): använde ${dec.enc} (i stället för ${preferred}) för att undvika "�".`, 6500);
        }
        return { file: f, text: dec.text };
      }));
      for (let i = 0; i < decoded.length; i++){
        const d = decoded[i];
        await importSieText(d.text, wipe && i===0, d.file && d.file.name ? d.file.name : "");
      }
    } else {
      // Import each file in order. If wipe is checked, we wipe once before the first import.
      for (let i = 0; i < fs.length; i++){
        const f = fs[i];
        await importSieFile(f, enc, wipe && i===0);
      }
    }
  } catch(err){
    console.error(err);
    showToast("Kunde inte importera SIE. Se konsolen.", 8000);
  } finally {
    // Reset so user can pick another file (and so we don't accidentally re-import an old selection)
    try { if (sieImportFile) sieImportFile.value = ""; } catch {}
    try { if (sieImportFileName) sieImportFileName.textContent = "Ingen fil vald"; } catch {}
    try { if (sieImportWipe) sieImportWipe.checked = false; } catch {}
    try { if (sieImportParallel) sieImportParallel.checked = false; } catch {}
  }
});

// --- Company Registry wiring (multi-company) ---
if (companySelect) companySelect.addEventListener("change", async ()=>{
  try {
    const targetId = String(companySelect.value || "").trim();
    if (!targetId){
      await fsDisconnect();
      showToast("Inget företag valt.", 2500);
      return;
    }
    if (CompanyManager.getActiveCompanyId && CompanyManager.getActiveCompanyId() === targetId) return;

    await maybeSilentAutosaveToFile("switch-company");
    await CompanyManager.setActiveCompany(targetId);

    // Clear local state to avoid mixing companies if load fails
    try { await wipeLocalDataForNewDataFile(); } catch {}

    if (!fsHandle){
      showToast("Företaget saknar kopplad datafil.", 4500);
      return;
    }

    try {
      await fsLoadState();
      showToast("Bytte företag.", 2500);
    } catch (e){
      console.error(e);
      showToast("Kunde inte ladda företagets datafil. Se konsolen.", 7000);
    }
  } catch (e){
    console.error(e);
  }
});

// --- File Sync wiring (UI moved to Settings) ---
if (btnConnectFile) btnConnectFile.addEventListener("click", async (e)=>{ e.preventDefault(); await fsConnectExisting(); });
if (btnCreateFile) btnCreateFile.addEventListener("click", async (e)=>{ e.preventDefault(); await fsCreateNew(); });
if (btnLoadFromFile) btnLoadFromFile.addEventListener("click", async (e)=>{
  e.preventDefault();
  try {
    await fsLoadState();
    fillYearSelectors();
    try { if (typeof renderAll === "function") renderAll(); } catch (e){ console.error(e); }
    showToast("Laddade data från fil.", 3500);
  }
  catch(err){ console.error(err); showToast("Kunde inte läsa från fil. Se konsolen.", 8000); }
});
if (btnSaveToFile) btnSaveToFile.addEventListener("click", async (e)=>{
  e.preventDefault();
  try { await fsWriteState(); showToast("Sparade till fil.", 3000); }
  catch(err){ console.error(err); showToast("Kunde inte spara till fil. Se konsolen.", 8000); }
});
if (btnDisconnectFile) btnDisconnectFile.addEventListener("click", async (e)=>{ e.preventDefault(); await fsDisconnect(); });

if (fsAutosave) fsAutosave.addEventListener("change", ()=>{ state.fileSync = state.fileSync || { autosave:true, requireFile:false }; state.fileSync.autosave = !!fsAutosave.checked; save(); updateFsUI(); });
if (fsRequireFile) fsRequireFile.addEventListener("change", ()=>{ state.fileSync = state.fileSync || { autosave:true, requireFile:false }; state.fileSync.requireFile = !!fsRequireFile.checked; save(); updateFsUI(); });

// Init company registry + restore active company handles (and attempt silent auto-load)
(async ()=>{
  try {
    await CompanyManager.init();
    CompanyManager.updateCompanySelectUI();
  } catch (e){
    console.error(e);
  }

  try { updateFsUI(); } catch (e){ /* ignore */ }
  try { updateBackupUI(); } catch (e){ /* ignore */ }

  if (CompanyManager.hasActiveCompany() && fsHandle){
    fsLastError = null;
    updateFsUI();

    // 1) Silent auto-load (no permission prompts) if permission already granted
    try {
      const ok = await fsEnsurePermission(false);
      if (ok){
        await fsLoadState();
        showToast("Auto-laddade data från datafil.", 2500);
      } else {
        // 2) Otherwise: load on first user interaction (prompts once)
        const once = async ()=>{
          document.removeEventListener("pointerdown", once, true);
          try {
            const ok2 = await fsEnsurePermission(true);
            if (ok2){
              await fsLoadState();
              showToast("Laddade data från datafil.", 2500);
            }
          } catch (err){
            console.error(err);
          }
          try { updateFsUI(); } catch (e){ /* ignore */ }
          try { updateBackupUI(); } catch (e){ /* ignore */ }
        };
        document.addEventListener("pointerdown", once, true);
      }
    } catch (err){
      console.error(err);
    }
  }

  // Attempt daily autobackup (silent) for active company
  try {
    await maybeDailyAutoBackup("startup");
  } catch {}
})();


  // --- Arkivering ---
  if (btnMakeArchive){
    btnMakeArchive.addEventListener("click", async (e)=>{
      e.preventDefault();
      try { await makeArchive((archiveYearSelect && archiveYearSelect.value) || state.activeYearId); }
      catch(err){ console.error(err); showToast("Kunde inte skapa arkiv. Se konsolen för detaljer.", 8000); }
    });
  }
  if (btnMakeArchiveFolder){
    btnMakeArchiveFolder.addEventListener("click", async (e)=>{
      e.preventDefault();
      try { await makeArchiveFolder((archiveYearSelect && archiveYearSelect.value) || state.activeYearId); }
      catch(err){ console.error(err); showToast("Kunde inte skapa arkivmapp. Se konsolen för detaljer.", 8000); }
    });
  }
  if (btnVerifyArchive){
    btnVerifyArchive.addEventListener("click", async (e)=>{
      e.preventDefault();
      try { await verifyArchive(); }
      catch(err){ console.error(err); showToast("Kunde inte verifiera arkiv. Se konsolen för detaljer.", 8000); }
    });
  }

  // Capture fallback (if clicks are intercepted by overlays)
  document.addEventListener("click", (e)=>{
    const b1 = e.target && e.target.closest ? e.target.closest("#btnMakeArchive") : null;
    const b2 = e.target && e.target.closest ? e.target.closest("#btnVerifyArchive") : null;
    const b3 = e.target && e.target.closest ? e.target.closest("#btnMakeArchiveFolder") : null;
    if (b1){
      e.preventDefault();
      makeArchive((archiveYearSelect && archiveYearSelect.value) || state.activeYearId);
    }
    if (b2){
      e.preventDefault();
      verifyArchive();
    }
    if (b3){
      e.preventDefault();
      makeArchiveFolder((archiveYearSelect && archiveYearSelect.value) || state.activeYearId);
    }
  }, true);
})();
</script>
</body>
</html>